/**
 * Generated by Scrooge
 *   version: 18.10.0
 *   rev: dda071e1412b53f4bfdebc19e474f584e475d475
 *   built at: 20181018-174244
 */
package modeldb

import com.twitter.scrooge.ThriftEnum
import scala.collection.immutable.{Map => immutable$Map}


@javax.annotation.Generated(value = Array("com.twitter.scrooge.Compiler"))
case object ModelCompMetric extends _root_.com.twitter.scrooge.ThriftEnumObject[ModelCompMetric] {

  val annotations: immutable$Map[String, String] = immutable$Map.empty

  
  case object Project extends modeldb.ModelCompMetric {
    val value: Int = 0
    val name: String = "Project"
    val originalName: String = "PROJECT"
    val annotations: immutable$Map[String, String] = immutable$Map.empty
  }

  private[this] val _SomeProject = _root_.scala.Some(modeldb.ModelCompMetric.Project)
  
  case object ExperimentRun extends modeldb.ModelCompMetric {
    val value: Int = 1
    val name: String = "ExperimentRun"
    val originalName: String = "EXPERIMENT_RUN"
    val annotations: immutable$Map[String, String] = immutable$Map.empty
  }

  private[this] val _SomeExperimentRun = _root_.scala.Some(modeldb.ModelCompMetric.ExperimentRun)
  
  case object ModelType extends modeldb.ModelCompMetric {
    val value: Int = 2
    val name: String = "ModelType"
    val originalName: String = "MODEL_TYPE"
    val annotations: immutable$Map[String, String] = immutable$Map.empty
  }

  private[this] val _SomeModelType = _root_.scala.Some(modeldb.ModelCompMetric.ModelType)
  
  case object ProblemType extends modeldb.ModelCompMetric {
    val value: Int = 3
    val name: String = "ProblemType"
    val originalName: String = "PROBLEM_TYPE"
    val annotations: immutable$Map[String, String] = immutable$Map.empty
  }

  private[this] val _SomeProblemType = _root_.scala.Some(modeldb.ModelCompMetric.ProblemType)
  
  case object Rmse extends modeldb.ModelCompMetric {
    val value: Int = 4
    val name: String = "Rmse"
    val originalName: String = "RMSE"
    val annotations: immutable$Map[String, String] = immutable$Map.empty
  }

  private[this] val _SomeRmse = _root_.scala.Some(modeldb.ModelCompMetric.Rmse)
  
  case object ExplainedVariance extends modeldb.ModelCompMetric {
    val value: Int = 5
    val name: String = "ExplainedVariance"
    val originalName: String = "EXPLAINED_VARIANCE"
    val annotations: immutable$Map[String, String] = immutable$Map.empty
  }

  private[this] val _SomeExplainedVariance = _root_.scala.Some(modeldb.ModelCompMetric.ExplainedVariance)
  
  case object R2 extends modeldb.ModelCompMetric {
    val value: Int = 6
    val name: String = "R2"
    val originalName: String = "R2"
    val annotations: immutable$Map[String, String] = immutable$Map.empty
  }

  private[this] val _SomeR2 = _root_.scala.Some(modeldb.ModelCompMetric.R2)

  case class EnumUnknownModelCompMetric(value: Int)
    extends modeldb.ModelCompMetric with _root_.com.twitter.scrooge.EnumItemUnknown
  {
    val name: String = "EnumUnknownModelCompMetric" + value
    def originalName: String = name
  }

  /**
   * Find the enum by its integer value, as defined in the Thrift IDL.
   */
  def apply(value: Int): modeldb.ModelCompMetric =
    value match {
      case 0 => modeldb.ModelCompMetric.Project
      case 1 => modeldb.ModelCompMetric.ExperimentRun
      case 2 => modeldb.ModelCompMetric.ModelType
      case 3 => modeldb.ModelCompMetric.ProblemType
      case 4 => modeldb.ModelCompMetric.Rmse
      case 5 => modeldb.ModelCompMetric.ExplainedVariance
      case 6 => modeldb.ModelCompMetric.R2
      case _ => throw new NoSuchElementException(value.toString)
    }

  /**
   * Find the enum by its integer value, as defined in the Thrift IDL.
   * returns an EnumUnknownModelCompMetric(value) if the value is not found.
   * In particular this allows ignoring new values added to an enum
   * in the IDL on the producer side when the consumer was not updated.
   */
  def getOrUnknown(value: Int): modeldb.ModelCompMetric =
    get(value) match {
      case _root_.scala.Some(e) => e
      case _root_.scala.None => EnumUnknownModelCompMetric(value)
    }

  /**
   * Find the enum by its integer value, as defined in the Thrift IDL.
   * Returns None if the value is not found
   */
  def get(value: Int): _root_.scala.Option[modeldb.ModelCompMetric] =
    value match {
      case 0 => _SomeProject
      case 1 => _SomeExperimentRun
      case 2 => _SomeModelType
      case 3 => _SomeProblemType
      case 4 => _SomeRmse
      case 5 => _SomeExplainedVariance
      case 6 => _SomeR2
      case _ => _root_.scala.None
    }

  def valueOf(name: String): _root_.scala.Option[modeldb.ModelCompMetric] =
    name.toLowerCase match {
      case "project" => _SomeProject
      case "experimentrun" => _SomeExperimentRun
      case "modeltype" => _SomeModelType
      case "problemtype" => _SomeProblemType
      case "rmse" => _SomeRmse
      case "explainedvariance" => _SomeExplainedVariance
      case "r2" => _SomeR2
      case _ => _root_.scala.None
    }

  lazy val list: List[modeldb.ModelCompMetric] = scala.List[modeldb.ModelCompMetric](
    modeldb.ModelCompMetric.Project,
    modeldb.ModelCompMetric.ExperimentRun,
    modeldb.ModelCompMetric.ModelType,
    modeldb.ModelCompMetric.ProblemType,
    modeldb.ModelCompMetric.Rmse,
    modeldb.ModelCompMetric.ExplainedVariance,
    modeldb.ModelCompMetric.R2
  )
}



@javax.annotation.Generated(value = Array("com.twitter.scrooge.Compiler"))
sealed trait ModelCompMetric extends ThriftEnum with Serializable