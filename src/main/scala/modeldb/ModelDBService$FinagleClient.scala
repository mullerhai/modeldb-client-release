/**
 * Generated by Scrooge
 *   version: 18.10.0
 *   rev: dda071e1412b53f4bfdebc19e474f584e475d475
 *   built at: 20181018-174244
 */
package modeldb

import com.twitter.finagle.SourcedException
import com.twitter.finagle.{service => ctfs}
import com.twitter.finagle.stats.{NullStatsReceiver, StatsReceiver}
import com.twitter.finagle.thrift.{Protocols,RichClientParam, ThriftClientRequest}
import com.twitter.scrooge.{TReusableBuffer, ThriftStruct, ThriftStructCodec}
import com.twitter.util.{Future, Return, Throw, Throwables}
import java.nio.ByteBuffer
import java.util.Arrays
import org.apache.thrift.protocol._
import org.apache.thrift.TApplicationException
import org.apache.thrift.transport.TMemoryInputTransport
import scala.collection.{Map, Set}
import scala.language.higherKinds


@javax.annotation.Generated(value = Array("com.twitter.scrooge.Compiler"))
class ModelDBService$FinagleClient(
    val service: com.twitter.finagle.Service[ThriftClientRequest, Array[Byte]],
    val clientParam: RichClientParam)
  extends ModelDBService[Future] {

  @deprecated("Use com.twitter.finagle.thrift.RichClientParam", "2017-08-16")
  def this(
    service: com.twitter.finagle.Service[ThriftClientRequest, Array[Byte]],
    protocolFactory: TProtocolFactory = Protocols.binaryFactory(),
    serviceName: String = "ModelDBService",
    stats: StatsReceiver = NullStatsReceiver,
    responseClassifier: ctfs.ResponseClassifier = ctfs.ResponseClassifier.Default
  ) = this(
    service,
    RichClientParam(
      protocolFactory,
      serviceName,
      clientStats = stats,
      responseClassifier = responseClassifier
    )
  )

  @deprecated("Use com.twitter.finagle.thrift.RichClientParam", "2017-08-16")
  def this(
    service: com.twitter.finagle.Service[ThriftClientRequest, Array[Byte]],
    protocolFactory: TProtocolFactory,
    serviceName: String,
    stats: StatsReceiver
  ) = this(service, protocolFactory, serviceName, stats, ctfs.ResponseClassifier.Default)

  import ModelDBService._

  def serviceName: String = clientParam.serviceName

  override def asClosable: _root_.com.twitter.util.Closable = service

  private[this] def protocolFactory: TProtocolFactory = clientParam.restrictedProtocolFactory
  private[this] def maxReusableBufferSize: Int = clientParam.maxThriftBufferSize

  private[this] val tlReusableBuffer = TReusableBuffer(maxThriftBufferSize = maxReusableBufferSize)

  protected def encodeRequest(name: String, args: ThriftStruct) = {
    val memoryBuffer = tlReusableBuffer.get()
    try {
      val oprot = protocolFactory.getProtocol(memoryBuffer)

      oprot.writeMessageBegin(new TMessage(name, TMessageType.CALL, 0))
      args.write(oprot)
      oprot.writeMessageEnd()
      oprot.getTransport().flush()
      val bytes = Arrays.copyOfRange(memoryBuffer.getArray(), 0, memoryBuffer.length())
      new ThriftClientRequest(bytes, false)
    } finally {
      tlReusableBuffer.reset()
    }
  }

  protected def decodeResponse[T <: ThriftStruct](resBytes: Array[Byte], codec: ThriftStructCodec[T]) = {
    val iprot = protocolFactory.getProtocol(new TMemoryInputTransport(resBytes))
    val msg = iprot.readMessageBegin()
    try {
      if (msg.`type` == TMessageType.EXCEPTION) {
        val exception = TApplicationException.readFrom(iprot) match {
          case sourced: SourcedException =>
            if (serviceName != "") sourced.serviceName = serviceName
            sourced
          case e => e
        }
        throw exception
      } else {
        codec.decode(iprot)
      }
    } finally {
      iprot.readMessageEnd()
    }
  }

  protected def missingResult(name: String) = {
    new TApplicationException(
      TApplicationException.MISSING_RESULT,
      name + " failed: unknown result"
    )
  }

  protected def setServiceName(ex: Throwable): Throwable =
    if (this.serviceName == "") ex
    else {
      ex match {
        case se: SourcedException =>
          se.serviceName = this.serviceName
          se
        case _ => ex
      }
    }

  // ----- end boilerplate.

  private[this] def stats: StatsReceiver = clientParam.clientStats
  private[this] def responseClassifier: ctfs.ResponseClassifier = clientParam.responseClassifier

  private[this] val scopedStats = if (serviceName != "") stats.scope(serviceName) else stats
  private[this] object __stats_testConnection {
    val RequestsCounter = scopedStats.scope("testConnection").counter("requests")
    val SuccessCounter = scopedStats.scope("testConnection").counter("success")
    val FailuresCounter = scopedStats.scope("testConnection").counter("failures")
    val FailuresScope = scopedStats.scope("testConnection").scope("failures")
  }
  val testConnectionModelDBServiceReplyDeserializer: Array[Byte] => _root_.com.twitter.util.Try[Int] = {
    response: Array[Byte] => {
      val result = decodeResponse(response, TestConnection.Result)
  
      result.firstException() match {
        case Some(exception) => _root_.com.twitter.util.Throw(setServiceName(exception))
        case _ => result.successField match {
          case Some(success) => _root_.com.twitter.util.Return(success)
          case _ => _root_.com.twitter.util.Throw(missingResult("testConnection"))
        }
      }
    }
  }
  
  def testConnection(): Future[Int] = {
    __stats_testConnection.RequestsCounter.incr()
    val inputArgs = TestConnection.Args()
  
    val serdeCtx = new _root_.com.twitter.finagle.thrift.ClientDeserializeCtx[Int](inputArgs, testConnectionModelDBServiceReplyDeserializer)
    _root_.com.twitter.finagle.context.Contexts.local.let(
      _root_.com.twitter.finagle.thrift.ClientDeserializeCtx.Key,
      serdeCtx,
      _root_.com.twitter.finagle.thrift.Headers.Request.Key,
      _root_.com.twitter.finagle.thrift.Headers.Request.newValues
    ) {
      val serialized = encodeRequest("testConnection", inputArgs)
      this.service(serialized).flatMap { response =>
        Future.const(serdeCtx.deserialize(response))
      }.respond { response =>
        val responseClass = responseClassifier.applyOrElse(
          ctfs.ReqRep(inputArgs, response),
          ctfs.ResponseClassifier.Default)
        responseClass match {
          case ctfs.ResponseClass.Successful(_) =>
            __stats_testConnection.SuccessCounter.incr()
          case ctfs.ResponseClass.Failed(_) =>
            __stats_testConnection.FailuresCounter.incr()
            response match {
              case Throw(ex) =>
                setServiceName(ex)
                __stats_testConnection.FailuresScope.counter(Throwables.mkString(ex): _*).incr()
              case _ =>
            }
        }
      }
    }
  }
  private[this] object __stats_storeDataFrame {
    val RequestsCounter = scopedStats.scope("storeDataFrame").counter("requests")
    val SuccessCounter = scopedStats.scope("storeDataFrame").counter("success")
    val FailuresCounter = scopedStats.scope("storeDataFrame").counter("failures")
    val FailuresScope = scopedStats.scope("storeDataFrame").scope("failures")
  }
  val storeDataFrameModelDBServiceReplyDeserializer: Array[Byte] => _root_.com.twitter.util.Try[Int] = {
    response: Array[Byte] => {
      val result = decodeResponse(response, StoreDataFrame.Result)
  
      result.firstException() match {
        case Some(exception) => _root_.com.twitter.util.Throw(setServiceName(exception))
        case _ => result.successField match {
          case Some(success) => _root_.com.twitter.util.Return(success)
          case _ => _root_.com.twitter.util.Throw(missingResult("storeDataFrame"))
        }
      }
    }
  }
  
  def storeDataFrame(df: modeldb.DataFrame, experimentRunId: Int): Future[Int] = {
    __stats_storeDataFrame.RequestsCounter.incr()
    val inputArgs = StoreDataFrame.Args(df, experimentRunId)
  
    val serdeCtx = new _root_.com.twitter.finagle.thrift.ClientDeserializeCtx[Int](inputArgs, storeDataFrameModelDBServiceReplyDeserializer)
    _root_.com.twitter.finagle.context.Contexts.local.let(
      _root_.com.twitter.finagle.thrift.ClientDeserializeCtx.Key,
      serdeCtx,
      _root_.com.twitter.finagle.thrift.Headers.Request.Key,
      _root_.com.twitter.finagle.thrift.Headers.Request.newValues
    ) {
      val serialized = encodeRequest("storeDataFrame", inputArgs)
      this.service(serialized).flatMap { response =>
        Future.const(serdeCtx.deserialize(response))
      }.respond { response =>
        val responseClass = responseClassifier.applyOrElse(
          ctfs.ReqRep(inputArgs, response),
          ctfs.ResponseClassifier.Default)
        responseClass match {
          case ctfs.ResponseClass.Successful(_) =>
            __stats_storeDataFrame.SuccessCounter.incr()
          case ctfs.ResponseClass.Failed(_) =>
            __stats_storeDataFrame.FailuresCounter.incr()
            response match {
              case Throw(ex) =>
                setServiceName(ex)
                __stats_storeDataFrame.FailuresScope.counter(Throwables.mkString(ex): _*).incr()
              case _ =>
            }
        }
      }
    }
  }
  private[this] object __stats_pathForTransformer {
    val RequestsCounter = scopedStats.scope("pathForTransformer").counter("requests")
    val SuccessCounter = scopedStats.scope("pathForTransformer").counter("success")
    val FailuresCounter = scopedStats.scope("pathForTransformer").counter("failures")
    val FailuresScope = scopedStats.scope("pathForTransformer").scope("failures")
  }
  val pathForTransformerModelDBServiceReplyDeserializer: Array[Byte] => _root_.com.twitter.util.Try[String] = {
    response: Array[Byte] => {
      val result = decodeResponse(response, PathForTransformer.Result)
  
      result.firstException() match {
        case Some(exception) => _root_.com.twitter.util.Throw(setServiceName(exception))
        case _ => result.successField match {
          case Some(success) => _root_.com.twitter.util.Return(success)
          case _ => _root_.com.twitter.util.Throw(missingResult("pathForTransformer"))
        }
      }
    }
  }
  
  def pathForTransformer(transformerId: Int): Future[String] = {
    __stats_pathForTransformer.RequestsCounter.incr()
    val inputArgs = PathForTransformer.Args(transformerId)
  
    val serdeCtx = new _root_.com.twitter.finagle.thrift.ClientDeserializeCtx[String](inputArgs, pathForTransformerModelDBServiceReplyDeserializer)
    _root_.com.twitter.finagle.context.Contexts.local.let(
      _root_.com.twitter.finagle.thrift.ClientDeserializeCtx.Key,
      serdeCtx,
      _root_.com.twitter.finagle.thrift.Headers.Request.Key,
      _root_.com.twitter.finagle.thrift.Headers.Request.newValues
    ) {
      val serialized = encodeRequest("pathForTransformer", inputArgs)
      this.service(serialized).flatMap { response =>
        Future.const(serdeCtx.deserialize(response))
      }.respond { response =>
        val responseClass = responseClassifier.applyOrElse(
          ctfs.ReqRep(inputArgs, response),
          ctfs.ResponseClassifier.Default)
        responseClass match {
          case ctfs.ResponseClass.Successful(_) =>
            __stats_pathForTransformer.SuccessCounter.incr()
          case ctfs.ResponseClass.Failed(_) =>
            __stats_pathForTransformer.FailuresCounter.incr()
            response match {
              case Throw(ex) =>
                setServiceName(ex)
                __stats_pathForTransformer.FailuresScope.counter(Throwables.mkString(ex): _*).incr()
              case _ =>
            }
        }
      }
    }
  }
  private[this] object __stats_storeFitEvent {
    val RequestsCounter = scopedStats.scope("storeFitEvent").counter("requests")
    val SuccessCounter = scopedStats.scope("storeFitEvent").counter("success")
    val FailuresCounter = scopedStats.scope("storeFitEvent").counter("failures")
    val FailuresScope = scopedStats.scope("storeFitEvent").scope("failures")
  }
  val storeFitEventModelDBServiceReplyDeserializer: Array[Byte] => _root_.com.twitter.util.Try[modeldb.FitEventResponse] = {
    response: Array[Byte] => {
      val result = decodeResponse(response, StoreFitEvent.Result)
  
      result.firstException() match {
        case Some(exception) => _root_.com.twitter.util.Throw(setServiceName(exception))
        case _ => result.successField match {
          case Some(success) => _root_.com.twitter.util.Return(success)
          case _ => _root_.com.twitter.util.Throw(missingResult("storeFitEvent"))
        }
      }
    }
  }
  
  def storeFitEvent(fe: modeldb.FitEvent): Future[modeldb.FitEventResponse] = {
    __stats_storeFitEvent.RequestsCounter.incr()
    val inputArgs = StoreFitEvent.Args(fe)
  
    val serdeCtx = new _root_.com.twitter.finagle.thrift.ClientDeserializeCtx[modeldb.FitEventResponse](inputArgs, storeFitEventModelDBServiceReplyDeserializer)
    _root_.com.twitter.finagle.context.Contexts.local.let(
      _root_.com.twitter.finagle.thrift.ClientDeserializeCtx.Key,
      serdeCtx,
      _root_.com.twitter.finagle.thrift.Headers.Request.Key,
      _root_.com.twitter.finagle.thrift.Headers.Request.newValues
    ) {
      val serialized = encodeRequest("storeFitEvent", inputArgs)
      this.service(serialized).flatMap { response =>
        Future.const(serdeCtx.deserialize(response))
      }.respond { response =>
        val responseClass = responseClassifier.applyOrElse(
          ctfs.ReqRep(inputArgs, response),
          ctfs.ResponseClassifier.Default)
        responseClass match {
          case ctfs.ResponseClass.Successful(_) =>
            __stats_storeFitEvent.SuccessCounter.incr()
          case ctfs.ResponseClass.Failed(_) =>
            __stats_storeFitEvent.FailuresCounter.incr()
            response match {
              case Throw(ex) =>
                setServiceName(ex)
                __stats_storeFitEvent.FailuresScope.counter(Throwables.mkString(ex): _*).incr()
              case _ =>
            }
        }
      }
    }
  }
  private[this] object __stats_storeMetricEvent {
    val RequestsCounter = scopedStats.scope("storeMetricEvent").counter("requests")
    val SuccessCounter = scopedStats.scope("storeMetricEvent").counter("success")
    val FailuresCounter = scopedStats.scope("storeMetricEvent").counter("failures")
    val FailuresScope = scopedStats.scope("storeMetricEvent").scope("failures")
  }
  val storeMetricEventModelDBServiceReplyDeserializer: Array[Byte] => _root_.com.twitter.util.Try[modeldb.MetricEventResponse] = {
    response: Array[Byte] => {
      val result = decodeResponse(response, StoreMetricEvent.Result)
  
      result.firstException() match {
        case Some(exception) => _root_.com.twitter.util.Throw(setServiceName(exception))
        case _ => result.successField match {
          case Some(success) => _root_.com.twitter.util.Return(success)
          case _ => _root_.com.twitter.util.Throw(missingResult("storeMetricEvent"))
        }
      }
    }
  }
  
  def storeMetricEvent(me: modeldb.MetricEvent): Future[modeldb.MetricEventResponse] = {
    __stats_storeMetricEvent.RequestsCounter.incr()
    val inputArgs = StoreMetricEvent.Args(me)
  
    val serdeCtx = new _root_.com.twitter.finagle.thrift.ClientDeserializeCtx[modeldb.MetricEventResponse](inputArgs, storeMetricEventModelDBServiceReplyDeserializer)
    _root_.com.twitter.finagle.context.Contexts.local.let(
      _root_.com.twitter.finagle.thrift.ClientDeserializeCtx.Key,
      serdeCtx,
      _root_.com.twitter.finagle.thrift.Headers.Request.Key,
      _root_.com.twitter.finagle.thrift.Headers.Request.newValues
    ) {
      val serialized = encodeRequest("storeMetricEvent", inputArgs)
      this.service(serialized).flatMap { response =>
        Future.const(serdeCtx.deserialize(response))
      }.respond { response =>
        val responseClass = responseClassifier.applyOrElse(
          ctfs.ReqRep(inputArgs, response),
          ctfs.ResponseClassifier.Default)
        responseClass match {
          case ctfs.ResponseClass.Successful(_) =>
            __stats_storeMetricEvent.SuccessCounter.incr()
          case ctfs.ResponseClass.Failed(_) =>
            __stats_storeMetricEvent.FailuresCounter.incr()
            response match {
              case Throw(ex) =>
                setServiceName(ex)
                __stats_storeMetricEvent.FailuresScope.counter(Throwables.mkString(ex): _*).incr()
              case _ =>
            }
        }
      }
    }
  }
  private[this] object __stats_getFilePath {
    val RequestsCounter = scopedStats.scope("getFilePath").counter("requests")
    val SuccessCounter = scopedStats.scope("getFilePath").counter("success")
    val FailuresCounter = scopedStats.scope("getFilePath").counter("failures")
    val FailuresScope = scopedStats.scope("getFilePath").scope("failures")
  }
  val getFilePathModelDBServiceReplyDeserializer: Array[Byte] => _root_.com.twitter.util.Try[String] = {
    response: Array[Byte] => {
      val result = decodeResponse(response, GetFilePath.Result)
  
      result.firstException() match {
        case Some(exception) => _root_.com.twitter.util.Throw(setServiceName(exception))
        case _ => result.successField match {
          case Some(success) => _root_.com.twitter.util.Return(success)
          case _ => _root_.com.twitter.util.Throw(missingResult("getFilePath"))
        }
      }
    }
  }
  
  def getFilePath(t: modeldb.Transformer, experimentRunId: Int, filename: String): Future[String] = {
    __stats_getFilePath.RequestsCounter.incr()
    val inputArgs = GetFilePath.Args(t, experimentRunId, filename)
  
    val serdeCtx = new _root_.com.twitter.finagle.thrift.ClientDeserializeCtx[String](inputArgs, getFilePathModelDBServiceReplyDeserializer)
    _root_.com.twitter.finagle.context.Contexts.local.let(
      _root_.com.twitter.finagle.thrift.ClientDeserializeCtx.Key,
      serdeCtx,
      _root_.com.twitter.finagle.thrift.Headers.Request.Key,
      _root_.com.twitter.finagle.thrift.Headers.Request.newValues
    ) {
      val serialized = encodeRequest("getFilePath", inputArgs)
      this.service(serialized).flatMap { response =>
        Future.const(serdeCtx.deserialize(response))
      }.respond { response =>
        val responseClass = responseClassifier.applyOrElse(
          ctfs.ReqRep(inputArgs, response),
          ctfs.ResponseClassifier.Default)
        responseClass match {
          case ctfs.ResponseClass.Successful(_) =>
            __stats_getFilePath.SuccessCounter.incr()
          case ctfs.ResponseClass.Failed(_) =>
            __stats_getFilePath.FailuresCounter.incr()
            response match {
              case Throw(ex) =>
                setServiceName(ex)
                __stats_getFilePath.FailuresScope.counter(Throwables.mkString(ex): _*).incr()
              case _ =>
            }
        }
      }
    }
  }
  private[this] object __stats_storeTransformEvent {
    val RequestsCounter = scopedStats.scope("storeTransformEvent").counter("requests")
    val SuccessCounter = scopedStats.scope("storeTransformEvent").counter("success")
    val FailuresCounter = scopedStats.scope("storeTransformEvent").counter("failures")
    val FailuresScope = scopedStats.scope("storeTransformEvent").scope("failures")
  }
  val storeTransformEventModelDBServiceReplyDeserializer: Array[Byte] => _root_.com.twitter.util.Try[modeldb.TransformEventResponse] = {
    response: Array[Byte] => {
      val result = decodeResponse(response, StoreTransformEvent.Result)
  
      result.firstException() match {
        case Some(exception) => _root_.com.twitter.util.Throw(setServiceName(exception))
        case _ => result.successField match {
          case Some(success) => _root_.com.twitter.util.Return(success)
          case _ => _root_.com.twitter.util.Throw(missingResult("storeTransformEvent"))
        }
      }
    }
  }
  
  def storeTransformEvent(te: modeldb.TransformEvent): Future[modeldb.TransformEventResponse] = {
    __stats_storeTransformEvent.RequestsCounter.incr()
    val inputArgs = StoreTransformEvent.Args(te)
  
    val serdeCtx = new _root_.com.twitter.finagle.thrift.ClientDeserializeCtx[modeldb.TransformEventResponse](inputArgs, storeTransformEventModelDBServiceReplyDeserializer)
    _root_.com.twitter.finagle.context.Contexts.local.let(
      _root_.com.twitter.finagle.thrift.ClientDeserializeCtx.Key,
      serdeCtx,
      _root_.com.twitter.finagle.thrift.Headers.Request.Key,
      _root_.com.twitter.finagle.thrift.Headers.Request.newValues
    ) {
      val serialized = encodeRequest("storeTransformEvent", inputArgs)
      this.service(serialized).flatMap { response =>
        Future.const(serdeCtx.deserialize(response))
      }.respond { response =>
        val responseClass = responseClassifier.applyOrElse(
          ctfs.ReqRep(inputArgs, response),
          ctfs.ResponseClassifier.Default)
        responseClass match {
          case ctfs.ResponseClass.Successful(_) =>
            __stats_storeTransformEvent.SuccessCounter.incr()
          case ctfs.ResponseClass.Failed(_) =>
            __stats_storeTransformEvent.FailuresCounter.incr()
            response match {
              case Throw(ex) =>
                setServiceName(ex)
                __stats_storeTransformEvent.FailuresScope.counter(Throwables.mkString(ex): _*).incr()
              case _ =>
            }
        }
      }
    }
  }
  private[this] object __stats_storeRandomSplitEvent {
    val RequestsCounter = scopedStats.scope("storeRandomSplitEvent").counter("requests")
    val SuccessCounter = scopedStats.scope("storeRandomSplitEvent").counter("success")
    val FailuresCounter = scopedStats.scope("storeRandomSplitEvent").counter("failures")
    val FailuresScope = scopedStats.scope("storeRandomSplitEvent").scope("failures")
  }
  val storeRandomSplitEventModelDBServiceReplyDeserializer: Array[Byte] => _root_.com.twitter.util.Try[modeldb.RandomSplitEventResponse] = {
    response: Array[Byte] => {
      val result = decodeResponse(response, StoreRandomSplitEvent.Result)
  
      result.firstException() match {
        case Some(exception) => _root_.com.twitter.util.Throw(setServiceName(exception))
        case _ => result.successField match {
          case Some(success) => _root_.com.twitter.util.Return(success)
          case _ => _root_.com.twitter.util.Throw(missingResult("storeRandomSplitEvent"))
        }
      }
    }
  }
  
  def storeRandomSplitEvent(rse: modeldb.RandomSplitEvent): Future[modeldb.RandomSplitEventResponse] = {
    __stats_storeRandomSplitEvent.RequestsCounter.incr()
    val inputArgs = StoreRandomSplitEvent.Args(rse)
  
    val serdeCtx = new _root_.com.twitter.finagle.thrift.ClientDeserializeCtx[modeldb.RandomSplitEventResponse](inputArgs, storeRandomSplitEventModelDBServiceReplyDeserializer)
    _root_.com.twitter.finagle.context.Contexts.local.let(
      _root_.com.twitter.finagle.thrift.ClientDeserializeCtx.Key,
      serdeCtx,
      _root_.com.twitter.finagle.thrift.Headers.Request.Key,
      _root_.com.twitter.finagle.thrift.Headers.Request.newValues
    ) {
      val serialized = encodeRequest("storeRandomSplitEvent", inputArgs)
      this.service(serialized).flatMap { response =>
        Future.const(serdeCtx.deserialize(response))
      }.respond { response =>
        val responseClass = responseClassifier.applyOrElse(
          ctfs.ReqRep(inputArgs, response),
          ctfs.ResponseClassifier.Default)
        responseClass match {
          case ctfs.ResponseClass.Successful(_) =>
            __stats_storeRandomSplitEvent.SuccessCounter.incr()
          case ctfs.ResponseClass.Failed(_) =>
            __stats_storeRandomSplitEvent.FailuresCounter.incr()
            response match {
              case Throw(ex) =>
                setServiceName(ex)
                __stats_storeRandomSplitEvent.FailuresScope.counter(Throwables.mkString(ex): _*).incr()
              case _ =>
            }
        }
      }
    }
  }
  private[this] object __stats_storePipelineEvent {
    val RequestsCounter = scopedStats.scope("storePipelineEvent").counter("requests")
    val SuccessCounter = scopedStats.scope("storePipelineEvent").counter("success")
    val FailuresCounter = scopedStats.scope("storePipelineEvent").counter("failures")
    val FailuresScope = scopedStats.scope("storePipelineEvent").scope("failures")
  }
  val storePipelineEventModelDBServiceReplyDeserializer: Array[Byte] => _root_.com.twitter.util.Try[modeldb.PipelineEventResponse] = {
    response: Array[Byte] => {
      val result = decodeResponse(response, StorePipelineEvent.Result)
  
      result.firstException() match {
        case Some(exception) => _root_.com.twitter.util.Throw(setServiceName(exception))
        case _ => result.successField match {
          case Some(success) => _root_.com.twitter.util.Return(success)
          case _ => _root_.com.twitter.util.Throw(missingResult("storePipelineEvent"))
        }
      }
    }
  }
  
  def storePipelineEvent(pipelineEvent: modeldb.PipelineEvent): Future[modeldb.PipelineEventResponse] = {
    __stats_storePipelineEvent.RequestsCounter.incr()
    val inputArgs = StorePipelineEvent.Args(pipelineEvent)
  
    val serdeCtx = new _root_.com.twitter.finagle.thrift.ClientDeserializeCtx[modeldb.PipelineEventResponse](inputArgs, storePipelineEventModelDBServiceReplyDeserializer)
    _root_.com.twitter.finagle.context.Contexts.local.let(
      _root_.com.twitter.finagle.thrift.ClientDeserializeCtx.Key,
      serdeCtx,
      _root_.com.twitter.finagle.thrift.Headers.Request.Key,
      _root_.com.twitter.finagle.thrift.Headers.Request.newValues
    ) {
      val serialized = encodeRequest("storePipelineEvent", inputArgs)
      this.service(serialized).flatMap { response =>
        Future.const(serdeCtx.deserialize(response))
      }.respond { response =>
        val responseClass = responseClassifier.applyOrElse(
          ctfs.ReqRep(inputArgs, response),
          ctfs.ResponseClassifier.Default)
        responseClass match {
          case ctfs.ResponseClass.Successful(_) =>
            __stats_storePipelineEvent.SuccessCounter.incr()
          case ctfs.ResponseClass.Failed(_) =>
            __stats_storePipelineEvent.FailuresCounter.incr()
            response match {
              case Throw(ex) =>
                setServiceName(ex)
                __stats_storePipelineEvent.FailuresScope.counter(Throwables.mkString(ex): _*).incr()
              case _ =>
            }
        }
      }
    }
  }
  private[this] object __stats_storeCrossValidationEvent {
    val RequestsCounter = scopedStats.scope("storeCrossValidationEvent").counter("requests")
    val SuccessCounter = scopedStats.scope("storeCrossValidationEvent").counter("success")
    val FailuresCounter = scopedStats.scope("storeCrossValidationEvent").counter("failures")
    val FailuresScope = scopedStats.scope("storeCrossValidationEvent").scope("failures")
  }
  val storeCrossValidationEventModelDBServiceReplyDeserializer: Array[Byte] => _root_.com.twitter.util.Try[modeldb.CrossValidationEventResponse] = {
    response: Array[Byte] => {
      val result = decodeResponse(response, StoreCrossValidationEvent.Result)
  
      result.firstException() match {
        case Some(exception) => _root_.com.twitter.util.Throw(setServiceName(exception))
        case _ => result.successField match {
          case Some(success) => _root_.com.twitter.util.Return(success)
          case _ => _root_.com.twitter.util.Throw(missingResult("storeCrossValidationEvent"))
        }
      }
    }
  }
  
  def storeCrossValidationEvent(cve: modeldb.CrossValidationEvent): Future[modeldb.CrossValidationEventResponse] = {
    __stats_storeCrossValidationEvent.RequestsCounter.incr()
    val inputArgs = StoreCrossValidationEvent.Args(cve)
  
    val serdeCtx = new _root_.com.twitter.finagle.thrift.ClientDeserializeCtx[modeldb.CrossValidationEventResponse](inputArgs, storeCrossValidationEventModelDBServiceReplyDeserializer)
    _root_.com.twitter.finagle.context.Contexts.local.let(
      _root_.com.twitter.finagle.thrift.ClientDeserializeCtx.Key,
      serdeCtx,
      _root_.com.twitter.finagle.thrift.Headers.Request.Key,
      _root_.com.twitter.finagle.thrift.Headers.Request.newValues
    ) {
      val serialized = encodeRequest("storeCrossValidationEvent", inputArgs)
      this.service(serialized).flatMap { response =>
        Future.const(serdeCtx.deserialize(response))
      }.respond { response =>
        val responseClass = responseClassifier.applyOrElse(
          ctfs.ReqRep(inputArgs, response),
          ctfs.ResponseClassifier.Default)
        responseClass match {
          case ctfs.ResponseClass.Successful(_) =>
            __stats_storeCrossValidationEvent.SuccessCounter.incr()
          case ctfs.ResponseClass.Failed(_) =>
            __stats_storeCrossValidationEvent.FailuresCounter.incr()
            response match {
              case Throw(ex) =>
                setServiceName(ex)
                __stats_storeCrossValidationEvent.FailuresScope.counter(Throwables.mkString(ex): _*).incr()
              case _ =>
            }
        }
      }
    }
  }
  private[this] object __stats_storeGridSearchCrossValidationEvent {
    val RequestsCounter = scopedStats.scope("storeGridSearchCrossValidationEvent").counter("requests")
    val SuccessCounter = scopedStats.scope("storeGridSearchCrossValidationEvent").counter("success")
    val FailuresCounter = scopedStats.scope("storeGridSearchCrossValidationEvent").counter("failures")
    val FailuresScope = scopedStats.scope("storeGridSearchCrossValidationEvent").scope("failures")
  }
  val storeGridSearchCrossValidationEventModelDBServiceReplyDeserializer: Array[Byte] => _root_.com.twitter.util.Try[modeldb.GridSearchCrossValidationEventResponse] = {
    response: Array[Byte] => {
      val result = decodeResponse(response, StoreGridSearchCrossValidationEvent.Result)
  
      result.firstException() match {
        case Some(exception) => _root_.com.twitter.util.Throw(setServiceName(exception))
        case _ => result.successField match {
          case Some(success) => _root_.com.twitter.util.Return(success)
          case _ => _root_.com.twitter.util.Throw(missingResult("storeGridSearchCrossValidationEvent"))
        }
      }
    }
  }
  
  def storeGridSearchCrossValidationEvent(gscve: modeldb.GridSearchCrossValidationEvent): Future[modeldb.GridSearchCrossValidationEventResponse] = {
    __stats_storeGridSearchCrossValidationEvent.RequestsCounter.incr()
    val inputArgs = StoreGridSearchCrossValidationEvent.Args(gscve)
  
    val serdeCtx = new _root_.com.twitter.finagle.thrift.ClientDeserializeCtx[modeldb.GridSearchCrossValidationEventResponse](inputArgs, storeGridSearchCrossValidationEventModelDBServiceReplyDeserializer)
    _root_.com.twitter.finagle.context.Contexts.local.let(
      _root_.com.twitter.finagle.thrift.ClientDeserializeCtx.Key,
      serdeCtx,
      _root_.com.twitter.finagle.thrift.Headers.Request.Key,
      _root_.com.twitter.finagle.thrift.Headers.Request.newValues
    ) {
      val serialized = encodeRequest("storeGridSearchCrossValidationEvent", inputArgs)
      this.service(serialized).flatMap { response =>
        Future.const(serdeCtx.deserialize(response))
      }.respond { response =>
        val responseClass = responseClassifier.applyOrElse(
          ctfs.ReqRep(inputArgs, response),
          ctfs.ResponseClassifier.Default)
        responseClass match {
          case ctfs.ResponseClass.Successful(_) =>
            __stats_storeGridSearchCrossValidationEvent.SuccessCounter.incr()
          case ctfs.ResponseClass.Failed(_) =>
            __stats_storeGridSearchCrossValidationEvent.FailuresCounter.incr()
            response match {
              case Throw(ex) =>
                setServiceName(ex)
                __stats_storeGridSearchCrossValidationEvent.FailuresScope.counter(Throwables.mkString(ex): _*).incr()
              case _ =>
            }
        }
      }
    }
  }
  private[this] object __stats_storeAnnotationEvent {
    val RequestsCounter = scopedStats.scope("storeAnnotationEvent").counter("requests")
    val SuccessCounter = scopedStats.scope("storeAnnotationEvent").counter("success")
    val FailuresCounter = scopedStats.scope("storeAnnotationEvent").counter("failures")
    val FailuresScope = scopedStats.scope("storeAnnotationEvent").scope("failures")
  }
  val storeAnnotationEventModelDBServiceReplyDeserializer: Array[Byte] => _root_.com.twitter.util.Try[modeldb.AnnotationEventResponse] = {
    response: Array[Byte] => {
      val result = decodeResponse(response, StoreAnnotationEvent.Result)
  
      result.firstException() match {
        case Some(exception) => _root_.com.twitter.util.Throw(setServiceName(exception))
        case _ => result.successField match {
          case Some(success) => _root_.com.twitter.util.Return(success)
          case _ => _root_.com.twitter.util.Throw(missingResult("storeAnnotationEvent"))
        }
      }
    }
  }
  
  def storeAnnotationEvent(ae: modeldb.AnnotationEvent): Future[modeldb.AnnotationEventResponse] = {
    __stats_storeAnnotationEvent.RequestsCounter.incr()
    val inputArgs = StoreAnnotationEvent.Args(ae)
  
    val serdeCtx = new _root_.com.twitter.finagle.thrift.ClientDeserializeCtx[modeldb.AnnotationEventResponse](inputArgs, storeAnnotationEventModelDBServiceReplyDeserializer)
    _root_.com.twitter.finagle.context.Contexts.local.let(
      _root_.com.twitter.finagle.thrift.ClientDeserializeCtx.Key,
      serdeCtx,
      _root_.com.twitter.finagle.thrift.Headers.Request.Key,
      _root_.com.twitter.finagle.thrift.Headers.Request.newValues
    ) {
      val serialized = encodeRequest("storeAnnotationEvent", inputArgs)
      this.service(serialized).flatMap { response =>
        Future.const(serdeCtx.deserialize(response))
      }.respond { response =>
        val responseClass = responseClassifier.applyOrElse(
          ctfs.ReqRep(inputArgs, response),
          ctfs.ResponseClassifier.Default)
        responseClass match {
          case ctfs.ResponseClass.Successful(_) =>
            __stats_storeAnnotationEvent.SuccessCounter.incr()
          case ctfs.ResponseClass.Failed(_) =>
            __stats_storeAnnotationEvent.FailuresCounter.incr()
            response match {
              case Throw(ex) =>
                setServiceName(ex)
                __stats_storeAnnotationEvent.FailuresScope.counter(Throwables.mkString(ex): _*).incr()
              case _ =>
            }
        }
      }
    }
  }
  private[this] object __stats_storeProjectEvent {
    val RequestsCounter = scopedStats.scope("storeProjectEvent").counter("requests")
    val SuccessCounter = scopedStats.scope("storeProjectEvent").counter("success")
    val FailuresCounter = scopedStats.scope("storeProjectEvent").counter("failures")
    val FailuresScope = scopedStats.scope("storeProjectEvent").scope("failures")
  }
  val storeProjectEventModelDBServiceReplyDeserializer: Array[Byte] => _root_.com.twitter.util.Try[modeldb.ProjectEventResponse] = {
    response: Array[Byte] => {
      val result = decodeResponse(response, StoreProjectEvent.Result)
  
      result.firstException() match {
        case Some(exception) => _root_.com.twitter.util.Throw(setServiceName(exception))
        case _ => result.successField match {
          case Some(success) => _root_.com.twitter.util.Return(success)
          case _ => _root_.com.twitter.util.Throw(missingResult("storeProjectEvent"))
        }
      }
    }
  }
  
  def storeProjectEvent(pr: modeldb.ProjectEvent): Future[modeldb.ProjectEventResponse] = {
    __stats_storeProjectEvent.RequestsCounter.incr()
    val inputArgs = StoreProjectEvent.Args(pr)
  
    val serdeCtx = new _root_.com.twitter.finagle.thrift.ClientDeserializeCtx[modeldb.ProjectEventResponse](inputArgs, storeProjectEventModelDBServiceReplyDeserializer)
    _root_.com.twitter.finagle.context.Contexts.local.let(
      _root_.com.twitter.finagle.thrift.ClientDeserializeCtx.Key,
      serdeCtx,
      _root_.com.twitter.finagle.thrift.Headers.Request.Key,
      _root_.com.twitter.finagle.thrift.Headers.Request.newValues
    ) {
      val serialized = encodeRequest("storeProjectEvent", inputArgs)
      this.service(serialized).flatMap { response =>
        Future.const(serdeCtx.deserialize(response))
      }.respond { response =>
        val responseClass = responseClassifier.applyOrElse(
          ctfs.ReqRep(inputArgs, response),
          ctfs.ResponseClassifier.Default)
        responseClass match {
          case ctfs.ResponseClass.Successful(_) =>
            __stats_storeProjectEvent.SuccessCounter.incr()
          case ctfs.ResponseClass.Failed(_) =>
            __stats_storeProjectEvent.FailuresCounter.incr()
            response match {
              case Throw(ex) =>
                setServiceName(ex)
                __stats_storeProjectEvent.FailuresScope.counter(Throwables.mkString(ex): _*).incr()
              case _ =>
            }
        }
      }
    }
  }
  private[this] object __stats_storeExperimentEvent {
    val RequestsCounter = scopedStats.scope("storeExperimentEvent").counter("requests")
    val SuccessCounter = scopedStats.scope("storeExperimentEvent").counter("success")
    val FailuresCounter = scopedStats.scope("storeExperimentEvent").counter("failures")
    val FailuresScope = scopedStats.scope("storeExperimentEvent").scope("failures")
  }
  val storeExperimentEventModelDBServiceReplyDeserializer: Array[Byte] => _root_.com.twitter.util.Try[modeldb.ExperimentEventResponse] = {
    response: Array[Byte] => {
      val result = decodeResponse(response, StoreExperimentEvent.Result)
  
      result.firstException() match {
        case Some(exception) => _root_.com.twitter.util.Throw(setServiceName(exception))
        case _ => result.successField match {
          case Some(success) => _root_.com.twitter.util.Return(success)
          case _ => _root_.com.twitter.util.Throw(missingResult("storeExperimentEvent"))
        }
      }
    }
  }
  
  def storeExperimentEvent(er: modeldb.ExperimentEvent): Future[modeldb.ExperimentEventResponse] = {
    __stats_storeExperimentEvent.RequestsCounter.incr()
    val inputArgs = StoreExperimentEvent.Args(er)
  
    val serdeCtx = new _root_.com.twitter.finagle.thrift.ClientDeserializeCtx[modeldb.ExperimentEventResponse](inputArgs, storeExperimentEventModelDBServiceReplyDeserializer)
    _root_.com.twitter.finagle.context.Contexts.local.let(
      _root_.com.twitter.finagle.thrift.ClientDeserializeCtx.Key,
      serdeCtx,
      _root_.com.twitter.finagle.thrift.Headers.Request.Key,
      _root_.com.twitter.finagle.thrift.Headers.Request.newValues
    ) {
      val serialized = encodeRequest("storeExperimentEvent", inputArgs)
      this.service(serialized).flatMap { response =>
        Future.const(serdeCtx.deserialize(response))
      }.respond { response =>
        val responseClass = responseClassifier.applyOrElse(
          ctfs.ReqRep(inputArgs, response),
          ctfs.ResponseClassifier.Default)
        responseClass match {
          case ctfs.ResponseClass.Successful(_) =>
            __stats_storeExperimentEvent.SuccessCounter.incr()
          case ctfs.ResponseClass.Failed(_) =>
            __stats_storeExperimentEvent.FailuresCounter.incr()
            response match {
              case Throw(ex) =>
                setServiceName(ex)
                __stats_storeExperimentEvent.FailuresScope.counter(Throwables.mkString(ex): _*).incr()
              case _ =>
            }
        }
      }
    }
  }
  private[this] object __stats_storeExperimentRunEvent {
    val RequestsCounter = scopedStats.scope("storeExperimentRunEvent").counter("requests")
    val SuccessCounter = scopedStats.scope("storeExperimentRunEvent").counter("success")
    val FailuresCounter = scopedStats.scope("storeExperimentRunEvent").counter("failures")
    val FailuresScope = scopedStats.scope("storeExperimentRunEvent").scope("failures")
  }
  val storeExperimentRunEventModelDBServiceReplyDeserializer: Array[Byte] => _root_.com.twitter.util.Try[modeldb.ExperimentRunEventResponse] = {
    response: Array[Byte] => {
      val result = decodeResponse(response, StoreExperimentRunEvent.Result)
  
      result.firstException() match {
        case Some(exception) => _root_.com.twitter.util.Throw(setServiceName(exception))
        case _ => result.successField match {
          case Some(success) => _root_.com.twitter.util.Return(success)
          case _ => _root_.com.twitter.util.Throw(missingResult("storeExperimentRunEvent"))
        }
      }
    }
  }
  
  def storeExperimentRunEvent(er: modeldb.ExperimentRunEvent): Future[modeldb.ExperimentRunEventResponse] = {
    __stats_storeExperimentRunEvent.RequestsCounter.incr()
    val inputArgs = StoreExperimentRunEvent.Args(er)
  
    val serdeCtx = new _root_.com.twitter.finagle.thrift.ClientDeserializeCtx[modeldb.ExperimentRunEventResponse](inputArgs, storeExperimentRunEventModelDBServiceReplyDeserializer)
    _root_.com.twitter.finagle.context.Contexts.local.let(
      _root_.com.twitter.finagle.thrift.ClientDeserializeCtx.Key,
      serdeCtx,
      _root_.com.twitter.finagle.thrift.Headers.Request.Key,
      _root_.com.twitter.finagle.thrift.Headers.Request.newValues
    ) {
      val serialized = encodeRequest("storeExperimentRunEvent", inputArgs)
      this.service(serialized).flatMap { response =>
        Future.const(serdeCtx.deserialize(response))
      }.respond { response =>
        val responseClass = responseClassifier.applyOrElse(
          ctfs.ReqRep(inputArgs, response),
          ctfs.ResponseClassifier.Default)
        responseClass match {
          case ctfs.ResponseClass.Successful(_) =>
            __stats_storeExperimentRunEvent.SuccessCounter.incr()
          case ctfs.ResponseClass.Failed(_) =>
            __stats_storeExperimentRunEvent.FailuresCounter.incr()
            response match {
              case Throw(ex) =>
                setServiceName(ex)
                __stats_storeExperimentRunEvent.FailuresScope.counter(Throwables.mkString(ex): _*).incr()
              case _ =>
            }
        }
      }
    }
  }
  private[this] object __stats_storeLinearModel {
    val RequestsCounter = scopedStats.scope("storeLinearModel").counter("requests")
    val SuccessCounter = scopedStats.scope("storeLinearModel").counter("success")
    val FailuresCounter = scopedStats.scope("storeLinearModel").counter("failures")
    val FailuresScope = scopedStats.scope("storeLinearModel").scope("failures")
  }
  val storeLinearModelModelDBServiceReplyDeserializer: Array[Byte] => _root_.com.twitter.util.Try[Boolean] = {
    response: Array[Byte] => {
      val result = decodeResponse(response, StoreLinearModel.Result)
  
      result.firstException() match {
        case Some(exception) => _root_.com.twitter.util.Throw(setServiceName(exception))
        case _ => result.successField match {
          case Some(success) => _root_.com.twitter.util.Return(success)
          case _ => _root_.com.twitter.util.Throw(missingResult("storeLinearModel"))
        }
      }
    }
  }
  
  def storeLinearModel(modelId: Int, model: modeldb.LinearModel): Future[Boolean] = {
    __stats_storeLinearModel.RequestsCounter.incr()
    val inputArgs = StoreLinearModel.Args(modelId, model)
  
    val serdeCtx = new _root_.com.twitter.finagle.thrift.ClientDeserializeCtx[Boolean](inputArgs, storeLinearModelModelDBServiceReplyDeserializer)
    _root_.com.twitter.finagle.context.Contexts.local.let(
      _root_.com.twitter.finagle.thrift.ClientDeserializeCtx.Key,
      serdeCtx,
      _root_.com.twitter.finagle.thrift.Headers.Request.Key,
      _root_.com.twitter.finagle.thrift.Headers.Request.newValues
    ) {
      val serialized = encodeRequest("storeLinearModel", inputArgs)
      this.service(serialized).flatMap { response =>
        Future.const(serdeCtx.deserialize(response))
      }.respond { response =>
        val responseClass = responseClassifier.applyOrElse(
          ctfs.ReqRep(inputArgs, response),
          ctfs.ResponseClassifier.Default)
        responseClass match {
          case ctfs.ResponseClass.Successful(_) =>
            __stats_storeLinearModel.SuccessCounter.incr()
          case ctfs.ResponseClass.Failed(_) =>
            __stats_storeLinearModel.FailuresCounter.incr()
            response match {
              case Throw(ex) =>
                setServiceName(ex)
                __stats_storeLinearModel.FailuresScope.counter(Throwables.mkString(ex): _*).incr()
              case _ =>
            }
        }
      }
    }
  }
  private[this] object __stats_getDataFrameAncestry {
    val RequestsCounter = scopedStats.scope("getDataFrameAncestry").counter("requests")
    val SuccessCounter = scopedStats.scope("getDataFrameAncestry").counter("success")
    val FailuresCounter = scopedStats.scope("getDataFrameAncestry").counter("failures")
    val FailuresScope = scopedStats.scope("getDataFrameAncestry").scope("failures")
  }
  val getDataFrameAncestryModelDBServiceReplyDeserializer: Array[Byte] => _root_.com.twitter.util.Try[modeldb.DataFrameAncestry] = {
    response: Array[Byte] => {
      val result = decodeResponse(response, GetDataFrameAncestry.Result)
  
      result.firstException() match {
        case Some(exception) => _root_.com.twitter.util.Throw(setServiceName(exception))
        case _ => result.successField match {
          case Some(success) => _root_.com.twitter.util.Return(success)
          case _ => _root_.com.twitter.util.Throw(missingResult("getDataFrameAncestry"))
        }
      }
    }
  }
  
  def getDataFrameAncestry(dataFrameId: Int): Future[modeldb.DataFrameAncestry] = {
    __stats_getDataFrameAncestry.RequestsCounter.incr()
    val inputArgs = GetDataFrameAncestry.Args(dataFrameId)
  
    val serdeCtx = new _root_.com.twitter.finagle.thrift.ClientDeserializeCtx[modeldb.DataFrameAncestry](inputArgs, getDataFrameAncestryModelDBServiceReplyDeserializer)
    _root_.com.twitter.finagle.context.Contexts.local.let(
      _root_.com.twitter.finagle.thrift.ClientDeserializeCtx.Key,
      serdeCtx,
      _root_.com.twitter.finagle.thrift.Headers.Request.Key,
      _root_.com.twitter.finagle.thrift.Headers.Request.newValues
    ) {
      val serialized = encodeRequest("getDataFrameAncestry", inputArgs)
      this.service(serialized).flatMap { response =>
        Future.const(serdeCtx.deserialize(response))
      }.respond { response =>
        val responseClass = responseClassifier.applyOrElse(
          ctfs.ReqRep(inputArgs, response),
          ctfs.ResponseClassifier.Default)
        responseClass match {
          case ctfs.ResponseClass.Successful(_) =>
            __stats_getDataFrameAncestry.SuccessCounter.incr()
          case ctfs.ResponseClass.Failed(_) =>
            __stats_getDataFrameAncestry.FailuresCounter.incr()
            response match {
              case Throw(ex) =>
                setServiceName(ex)
                __stats_getDataFrameAncestry.FailuresScope.counter(Throwables.mkString(ex): _*).incr()
              case _ =>
            }
        }
      }
    }
  }
  private[this] object __stats_getCommonAncestor {
    val RequestsCounter = scopedStats.scope("getCommonAncestor").counter("requests")
    val SuccessCounter = scopedStats.scope("getCommonAncestor").counter("success")
    val FailuresCounter = scopedStats.scope("getCommonAncestor").counter("failures")
    val FailuresScope = scopedStats.scope("getCommonAncestor").scope("failures")
  }
  val getCommonAncestorModelDBServiceReplyDeserializer: Array[Byte] => _root_.com.twitter.util.Try[modeldb.CommonAncestor] = {
    response: Array[Byte] => {
      val result = decodeResponse(response, GetCommonAncestor.Result)
  
      result.firstException() match {
        case Some(exception) => _root_.com.twitter.util.Throw(setServiceName(exception))
        case _ => result.successField match {
          case Some(success) => _root_.com.twitter.util.Return(success)
          case _ => _root_.com.twitter.util.Throw(missingResult("getCommonAncestor"))
        }
      }
    }
  }
  
  def getCommonAncestor(dfId1: Int, dfId2: Int): Future[modeldb.CommonAncestor] = {
    __stats_getCommonAncestor.RequestsCounter.incr()
    val inputArgs = GetCommonAncestor.Args(dfId1, dfId2)
  
    val serdeCtx = new _root_.com.twitter.finagle.thrift.ClientDeserializeCtx[modeldb.CommonAncestor](inputArgs, getCommonAncestorModelDBServiceReplyDeserializer)
    _root_.com.twitter.finagle.context.Contexts.local.let(
      _root_.com.twitter.finagle.thrift.ClientDeserializeCtx.Key,
      serdeCtx,
      _root_.com.twitter.finagle.thrift.Headers.Request.Key,
      _root_.com.twitter.finagle.thrift.Headers.Request.newValues
    ) {
      val serialized = encodeRequest("getCommonAncestor", inputArgs)
      this.service(serialized).flatMap { response =>
        Future.const(serdeCtx.deserialize(response))
      }.respond { response =>
        val responseClass = responseClassifier.applyOrElse(
          ctfs.ReqRep(inputArgs, response),
          ctfs.ResponseClassifier.Default)
        responseClass match {
          case ctfs.ResponseClass.Successful(_) =>
            __stats_getCommonAncestor.SuccessCounter.incr()
          case ctfs.ResponseClass.Failed(_) =>
            __stats_getCommonAncestor.FailuresCounter.incr()
            response match {
              case Throw(ex) =>
                setServiceName(ex)
                __stats_getCommonAncestor.FailuresScope.counter(Throwables.mkString(ex): _*).incr()
              case _ =>
            }
        }
      }
    }
  }
  private[this] object __stats_getCommonAncestorForModels {
    val RequestsCounter = scopedStats.scope("getCommonAncestorForModels").counter("requests")
    val SuccessCounter = scopedStats.scope("getCommonAncestorForModels").counter("success")
    val FailuresCounter = scopedStats.scope("getCommonAncestorForModels").counter("failures")
    val FailuresScope = scopedStats.scope("getCommonAncestorForModels").scope("failures")
  }
  val getCommonAncestorForModelsModelDBServiceReplyDeserializer: Array[Byte] => _root_.com.twitter.util.Try[modeldb.CommonAncestor] = {
    response: Array[Byte] => {
      val result = decodeResponse(response, GetCommonAncestorForModels.Result)
  
      result.firstException() match {
        case Some(exception) => _root_.com.twitter.util.Throw(setServiceName(exception))
        case _ => result.successField match {
          case Some(success) => _root_.com.twitter.util.Return(success)
          case _ => _root_.com.twitter.util.Throw(missingResult("getCommonAncestorForModels"))
        }
      }
    }
  }
  
  def getCommonAncestorForModels(modelId1: Int, modelId2: Int): Future[modeldb.CommonAncestor] = {
    __stats_getCommonAncestorForModels.RequestsCounter.incr()
    val inputArgs = GetCommonAncestorForModels.Args(modelId1, modelId2)
  
    val serdeCtx = new _root_.com.twitter.finagle.thrift.ClientDeserializeCtx[modeldb.CommonAncestor](inputArgs, getCommonAncestorForModelsModelDBServiceReplyDeserializer)
    _root_.com.twitter.finagle.context.Contexts.local.let(
      _root_.com.twitter.finagle.thrift.ClientDeserializeCtx.Key,
      serdeCtx,
      _root_.com.twitter.finagle.thrift.Headers.Request.Key,
      _root_.com.twitter.finagle.thrift.Headers.Request.newValues
    ) {
      val serialized = encodeRequest("getCommonAncestorForModels", inputArgs)
      this.service(serialized).flatMap { response =>
        Future.const(serdeCtx.deserialize(response))
      }.respond { response =>
        val responseClass = responseClassifier.applyOrElse(
          ctfs.ReqRep(inputArgs, response),
          ctfs.ResponseClassifier.Default)
        responseClass match {
          case ctfs.ResponseClass.Successful(_) =>
            __stats_getCommonAncestorForModels.SuccessCounter.incr()
          case ctfs.ResponseClass.Failed(_) =>
            __stats_getCommonAncestorForModels.FailuresCounter.incr()
            response match {
              case Throw(ex) =>
                setServiceName(ex)
                __stats_getCommonAncestorForModels.FailuresScope.counter(Throwables.mkString(ex): _*).incr()
              case _ =>
            }
        }
      }
    }
  }
  private[this] object __stats_getTrainingRowsCount {
    val RequestsCounter = scopedStats.scope("getTrainingRowsCount").counter("requests")
    val SuccessCounter = scopedStats.scope("getTrainingRowsCount").counter("success")
    val FailuresCounter = scopedStats.scope("getTrainingRowsCount").counter("failures")
    val FailuresScope = scopedStats.scope("getTrainingRowsCount").scope("failures")
  }
  val getTrainingRowsCountModelDBServiceReplyDeserializer: Array[Byte] => _root_.com.twitter.util.Try[Int] = {
    response: Array[Byte] => {
      val result = decodeResponse(response, GetTrainingRowsCount.Result)
  
      result.firstException() match {
        case Some(exception) => _root_.com.twitter.util.Throw(setServiceName(exception))
        case _ => result.successField match {
          case Some(success) => _root_.com.twitter.util.Return(success)
          case _ => _root_.com.twitter.util.Throw(missingResult("getTrainingRowsCount"))
        }
      }
    }
  }
  
  def getTrainingRowsCount(modelId: Int): Future[Int] = {
    __stats_getTrainingRowsCount.RequestsCounter.incr()
    val inputArgs = GetTrainingRowsCount.Args(modelId)
  
    val serdeCtx = new _root_.com.twitter.finagle.thrift.ClientDeserializeCtx[Int](inputArgs, getTrainingRowsCountModelDBServiceReplyDeserializer)
    _root_.com.twitter.finagle.context.Contexts.local.let(
      _root_.com.twitter.finagle.thrift.ClientDeserializeCtx.Key,
      serdeCtx,
      _root_.com.twitter.finagle.thrift.Headers.Request.Key,
      _root_.com.twitter.finagle.thrift.Headers.Request.newValues
    ) {
      val serialized = encodeRequest("getTrainingRowsCount", inputArgs)
      this.service(serialized).flatMap { response =>
        Future.const(serdeCtx.deserialize(response))
      }.respond { response =>
        val responseClass = responseClassifier.applyOrElse(
          ctfs.ReqRep(inputArgs, response),
          ctfs.ResponseClassifier.Default)
        responseClass match {
          case ctfs.ResponseClass.Successful(_) =>
            __stats_getTrainingRowsCount.SuccessCounter.incr()
          case ctfs.ResponseClass.Failed(_) =>
            __stats_getTrainingRowsCount.FailuresCounter.incr()
            response match {
              case Throw(ex) =>
                setServiceName(ex)
                __stats_getTrainingRowsCount.FailuresScope.counter(Throwables.mkString(ex): _*).incr()
              case _ =>
            }
        }
      }
    }
  }
  private[this] object __stats_getTrainingRowsCounts {
    val RequestsCounter = scopedStats.scope("getTrainingRowsCounts").counter("requests")
    val SuccessCounter = scopedStats.scope("getTrainingRowsCounts").counter("success")
    val FailuresCounter = scopedStats.scope("getTrainingRowsCounts").counter("failures")
    val FailuresScope = scopedStats.scope("getTrainingRowsCounts").scope("failures")
  }
  val getTrainingRowsCountsModelDBServiceReplyDeserializer: Array[Byte] => _root_.com.twitter.util.Try[Seq[Int]] = {
    response: Array[Byte] => {
      val result = decodeResponse(response, GetTrainingRowsCounts.Result)
  
      result.firstException() match {
        case Some(exception) => _root_.com.twitter.util.Throw(setServiceName(exception))
        case _ => result.successField match {
          case Some(success) => _root_.com.twitter.util.Return(success)
          case _ => _root_.com.twitter.util.Throw(missingResult("getTrainingRowsCounts"))
        }
      }
    }
  }
  
  def getTrainingRowsCounts(modelIds: Seq[Int] = Seq[Int]()): Future[Seq[Int]] = {
    __stats_getTrainingRowsCounts.RequestsCounter.incr()
    val inputArgs = GetTrainingRowsCounts.Args(modelIds)
  
    val serdeCtx = new _root_.com.twitter.finagle.thrift.ClientDeserializeCtx[Seq[Int]](inputArgs, getTrainingRowsCountsModelDBServiceReplyDeserializer)
    _root_.com.twitter.finagle.context.Contexts.local.let(
      _root_.com.twitter.finagle.thrift.ClientDeserializeCtx.Key,
      serdeCtx,
      _root_.com.twitter.finagle.thrift.Headers.Request.Key,
      _root_.com.twitter.finagle.thrift.Headers.Request.newValues
    ) {
      val serialized = encodeRequest("getTrainingRowsCounts", inputArgs)
      this.service(serialized).flatMap { response =>
        Future.const(serdeCtx.deserialize(response))
      }.respond { response =>
        val responseClass = responseClassifier.applyOrElse(
          ctfs.ReqRep(inputArgs, response),
          ctfs.ResponseClassifier.Default)
        responseClass match {
          case ctfs.ResponseClass.Successful(_) =>
            __stats_getTrainingRowsCounts.SuccessCounter.incr()
          case ctfs.ResponseClass.Failed(_) =>
            __stats_getTrainingRowsCounts.FailuresCounter.incr()
            response match {
              case Throw(ex) =>
                setServiceName(ex)
                __stats_getTrainingRowsCounts.FailuresScope.counter(Throwables.mkString(ex): _*).incr()
              case _ =>
            }
        }
      }
    }
  }
  private[this] object __stats_compareHyperparameters {
    val RequestsCounter = scopedStats.scope("compareHyperparameters").counter("requests")
    val SuccessCounter = scopedStats.scope("compareHyperparameters").counter("success")
    val FailuresCounter = scopedStats.scope("compareHyperparameters").counter("failures")
    val FailuresScope = scopedStats.scope("compareHyperparameters").scope("failures")
  }
  val compareHyperparametersModelDBServiceReplyDeserializer: Array[Byte] => _root_.com.twitter.util.Try[modeldb.CompareHyperParametersResponse] = {
    response: Array[Byte] => {
      val result = decodeResponse(response, CompareHyperparameters.Result)
  
      result.firstException() match {
        case Some(exception) => _root_.com.twitter.util.Throw(setServiceName(exception))
        case _ => result.successField match {
          case Some(success) => _root_.com.twitter.util.Return(success)
          case _ => _root_.com.twitter.util.Throw(missingResult("compareHyperparameters"))
        }
      }
    }
  }
  
  def compareHyperparameters(modelId1: Int, modelId2: Int): Future[modeldb.CompareHyperParametersResponse] = {
    __stats_compareHyperparameters.RequestsCounter.incr()
    val inputArgs = CompareHyperparameters.Args(modelId1, modelId2)
  
    val serdeCtx = new _root_.com.twitter.finagle.thrift.ClientDeserializeCtx[modeldb.CompareHyperParametersResponse](inputArgs, compareHyperparametersModelDBServiceReplyDeserializer)
    _root_.com.twitter.finagle.context.Contexts.local.let(
      _root_.com.twitter.finagle.thrift.ClientDeserializeCtx.Key,
      serdeCtx,
      _root_.com.twitter.finagle.thrift.Headers.Request.Key,
      _root_.com.twitter.finagle.thrift.Headers.Request.newValues
    ) {
      val serialized = encodeRequest("compareHyperparameters", inputArgs)
      this.service(serialized).flatMap { response =>
        Future.const(serdeCtx.deserialize(response))
      }.respond { response =>
        val responseClass = responseClassifier.applyOrElse(
          ctfs.ReqRep(inputArgs, response),
          ctfs.ResponseClassifier.Default)
        responseClass match {
          case ctfs.ResponseClass.Successful(_) =>
            __stats_compareHyperparameters.SuccessCounter.incr()
          case ctfs.ResponseClass.Failed(_) =>
            __stats_compareHyperparameters.FailuresCounter.incr()
            response match {
              case Throw(ex) =>
                setServiceName(ex)
                __stats_compareHyperparameters.FailuresScope.counter(Throwables.mkString(ex): _*).incr()
              case _ =>
            }
        }
      }
    }
  }
  private[this] object __stats_compareFeatures {
    val RequestsCounter = scopedStats.scope("compareFeatures").counter("requests")
    val SuccessCounter = scopedStats.scope("compareFeatures").counter("success")
    val FailuresCounter = scopedStats.scope("compareFeatures").counter("failures")
    val FailuresScope = scopedStats.scope("compareFeatures").scope("failures")
  }
  val compareFeaturesModelDBServiceReplyDeserializer: Array[Byte] => _root_.com.twitter.util.Try[modeldb.CompareFeaturesResponse] = {
    response: Array[Byte] => {
      val result = decodeResponse(response, CompareFeatures.Result)
  
      result.firstException() match {
        case Some(exception) => _root_.com.twitter.util.Throw(setServiceName(exception))
        case _ => result.successField match {
          case Some(success) => _root_.com.twitter.util.Return(success)
          case _ => _root_.com.twitter.util.Throw(missingResult("compareFeatures"))
        }
      }
    }
  }
  
  def compareFeatures(modelId1: Int, modelId2: Int): Future[modeldb.CompareFeaturesResponse] = {
    __stats_compareFeatures.RequestsCounter.incr()
    val inputArgs = CompareFeatures.Args(modelId1, modelId2)
  
    val serdeCtx = new _root_.com.twitter.finagle.thrift.ClientDeserializeCtx[modeldb.CompareFeaturesResponse](inputArgs, compareFeaturesModelDBServiceReplyDeserializer)
    _root_.com.twitter.finagle.context.Contexts.local.let(
      _root_.com.twitter.finagle.thrift.ClientDeserializeCtx.Key,
      serdeCtx,
      _root_.com.twitter.finagle.thrift.Headers.Request.Key,
      _root_.com.twitter.finagle.thrift.Headers.Request.newValues
    ) {
      val serialized = encodeRequest("compareFeatures", inputArgs)
      this.service(serialized).flatMap { response =>
        Future.const(serdeCtx.deserialize(response))
      }.respond { response =>
        val responseClass = responseClassifier.applyOrElse(
          ctfs.ReqRep(inputArgs, response),
          ctfs.ResponseClassifier.Default)
        responseClass match {
          case ctfs.ResponseClass.Successful(_) =>
            __stats_compareFeatures.SuccessCounter.incr()
          case ctfs.ResponseClass.Failed(_) =>
            __stats_compareFeatures.FailuresCounter.incr()
            response match {
              case Throw(ex) =>
                setServiceName(ex)
                __stats_compareFeatures.FailuresScope.counter(Throwables.mkString(ex): _*).incr()
              case _ =>
            }
        }
      }
    }
  }
  private[this] object __stats_groupByProblemType {
    val RequestsCounter = scopedStats.scope("groupByProblemType").counter("requests")
    val SuccessCounter = scopedStats.scope("groupByProblemType").counter("success")
    val FailuresCounter = scopedStats.scope("groupByProblemType").counter("failures")
    val FailuresScope = scopedStats.scope("groupByProblemType").scope("failures")
  }
  val groupByProblemTypeModelDBServiceReplyDeserializer: Array[Byte] => _root_.com.twitter.util.Try[Map[modeldb.ProblemType, Seq[Int]]] = {
    response: Array[Byte] => {
      val result = decodeResponse(response, GroupByProblemType.Result)
  
      result.firstException() match {
        case Some(exception) => _root_.com.twitter.util.Throw(setServiceName(exception))
        case _ => result.successField match {
          case Some(success) => _root_.com.twitter.util.Return(success)
          case _ => _root_.com.twitter.util.Throw(missingResult("groupByProblemType"))
        }
      }
    }
  }
  
  def groupByProblemType(modelIds: Seq[Int] = Seq[Int]()): Future[Map[modeldb.ProblemType, Seq[Int]]] = {
    __stats_groupByProblemType.RequestsCounter.incr()
    val inputArgs = GroupByProblemType.Args(modelIds)
  
    val serdeCtx = new _root_.com.twitter.finagle.thrift.ClientDeserializeCtx[Map[modeldb.ProblemType, Seq[Int]]](inputArgs, groupByProblemTypeModelDBServiceReplyDeserializer)
    _root_.com.twitter.finagle.context.Contexts.local.let(
      _root_.com.twitter.finagle.thrift.ClientDeserializeCtx.Key,
      serdeCtx,
      _root_.com.twitter.finagle.thrift.Headers.Request.Key,
      _root_.com.twitter.finagle.thrift.Headers.Request.newValues
    ) {
      val serialized = encodeRequest("groupByProblemType", inputArgs)
      this.service(serialized).flatMap { response =>
        Future.const(serdeCtx.deserialize(response))
      }.respond { response =>
        val responseClass = responseClassifier.applyOrElse(
          ctfs.ReqRep(inputArgs, response),
          ctfs.ResponseClassifier.Default)
        responseClass match {
          case ctfs.ResponseClass.Successful(_) =>
            __stats_groupByProblemType.SuccessCounter.incr()
          case ctfs.ResponseClass.Failed(_) =>
            __stats_groupByProblemType.FailuresCounter.incr()
            response match {
              case Throw(ex) =>
                setServiceName(ex)
                __stats_groupByProblemType.FailuresScope.counter(Throwables.mkString(ex): _*).incr()
              case _ =>
            }
        }
      }
    }
  }
  private[this] object __stats_similarModels {
    val RequestsCounter = scopedStats.scope("similarModels").counter("requests")
    val SuccessCounter = scopedStats.scope("similarModels").counter("success")
    val FailuresCounter = scopedStats.scope("similarModels").counter("failures")
    val FailuresScope = scopedStats.scope("similarModels").scope("failures")
  }
  val similarModelsModelDBServiceReplyDeserializer: Array[Byte] => _root_.com.twitter.util.Try[Seq[Int]] = {
    response: Array[Byte] => {
      val result = decodeResponse(response, SimilarModels.Result)
  
      result.firstException() match {
        case Some(exception) => _root_.com.twitter.util.Throw(setServiceName(exception))
        case _ => result.successField match {
          case Some(success) => _root_.com.twitter.util.Return(success)
          case _ => _root_.com.twitter.util.Throw(missingResult("similarModels"))
        }
      }
    }
  }
  
  def similarModels(modelId: Int, compMetrics: Seq[modeldb.ModelCompMetric] = Seq[modeldb.ModelCompMetric](), numModels: Int): Future[Seq[Int]] = {
    __stats_similarModels.RequestsCounter.incr()
    val inputArgs = SimilarModels.Args(modelId, compMetrics, numModels)
  
    val serdeCtx = new _root_.com.twitter.finagle.thrift.ClientDeserializeCtx[Seq[Int]](inputArgs, similarModelsModelDBServiceReplyDeserializer)
    _root_.com.twitter.finagle.context.Contexts.local.let(
      _root_.com.twitter.finagle.thrift.ClientDeserializeCtx.Key,
      serdeCtx,
      _root_.com.twitter.finagle.thrift.Headers.Request.Key,
      _root_.com.twitter.finagle.thrift.Headers.Request.newValues
    ) {
      val serialized = encodeRequest("similarModels", inputArgs)
      this.service(serialized).flatMap { response =>
        Future.const(serdeCtx.deserialize(response))
      }.respond { response =>
        val responseClass = responseClassifier.applyOrElse(
          ctfs.ReqRep(inputArgs, response),
          ctfs.ResponseClassifier.Default)
        responseClass match {
          case ctfs.ResponseClass.Successful(_) =>
            __stats_similarModels.SuccessCounter.incr()
          case ctfs.ResponseClass.Failed(_) =>
            __stats_similarModels.FailuresCounter.incr()
            response match {
              case Throw(ex) =>
                setServiceName(ex)
                __stats_similarModels.FailuresScope.counter(Throwables.mkString(ex): _*).incr()
              case _ =>
            }
        }
      }
    }
  }
  private[this] object __stats_linearModelFeatureImportances {
    val RequestsCounter = scopedStats.scope("linearModelFeatureImportances").counter("requests")
    val SuccessCounter = scopedStats.scope("linearModelFeatureImportances").counter("success")
    val FailuresCounter = scopedStats.scope("linearModelFeatureImportances").counter("failures")
    val FailuresScope = scopedStats.scope("linearModelFeatureImportances").scope("failures")
  }
  val linearModelFeatureImportancesModelDBServiceReplyDeserializer: Array[Byte] => _root_.com.twitter.util.Try[Seq[String]] = {
    response: Array[Byte] => {
      val result = decodeResponse(response, LinearModelFeatureImportances.Result)
  
      result.firstException() match {
        case Some(exception) => _root_.com.twitter.util.Throw(setServiceName(exception))
        case _ => result.successField match {
          case Some(success) => _root_.com.twitter.util.Return(success)
          case _ => _root_.com.twitter.util.Throw(missingResult("linearModelFeatureImportances"))
        }
      }
    }
  }
  
  def linearModelFeatureImportances(modelId: Int): Future[Seq[String]] = {
    __stats_linearModelFeatureImportances.RequestsCounter.incr()
    val inputArgs = LinearModelFeatureImportances.Args(modelId)
  
    val serdeCtx = new _root_.com.twitter.finagle.thrift.ClientDeserializeCtx[Seq[String]](inputArgs, linearModelFeatureImportancesModelDBServiceReplyDeserializer)
    _root_.com.twitter.finagle.context.Contexts.local.let(
      _root_.com.twitter.finagle.thrift.ClientDeserializeCtx.Key,
      serdeCtx,
      _root_.com.twitter.finagle.thrift.Headers.Request.Key,
      _root_.com.twitter.finagle.thrift.Headers.Request.newValues
    ) {
      val serialized = encodeRequest("linearModelFeatureImportances", inputArgs)
      this.service(serialized).flatMap { response =>
        Future.const(serdeCtx.deserialize(response))
      }.respond { response =>
        val responseClass = responseClassifier.applyOrElse(
          ctfs.ReqRep(inputArgs, response),
          ctfs.ResponseClassifier.Default)
        responseClass match {
          case ctfs.ResponseClass.Successful(_) =>
            __stats_linearModelFeatureImportances.SuccessCounter.incr()
          case ctfs.ResponseClass.Failed(_) =>
            __stats_linearModelFeatureImportances.FailuresCounter.incr()
            response match {
              case Throw(ex) =>
                setServiceName(ex)
                __stats_linearModelFeatureImportances.FailuresScope.counter(Throwables.mkString(ex): _*).incr()
              case _ =>
            }
        }
      }
    }
  }
  private[this] object __stats_compareLinearModelFeatureImportances {
    val RequestsCounter = scopedStats.scope("compareLinearModelFeatureImportances").counter("requests")
    val SuccessCounter = scopedStats.scope("compareLinearModelFeatureImportances").counter("success")
    val FailuresCounter = scopedStats.scope("compareLinearModelFeatureImportances").counter("failures")
    val FailuresScope = scopedStats.scope("compareLinearModelFeatureImportances").scope("failures")
  }
  val compareLinearModelFeatureImportancesModelDBServiceReplyDeserializer: Array[Byte] => _root_.com.twitter.util.Try[Seq[modeldb.FeatureImportanceComparison]] = {
    response: Array[Byte] => {
      val result = decodeResponse(response, CompareLinearModelFeatureImportances.Result)
  
      result.firstException() match {
        case Some(exception) => _root_.com.twitter.util.Throw(setServiceName(exception))
        case _ => result.successField match {
          case Some(success) => _root_.com.twitter.util.Return(success)
          case _ => _root_.com.twitter.util.Throw(missingResult("compareLinearModelFeatureImportances"))
        }
      }
    }
  }
  
  def compareLinearModelFeatureImportances(model1Id: Int, model2Id: Int): Future[Seq[modeldb.FeatureImportanceComparison]] = {
    __stats_compareLinearModelFeatureImportances.RequestsCounter.incr()
    val inputArgs = CompareLinearModelFeatureImportances.Args(model1Id, model2Id)
  
    val serdeCtx = new _root_.com.twitter.finagle.thrift.ClientDeserializeCtx[Seq[modeldb.FeatureImportanceComparison]](inputArgs, compareLinearModelFeatureImportancesModelDBServiceReplyDeserializer)
    _root_.com.twitter.finagle.context.Contexts.local.let(
      _root_.com.twitter.finagle.thrift.ClientDeserializeCtx.Key,
      serdeCtx,
      _root_.com.twitter.finagle.thrift.Headers.Request.Key,
      _root_.com.twitter.finagle.thrift.Headers.Request.newValues
    ) {
      val serialized = encodeRequest("compareLinearModelFeatureImportances", inputArgs)
      this.service(serialized).flatMap { response =>
        Future.const(serdeCtx.deserialize(response))
      }.respond { response =>
        val responseClass = responseClassifier.applyOrElse(
          ctfs.ReqRep(inputArgs, response),
          ctfs.ResponseClassifier.Default)
        responseClass match {
          case ctfs.ResponseClass.Successful(_) =>
            __stats_compareLinearModelFeatureImportances.SuccessCounter.incr()
          case ctfs.ResponseClass.Failed(_) =>
            __stats_compareLinearModelFeatureImportances.FailuresCounter.incr()
            response match {
              case Throw(ex) =>
                setServiceName(ex)
                __stats_compareLinearModelFeatureImportances.FailuresScope.counter(Throwables.mkString(ex): _*).incr()
              case _ =>
            }
        }
      }
    }
  }
  private[this] object __stats_iterationsUntilConvergence {
    val RequestsCounter = scopedStats.scope("iterationsUntilConvergence").counter("requests")
    val SuccessCounter = scopedStats.scope("iterationsUntilConvergence").counter("success")
    val FailuresCounter = scopedStats.scope("iterationsUntilConvergence").counter("failures")
    val FailuresScope = scopedStats.scope("iterationsUntilConvergence").scope("failures")
  }
  val iterationsUntilConvergenceModelDBServiceReplyDeserializer: Array[Byte] => _root_.com.twitter.util.Try[Seq[Int]] = {
    response: Array[Byte] => {
      val result = decodeResponse(response, IterationsUntilConvergence.Result)
  
      result.firstException() match {
        case Some(exception) => _root_.com.twitter.util.Throw(setServiceName(exception))
        case _ => result.successField match {
          case Some(success) => _root_.com.twitter.util.Return(success)
          case _ => _root_.com.twitter.util.Throw(missingResult("iterationsUntilConvergence"))
        }
      }
    }
  }
  
  def iterationsUntilConvergence(modelIds: Seq[Int] = Seq[Int](), tolerance: Double): Future[Seq[Int]] = {
    __stats_iterationsUntilConvergence.RequestsCounter.incr()
    val inputArgs = IterationsUntilConvergence.Args(modelIds, tolerance)
  
    val serdeCtx = new _root_.com.twitter.finagle.thrift.ClientDeserializeCtx[Seq[Int]](inputArgs, iterationsUntilConvergenceModelDBServiceReplyDeserializer)
    _root_.com.twitter.finagle.context.Contexts.local.let(
      _root_.com.twitter.finagle.thrift.ClientDeserializeCtx.Key,
      serdeCtx,
      _root_.com.twitter.finagle.thrift.Headers.Request.Key,
      _root_.com.twitter.finagle.thrift.Headers.Request.newValues
    ) {
      val serialized = encodeRequest("iterationsUntilConvergence", inputArgs)
      this.service(serialized).flatMap { response =>
        Future.const(serdeCtx.deserialize(response))
      }.respond { response =>
        val responseClass = responseClassifier.applyOrElse(
          ctfs.ReqRep(inputArgs, response),
          ctfs.ResponseClassifier.Default)
        responseClass match {
          case ctfs.ResponseClass.Successful(_) =>
            __stats_iterationsUntilConvergence.SuccessCounter.incr()
          case ctfs.ResponseClass.Failed(_) =>
            __stats_iterationsUntilConvergence.FailuresCounter.incr()
            response match {
              case Throw(ex) =>
                setServiceName(ex)
                __stats_iterationsUntilConvergence.FailuresScope.counter(Throwables.mkString(ex): _*).incr()
              case _ =>
            }
        }
      }
    }
  }
  private[this] object __stats_rankModels {
    val RequestsCounter = scopedStats.scope("rankModels").counter("requests")
    val SuccessCounter = scopedStats.scope("rankModels").counter("success")
    val FailuresCounter = scopedStats.scope("rankModels").counter("failures")
    val FailuresScope = scopedStats.scope("rankModels").scope("failures")
  }
  val rankModelsModelDBServiceReplyDeserializer: Array[Byte] => _root_.com.twitter.util.Try[Seq[Int]] = {
    response: Array[Byte] => {
      val result = decodeResponse(response, RankModels.Result)
  
      result.firstException() match {
        case Some(exception) => _root_.com.twitter.util.Throw(setServiceName(exception))
        case _ => result.successField match {
          case Some(success) => _root_.com.twitter.util.Return(success)
          case _ => _root_.com.twitter.util.Throw(missingResult("rankModels"))
        }
      }
    }
  }
  
  def rankModels(modelIds: Seq[Int] = Seq[Int](), metric: modeldb.ModelRankMetric): Future[Seq[Int]] = {
    __stats_rankModels.RequestsCounter.incr()
    val inputArgs = RankModels.Args(modelIds, metric)
  
    val serdeCtx = new _root_.com.twitter.finagle.thrift.ClientDeserializeCtx[Seq[Int]](inputArgs, rankModelsModelDBServiceReplyDeserializer)
    _root_.com.twitter.finagle.context.Contexts.local.let(
      _root_.com.twitter.finagle.thrift.ClientDeserializeCtx.Key,
      serdeCtx,
      _root_.com.twitter.finagle.thrift.Headers.Request.Key,
      _root_.com.twitter.finagle.thrift.Headers.Request.newValues
    ) {
      val serialized = encodeRequest("rankModels", inputArgs)
      this.service(serialized).flatMap { response =>
        Future.const(serdeCtx.deserialize(response))
      }.respond { response =>
        val responseClass = responseClassifier.applyOrElse(
          ctfs.ReqRep(inputArgs, response),
          ctfs.ResponseClassifier.Default)
        responseClass match {
          case ctfs.ResponseClass.Successful(_) =>
            __stats_rankModels.SuccessCounter.incr()
          case ctfs.ResponseClass.Failed(_) =>
            __stats_rankModels.FailuresCounter.incr()
            response match {
              case Throw(ex) =>
                setServiceName(ex)
                __stats_rankModels.FailuresScope.counter(Throwables.mkString(ex): _*).incr()
              case _ =>
            }
        }
      }
    }
  }
  private[this] object __stats_confidenceIntervals {
    val RequestsCounter = scopedStats.scope("confidenceIntervals").counter("requests")
    val SuccessCounter = scopedStats.scope("confidenceIntervals").counter("success")
    val FailuresCounter = scopedStats.scope("confidenceIntervals").counter("failures")
    val FailuresScope = scopedStats.scope("confidenceIntervals").scope("failures")
  }
  val confidenceIntervalsModelDBServiceReplyDeserializer: Array[Byte] => _root_.com.twitter.util.Try[Seq[modeldb.ConfidenceInterval]] = {
    response: Array[Byte] => {
      val result = decodeResponse(response, ConfidenceIntervals.Result)
  
      result.firstException() match {
        case Some(exception) => _root_.com.twitter.util.Throw(setServiceName(exception))
        case _ => result.successField match {
          case Some(success) => _root_.com.twitter.util.Return(success)
          case _ => _root_.com.twitter.util.Throw(missingResult("confidenceIntervals"))
        }
      }
    }
  }
  
  def confidenceIntervals(modelId: Int, sigLevel: Double): Future[Seq[modeldb.ConfidenceInterval]] = {
    __stats_confidenceIntervals.RequestsCounter.incr()
    val inputArgs = ConfidenceIntervals.Args(modelId, sigLevel)
  
    val serdeCtx = new _root_.com.twitter.finagle.thrift.ClientDeserializeCtx[Seq[modeldb.ConfidenceInterval]](inputArgs, confidenceIntervalsModelDBServiceReplyDeserializer)
    _root_.com.twitter.finagle.context.Contexts.local.let(
      _root_.com.twitter.finagle.thrift.ClientDeserializeCtx.Key,
      serdeCtx,
      _root_.com.twitter.finagle.thrift.Headers.Request.Key,
      _root_.com.twitter.finagle.thrift.Headers.Request.newValues
    ) {
      val serialized = encodeRequest("confidenceIntervals", inputArgs)
      this.service(serialized).flatMap { response =>
        Future.const(serdeCtx.deserialize(response))
      }.respond { response =>
        val responseClass = responseClassifier.applyOrElse(
          ctfs.ReqRep(inputArgs, response),
          ctfs.ResponseClassifier.Default)
        responseClass match {
          case ctfs.ResponseClass.Successful(_) =>
            __stats_confidenceIntervals.SuccessCounter.incr()
          case ctfs.ResponseClass.Failed(_) =>
            __stats_confidenceIntervals.FailuresCounter.incr()
            response match {
              case Throw(ex) =>
                setServiceName(ex)
                __stats_confidenceIntervals.FailuresScope.counter(Throwables.mkString(ex): _*).incr()
              case _ =>
            }
        }
      }
    }
  }
  private[this] object __stats_modelsWithFeatures {
    val RequestsCounter = scopedStats.scope("modelsWithFeatures").counter("requests")
    val SuccessCounter = scopedStats.scope("modelsWithFeatures").counter("success")
    val FailuresCounter = scopedStats.scope("modelsWithFeatures").counter("failures")
    val FailuresScope = scopedStats.scope("modelsWithFeatures").scope("failures")
  }
  val modelsWithFeaturesModelDBServiceReplyDeserializer: Array[Byte] => _root_.com.twitter.util.Try[Seq[Int]] = {
    response: Array[Byte] => {
      val result = decodeResponse(response, ModelsWithFeatures.Result)
  
      result.firstException() match {
        case Some(exception) => _root_.com.twitter.util.Throw(setServiceName(exception))
        case _ => result.successField match {
          case Some(success) => _root_.com.twitter.util.Return(success)
          case _ => _root_.com.twitter.util.Throw(missingResult("modelsWithFeatures"))
        }
      }
    }
  }
  
  def modelsWithFeatures(featureNames: Seq[String] = Seq[String]()): Future[Seq[Int]] = {
    __stats_modelsWithFeatures.RequestsCounter.incr()
    val inputArgs = ModelsWithFeatures.Args(featureNames)
  
    val serdeCtx = new _root_.com.twitter.finagle.thrift.ClientDeserializeCtx[Seq[Int]](inputArgs, modelsWithFeaturesModelDBServiceReplyDeserializer)
    _root_.com.twitter.finagle.context.Contexts.local.let(
      _root_.com.twitter.finagle.thrift.ClientDeserializeCtx.Key,
      serdeCtx,
      _root_.com.twitter.finagle.thrift.Headers.Request.Key,
      _root_.com.twitter.finagle.thrift.Headers.Request.newValues
    ) {
      val serialized = encodeRequest("modelsWithFeatures", inputArgs)
      this.service(serialized).flatMap { response =>
        Future.const(serdeCtx.deserialize(response))
      }.respond { response =>
        val responseClass = responseClassifier.applyOrElse(
          ctfs.ReqRep(inputArgs, response),
          ctfs.ResponseClassifier.Default)
        responseClass match {
          case ctfs.ResponseClass.Successful(_) =>
            __stats_modelsWithFeatures.SuccessCounter.incr()
          case ctfs.ResponseClass.Failed(_) =>
            __stats_modelsWithFeatures.FailuresCounter.incr()
            response match {
              case Throw(ex) =>
                setServiceName(ex)
                __stats_modelsWithFeatures.FailuresScope.counter(Throwables.mkString(ex): _*).incr()
              case _ =>
            }
        }
      }
    }
  }
  private[this] object __stats_modelsDerivedFromDataFrame {
    val RequestsCounter = scopedStats.scope("modelsDerivedFromDataFrame").counter("requests")
    val SuccessCounter = scopedStats.scope("modelsDerivedFromDataFrame").counter("success")
    val FailuresCounter = scopedStats.scope("modelsDerivedFromDataFrame").counter("failures")
    val FailuresScope = scopedStats.scope("modelsDerivedFromDataFrame").scope("failures")
  }
  val modelsDerivedFromDataFrameModelDBServiceReplyDeserializer: Array[Byte] => _root_.com.twitter.util.Try[Seq[Int]] = {
    response: Array[Byte] => {
      val result = decodeResponse(response, ModelsDerivedFromDataFrame.Result)
  
      result.firstException() match {
        case Some(exception) => _root_.com.twitter.util.Throw(setServiceName(exception))
        case _ => result.successField match {
          case Some(success) => _root_.com.twitter.util.Return(success)
          case _ => _root_.com.twitter.util.Throw(missingResult("modelsDerivedFromDataFrame"))
        }
      }
    }
  }
  
  def modelsDerivedFromDataFrame(dfId: Int): Future[Seq[Int]] = {
    __stats_modelsDerivedFromDataFrame.RequestsCounter.incr()
    val inputArgs = ModelsDerivedFromDataFrame.Args(dfId)
  
    val serdeCtx = new _root_.com.twitter.finagle.thrift.ClientDeserializeCtx[Seq[Int]](inputArgs, modelsDerivedFromDataFrameModelDBServiceReplyDeserializer)
    _root_.com.twitter.finagle.context.Contexts.local.let(
      _root_.com.twitter.finagle.thrift.ClientDeserializeCtx.Key,
      serdeCtx,
      _root_.com.twitter.finagle.thrift.Headers.Request.Key,
      _root_.com.twitter.finagle.thrift.Headers.Request.newValues
    ) {
      val serialized = encodeRequest("modelsDerivedFromDataFrame", inputArgs)
      this.service(serialized).flatMap { response =>
        Future.const(serdeCtx.deserialize(response))
      }.respond { response =>
        val responseClass = responseClassifier.applyOrElse(
          ctfs.ReqRep(inputArgs, response),
          ctfs.ResponseClassifier.Default)
        responseClass match {
          case ctfs.ResponseClass.Successful(_) =>
            __stats_modelsDerivedFromDataFrame.SuccessCounter.incr()
          case ctfs.ResponseClass.Failed(_) =>
            __stats_modelsDerivedFromDataFrame.FailuresCounter.incr()
            response match {
              case Throw(ex) =>
                setServiceName(ex)
                __stats_modelsDerivedFromDataFrame.FailuresScope.counter(Throwables.mkString(ex): _*).incr()
              case _ =>
            }
        }
      }
    }
  }
  private[this] object __stats_getProjectIds {
    val RequestsCounter = scopedStats.scope("getProjectIds").counter("requests")
    val SuccessCounter = scopedStats.scope("getProjectIds").counter("success")
    val FailuresCounter = scopedStats.scope("getProjectIds").counter("failures")
    val FailuresScope = scopedStats.scope("getProjectIds").scope("failures")
  }
  val getProjectIdsModelDBServiceReplyDeserializer: Array[Byte] => _root_.com.twitter.util.Try[Seq[Int]] = {
    response: Array[Byte] => {
      val result = decodeResponse(response, GetProjectIds.Result)
  
      result.firstException() match {
        case Some(exception) => _root_.com.twitter.util.Throw(setServiceName(exception))
        case _ => result.successField match {
          case Some(success) => _root_.com.twitter.util.Return(success)
          case _ => _root_.com.twitter.util.Throw(missingResult("getProjectIds"))
        }
      }
    }
  }
  
  def getProjectIds(keyValuePairs: Map[String, String] = Map[String, String]()): Future[Seq[Int]] = {
    __stats_getProjectIds.RequestsCounter.incr()
    val inputArgs = GetProjectIds.Args(keyValuePairs)
  
    val serdeCtx = new _root_.com.twitter.finagle.thrift.ClientDeserializeCtx[Seq[Int]](inputArgs, getProjectIdsModelDBServiceReplyDeserializer)
    _root_.com.twitter.finagle.context.Contexts.local.let(
      _root_.com.twitter.finagle.thrift.ClientDeserializeCtx.Key,
      serdeCtx,
      _root_.com.twitter.finagle.thrift.Headers.Request.Key,
      _root_.com.twitter.finagle.thrift.Headers.Request.newValues
    ) {
      val serialized = encodeRequest("getProjectIds", inputArgs)
      this.service(serialized).flatMap { response =>
        Future.const(serdeCtx.deserialize(response))
      }.respond { response =>
        val responseClass = responseClassifier.applyOrElse(
          ctfs.ReqRep(inputArgs, response),
          ctfs.ResponseClassifier.Default)
        responseClass match {
          case ctfs.ResponseClass.Successful(_) =>
            __stats_getProjectIds.SuccessCounter.incr()
          case ctfs.ResponseClass.Failed(_) =>
            __stats_getProjectIds.FailuresCounter.incr()
            response match {
              case Throw(ex) =>
                setServiceName(ex)
                __stats_getProjectIds.FailuresScope.counter(Throwables.mkString(ex): _*).incr()
              case _ =>
            }
        }
      }
    }
  }
  private[this] object __stats_getModelIds {
    val RequestsCounter = scopedStats.scope("getModelIds").counter("requests")
    val SuccessCounter = scopedStats.scope("getModelIds").counter("success")
    val FailuresCounter = scopedStats.scope("getModelIds").counter("failures")
    val FailuresScope = scopedStats.scope("getModelIds").scope("failures")
  }
  val getModelIdsModelDBServiceReplyDeserializer: Array[Byte] => _root_.com.twitter.util.Try[Seq[Int]] = {
    response: Array[Byte] => {
      val result = decodeResponse(response, GetModelIds.Result)
  
      result.firstException() match {
        case Some(exception) => _root_.com.twitter.util.Throw(setServiceName(exception))
        case _ => result.successField match {
          case Some(success) => _root_.com.twitter.util.Return(success)
          case _ => _root_.com.twitter.util.Throw(missingResult("getModelIds"))
        }
      }
    }
  }
  
  def getModelIds(keyValuePairs: Map[String, String] = Map[String, String]()): Future[Seq[Int]] = {
    __stats_getModelIds.RequestsCounter.incr()
    val inputArgs = GetModelIds.Args(keyValuePairs)
  
    val serdeCtx = new _root_.com.twitter.finagle.thrift.ClientDeserializeCtx[Seq[Int]](inputArgs, getModelIdsModelDBServiceReplyDeserializer)
    _root_.com.twitter.finagle.context.Contexts.local.let(
      _root_.com.twitter.finagle.thrift.ClientDeserializeCtx.Key,
      serdeCtx,
      _root_.com.twitter.finagle.thrift.Headers.Request.Key,
      _root_.com.twitter.finagle.thrift.Headers.Request.newValues
    ) {
      val serialized = encodeRequest("getModelIds", inputArgs)
      this.service(serialized).flatMap { response =>
        Future.const(serdeCtx.deserialize(response))
      }.respond { response =>
        val responseClass = responseClassifier.applyOrElse(
          ctfs.ReqRep(inputArgs, response),
          ctfs.ResponseClassifier.Default)
        responseClass match {
          case ctfs.ResponseClass.Successful(_) =>
            __stats_getModelIds.SuccessCounter.incr()
          case ctfs.ResponseClass.Failed(_) =>
            __stats_getModelIds.FailuresCounter.incr()
            response match {
              case Throw(ex) =>
                setServiceName(ex)
                __stats_getModelIds.FailuresScope.counter(Throwables.mkString(ex): _*).incr()
              case _ =>
            }
        }
      }
    }
  }
  private[this] object __stats_updateProject {
    val RequestsCounter = scopedStats.scope("updateProject").counter("requests")
    val SuccessCounter = scopedStats.scope("updateProject").counter("success")
    val FailuresCounter = scopedStats.scope("updateProject").counter("failures")
    val FailuresScope = scopedStats.scope("updateProject").scope("failures")
  }
  val updateProjectModelDBServiceReplyDeserializer: Array[Byte] => _root_.com.twitter.util.Try[Boolean] = {
    response: Array[Byte] => {
      val result = decodeResponse(response, UpdateProject.Result)
  
      result.firstException() match {
        case Some(exception) => _root_.com.twitter.util.Throw(setServiceName(exception))
        case _ => result.successField match {
          case Some(success) => _root_.com.twitter.util.Return(success)
          case _ => _root_.com.twitter.util.Throw(missingResult("updateProject"))
        }
      }
    }
  }
  
  def updateProject(projectId: Int, key: String, value: String): Future[Boolean] = {
    __stats_updateProject.RequestsCounter.incr()
    val inputArgs = UpdateProject.Args(projectId, key, value)
  
    val serdeCtx = new _root_.com.twitter.finagle.thrift.ClientDeserializeCtx[Boolean](inputArgs, updateProjectModelDBServiceReplyDeserializer)
    _root_.com.twitter.finagle.context.Contexts.local.let(
      _root_.com.twitter.finagle.thrift.ClientDeserializeCtx.Key,
      serdeCtx,
      _root_.com.twitter.finagle.thrift.Headers.Request.Key,
      _root_.com.twitter.finagle.thrift.Headers.Request.newValues
    ) {
      val serialized = encodeRequest("updateProject", inputArgs)
      this.service(serialized).flatMap { response =>
        Future.const(serdeCtx.deserialize(response))
      }.respond { response =>
        val responseClass = responseClassifier.applyOrElse(
          ctfs.ReqRep(inputArgs, response),
          ctfs.ResponseClassifier.Default)
        responseClass match {
          case ctfs.ResponseClass.Successful(_) =>
            __stats_updateProject.SuccessCounter.incr()
          case ctfs.ResponseClass.Failed(_) =>
            __stats_updateProject.FailuresCounter.incr()
            response match {
              case Throw(ex) =>
                setServiceName(ex)
                __stats_updateProject.FailuresScope.counter(Throwables.mkString(ex): _*).incr()
              case _ =>
            }
        }
      }
    }
  }
  private[this] object __stats_createOrUpdateScalarField {
    val RequestsCounter = scopedStats.scope("createOrUpdateScalarField").counter("requests")
    val SuccessCounter = scopedStats.scope("createOrUpdateScalarField").counter("success")
    val FailuresCounter = scopedStats.scope("createOrUpdateScalarField").counter("failures")
    val FailuresScope = scopedStats.scope("createOrUpdateScalarField").scope("failures")
  }
  val createOrUpdateScalarFieldModelDBServiceReplyDeserializer: Array[Byte] => _root_.com.twitter.util.Try[Boolean] = {
    response: Array[Byte] => {
      val result = decodeResponse(response, CreateOrUpdateScalarField.Result)
  
      result.firstException() match {
        case Some(exception) => _root_.com.twitter.util.Throw(setServiceName(exception))
        case _ => result.successField match {
          case Some(success) => _root_.com.twitter.util.Return(success)
          case _ => _root_.com.twitter.util.Throw(missingResult("createOrUpdateScalarField"))
        }
      }
    }
  }
  
  def createOrUpdateScalarField(modelId: Int, key: String, value: String, valueType: String): Future[Boolean] = {
    __stats_createOrUpdateScalarField.RequestsCounter.incr()
    val inputArgs = CreateOrUpdateScalarField.Args(modelId, key, value, valueType)
  
    val serdeCtx = new _root_.com.twitter.finagle.thrift.ClientDeserializeCtx[Boolean](inputArgs, createOrUpdateScalarFieldModelDBServiceReplyDeserializer)
    _root_.com.twitter.finagle.context.Contexts.local.let(
      _root_.com.twitter.finagle.thrift.ClientDeserializeCtx.Key,
      serdeCtx,
      _root_.com.twitter.finagle.thrift.Headers.Request.Key,
      _root_.com.twitter.finagle.thrift.Headers.Request.newValues
    ) {
      val serialized = encodeRequest("createOrUpdateScalarField", inputArgs)
      this.service(serialized).flatMap { response =>
        Future.const(serdeCtx.deserialize(response))
      }.respond { response =>
        val responseClass = responseClassifier.applyOrElse(
          ctfs.ReqRep(inputArgs, response),
          ctfs.ResponseClassifier.Default)
        responseClass match {
          case ctfs.ResponseClass.Successful(_) =>
            __stats_createOrUpdateScalarField.SuccessCounter.incr()
          case ctfs.ResponseClass.Failed(_) =>
            __stats_createOrUpdateScalarField.FailuresCounter.incr()
            response match {
              case Throw(ex) =>
                setServiceName(ex)
                __stats_createOrUpdateScalarField.FailuresScope.counter(Throwables.mkString(ex): _*).incr()
              case _ =>
            }
        }
      }
    }
  }
  private[this] object __stats_createVectorField {
    val RequestsCounter = scopedStats.scope("createVectorField").counter("requests")
    val SuccessCounter = scopedStats.scope("createVectorField").counter("success")
    val FailuresCounter = scopedStats.scope("createVectorField").counter("failures")
    val FailuresScope = scopedStats.scope("createVectorField").scope("failures")
  }
  val createVectorFieldModelDBServiceReplyDeserializer: Array[Byte] => _root_.com.twitter.util.Try[Boolean] = {
    response: Array[Byte] => {
      val result = decodeResponse(response, CreateVectorField.Result)
  
      result.firstException() match {
        case Some(exception) => _root_.com.twitter.util.Throw(setServiceName(exception))
        case _ => result.successField match {
          case Some(success) => _root_.com.twitter.util.Return(success)
          case _ => _root_.com.twitter.util.Throw(missingResult("createVectorField"))
        }
      }
    }
  }
  
  def createVectorField(modelId: Int, vectorName: String, vectorConfig: Map[String, String] = Map[String, String]()): Future[Boolean] = {
    __stats_createVectorField.RequestsCounter.incr()
    val inputArgs = CreateVectorField.Args(modelId, vectorName, vectorConfig)
  
    val serdeCtx = new _root_.com.twitter.finagle.thrift.ClientDeserializeCtx[Boolean](inputArgs, createVectorFieldModelDBServiceReplyDeserializer)
    _root_.com.twitter.finagle.context.Contexts.local.let(
      _root_.com.twitter.finagle.thrift.ClientDeserializeCtx.Key,
      serdeCtx,
      _root_.com.twitter.finagle.thrift.Headers.Request.Key,
      _root_.com.twitter.finagle.thrift.Headers.Request.newValues
    ) {
      val serialized = encodeRequest("createVectorField", inputArgs)
      this.service(serialized).flatMap { response =>
        Future.const(serdeCtx.deserialize(response))
      }.respond { response =>
        val responseClass = responseClassifier.applyOrElse(
          ctfs.ReqRep(inputArgs, response),
          ctfs.ResponseClassifier.Default)
        responseClass match {
          case ctfs.ResponseClass.Successful(_) =>
            __stats_createVectorField.SuccessCounter.incr()
          case ctfs.ResponseClass.Failed(_) =>
            __stats_createVectorField.FailuresCounter.incr()
            response match {
              case Throw(ex) =>
                setServiceName(ex)
                __stats_createVectorField.FailuresScope.counter(Throwables.mkString(ex): _*).incr()
              case _ =>
            }
        }
      }
    }
  }
  private[this] object __stats_updateVectorField {
    val RequestsCounter = scopedStats.scope("updateVectorField").counter("requests")
    val SuccessCounter = scopedStats.scope("updateVectorField").counter("success")
    val FailuresCounter = scopedStats.scope("updateVectorField").counter("failures")
    val FailuresScope = scopedStats.scope("updateVectorField").scope("failures")
  }
  val updateVectorFieldModelDBServiceReplyDeserializer: Array[Byte] => _root_.com.twitter.util.Try[Boolean] = {
    response: Array[Byte] => {
      val result = decodeResponse(response, UpdateVectorField.Result)
  
      result.firstException() match {
        case Some(exception) => _root_.com.twitter.util.Throw(setServiceName(exception))
        case _ => result.successField match {
          case Some(success) => _root_.com.twitter.util.Return(success)
          case _ => _root_.com.twitter.util.Throw(missingResult("updateVectorField"))
        }
      }
    }
  }
  
  def updateVectorField(modelId: Int, key: String, valueIndex: Int, value: String, valueType: String): Future[Boolean] = {
    __stats_updateVectorField.RequestsCounter.incr()
    val inputArgs = UpdateVectorField.Args(modelId, key, valueIndex, value, valueType)
  
    val serdeCtx = new _root_.com.twitter.finagle.thrift.ClientDeserializeCtx[Boolean](inputArgs, updateVectorFieldModelDBServiceReplyDeserializer)
    _root_.com.twitter.finagle.context.Contexts.local.let(
      _root_.com.twitter.finagle.thrift.ClientDeserializeCtx.Key,
      serdeCtx,
      _root_.com.twitter.finagle.thrift.Headers.Request.Key,
      _root_.com.twitter.finagle.thrift.Headers.Request.newValues
    ) {
      val serialized = encodeRequest("updateVectorField", inputArgs)
      this.service(serialized).flatMap { response =>
        Future.const(serdeCtx.deserialize(response))
      }.respond { response =>
        val responseClass = responseClassifier.applyOrElse(
          ctfs.ReqRep(inputArgs, response),
          ctfs.ResponseClassifier.Default)
        responseClass match {
          case ctfs.ResponseClass.Successful(_) =>
            __stats_updateVectorField.SuccessCounter.incr()
          case ctfs.ResponseClass.Failed(_) =>
            __stats_updateVectorField.FailuresCounter.incr()
            response match {
              case Throw(ex) =>
                setServiceName(ex)
                __stats_updateVectorField.FailuresScope.counter(Throwables.mkString(ex): _*).incr()
              case _ =>
            }
        }
      }
    }
  }
  private[this] object __stats_appendToVectorField {
    val RequestsCounter = scopedStats.scope("appendToVectorField").counter("requests")
    val SuccessCounter = scopedStats.scope("appendToVectorField").counter("success")
    val FailuresCounter = scopedStats.scope("appendToVectorField").counter("failures")
    val FailuresScope = scopedStats.scope("appendToVectorField").scope("failures")
  }
  val appendToVectorFieldModelDBServiceReplyDeserializer: Array[Byte] => _root_.com.twitter.util.Try[Boolean] = {
    response: Array[Byte] => {
      val result = decodeResponse(response, AppendToVectorField.Result)
  
      result.firstException() match {
        case Some(exception) => _root_.com.twitter.util.Throw(setServiceName(exception))
        case _ => result.successField match {
          case Some(success) => _root_.com.twitter.util.Return(success)
          case _ => _root_.com.twitter.util.Throw(missingResult("appendToVectorField"))
        }
      }
    }
  }
  
  def appendToVectorField(modelId: Int, vectorName: String, value: String, valueType: String): Future[Boolean] = {
    __stats_appendToVectorField.RequestsCounter.incr()
    val inputArgs = AppendToVectorField.Args(modelId, vectorName, value, valueType)
  
    val serdeCtx = new _root_.com.twitter.finagle.thrift.ClientDeserializeCtx[Boolean](inputArgs, appendToVectorFieldModelDBServiceReplyDeserializer)
    _root_.com.twitter.finagle.context.Contexts.local.let(
      _root_.com.twitter.finagle.thrift.ClientDeserializeCtx.Key,
      serdeCtx,
      _root_.com.twitter.finagle.thrift.Headers.Request.Key,
      _root_.com.twitter.finagle.thrift.Headers.Request.newValues
    ) {
      val serialized = encodeRequest("appendToVectorField", inputArgs)
      this.service(serialized).flatMap { response =>
        Future.const(serdeCtx.deserialize(response))
      }.respond { response =>
        val responseClass = responseClassifier.applyOrElse(
          ctfs.ReqRep(inputArgs, response),
          ctfs.ResponseClassifier.Default)
        responseClass match {
          case ctfs.ResponseClass.Successful(_) =>
            __stats_appendToVectorField.SuccessCounter.incr()
          case ctfs.ResponseClass.Failed(_) =>
            __stats_appendToVectorField.FailuresCounter.incr()
            response match {
              case Throw(ex) =>
                setServiceName(ex)
                __stats_appendToVectorField.FailuresScope.counter(Throwables.mkString(ex): _*).incr()
              case _ =>
            }
        }
      }
    }
  }
  private[this] object __stats_getModel {
    val RequestsCounter = scopedStats.scope("getModel").counter("requests")
    val SuccessCounter = scopedStats.scope("getModel").counter("success")
    val FailuresCounter = scopedStats.scope("getModel").counter("failures")
    val FailuresScope = scopedStats.scope("getModel").scope("failures")
  }
  val getModelModelDBServiceReplyDeserializer: Array[Byte] => _root_.com.twitter.util.Try[modeldb.ModelResponse] = {
    response: Array[Byte] => {
      val result = decodeResponse(response, GetModel.Result)
  
      result.firstException() match {
        case Some(exception) => _root_.com.twitter.util.Throw(setServiceName(exception))
        case _ => result.successField match {
          case Some(success) => _root_.com.twitter.util.Return(success)
          case _ => _root_.com.twitter.util.Throw(missingResult("getModel"))
        }
      }
    }
  }
  
  def getModel(modelId: Int): Future[modeldb.ModelResponse] = {
    __stats_getModel.RequestsCounter.incr()
    val inputArgs = GetModel.Args(modelId)
  
    val serdeCtx = new _root_.com.twitter.finagle.thrift.ClientDeserializeCtx[modeldb.ModelResponse](inputArgs, getModelModelDBServiceReplyDeserializer)
    _root_.com.twitter.finagle.context.Contexts.local.let(
      _root_.com.twitter.finagle.thrift.ClientDeserializeCtx.Key,
      serdeCtx,
      _root_.com.twitter.finagle.thrift.Headers.Request.Key,
      _root_.com.twitter.finagle.thrift.Headers.Request.newValues
    ) {
      val serialized = encodeRequest("getModel", inputArgs)
      this.service(serialized).flatMap { response =>
        Future.const(serdeCtx.deserialize(response))
      }.respond { response =>
        val responseClass = responseClassifier.applyOrElse(
          ctfs.ReqRep(inputArgs, response),
          ctfs.ResponseClassifier.Default)
        responseClass match {
          case ctfs.ResponseClass.Successful(_) =>
            __stats_getModel.SuccessCounter.incr()
          case ctfs.ResponseClass.Failed(_) =>
            __stats_getModel.FailuresCounter.incr()
            response match {
              case Throw(ex) =>
                setServiceName(ex)
                __stats_getModel.FailuresScope.counter(Throwables.mkString(ex): _*).incr()
              case _ =>
            }
        }
      }
    }
  }
  private[this] object __stats_getRunsInExperiment {
    val RequestsCounter = scopedStats.scope("getRunsInExperiment").counter("requests")
    val SuccessCounter = scopedStats.scope("getRunsInExperiment").counter("success")
    val FailuresCounter = scopedStats.scope("getRunsInExperiment").counter("failures")
    val FailuresScope = scopedStats.scope("getRunsInExperiment").scope("failures")
  }
  val getRunsInExperimentModelDBServiceReplyDeserializer: Array[Byte] => _root_.com.twitter.util.Try[Seq[modeldb.ExperimentRun]] = {
    response: Array[Byte] => {
      val result = decodeResponse(response, GetRunsInExperiment.Result)
  
      result.firstException() match {
        case Some(exception) => _root_.com.twitter.util.Throw(setServiceName(exception))
        case _ => result.successField match {
          case Some(success) => _root_.com.twitter.util.Return(success)
          case _ => _root_.com.twitter.util.Throw(missingResult("getRunsInExperiment"))
        }
      }
    }
  }
  
  def getRunsInExperiment(experimentId: Int): Future[Seq[modeldb.ExperimentRun]] = {
    __stats_getRunsInExperiment.RequestsCounter.incr()
    val inputArgs = GetRunsInExperiment.Args(experimentId)
  
    val serdeCtx = new _root_.com.twitter.finagle.thrift.ClientDeserializeCtx[Seq[modeldb.ExperimentRun]](inputArgs, getRunsInExperimentModelDBServiceReplyDeserializer)
    _root_.com.twitter.finagle.context.Contexts.local.let(
      _root_.com.twitter.finagle.thrift.ClientDeserializeCtx.Key,
      serdeCtx,
      _root_.com.twitter.finagle.thrift.Headers.Request.Key,
      _root_.com.twitter.finagle.thrift.Headers.Request.newValues
    ) {
      val serialized = encodeRequest("getRunsInExperiment", inputArgs)
      this.service(serialized).flatMap { response =>
        Future.const(serdeCtx.deserialize(response))
      }.respond { response =>
        val responseClass = responseClassifier.applyOrElse(
          ctfs.ReqRep(inputArgs, response),
          ctfs.ResponseClassifier.Default)
        responseClass match {
          case ctfs.ResponseClass.Successful(_) =>
            __stats_getRunsInExperiment.SuccessCounter.incr()
          case ctfs.ResponseClass.Failed(_) =>
            __stats_getRunsInExperiment.FailuresCounter.incr()
            response match {
              case Throw(ex) =>
                setServiceName(ex)
                __stats_getRunsInExperiment.FailuresScope.counter(Throwables.mkString(ex): _*).incr()
              case _ =>
            }
        }
      }
    }
  }
  private[this] object __stats_getRunsAndExperimentsInProject {
    val RequestsCounter = scopedStats.scope("getRunsAndExperimentsInProject").counter("requests")
    val SuccessCounter = scopedStats.scope("getRunsAndExperimentsInProject").counter("success")
    val FailuresCounter = scopedStats.scope("getRunsAndExperimentsInProject").counter("failures")
    val FailuresScope = scopedStats.scope("getRunsAndExperimentsInProject").scope("failures")
  }
  val getRunsAndExperimentsInProjectModelDBServiceReplyDeserializer: Array[Byte] => _root_.com.twitter.util.Try[modeldb.ProjectExperimentsAndRuns] = {
    response: Array[Byte] => {
      val result = decodeResponse(response, GetRunsAndExperimentsInProject.Result)
  
      result.firstException() match {
        case Some(exception) => _root_.com.twitter.util.Throw(setServiceName(exception))
        case _ => result.successField match {
          case Some(success) => _root_.com.twitter.util.Return(success)
          case _ => _root_.com.twitter.util.Throw(missingResult("getRunsAndExperimentsInProject"))
        }
      }
    }
  }
  
  def getRunsAndExperimentsInProject(projId: Int): Future[modeldb.ProjectExperimentsAndRuns] = {
    __stats_getRunsAndExperimentsInProject.RequestsCounter.incr()
    val inputArgs = GetRunsAndExperimentsInProject.Args(projId)
  
    val serdeCtx = new _root_.com.twitter.finagle.thrift.ClientDeserializeCtx[modeldb.ProjectExperimentsAndRuns](inputArgs, getRunsAndExperimentsInProjectModelDBServiceReplyDeserializer)
    _root_.com.twitter.finagle.context.Contexts.local.let(
      _root_.com.twitter.finagle.thrift.ClientDeserializeCtx.Key,
      serdeCtx,
      _root_.com.twitter.finagle.thrift.Headers.Request.Key,
      _root_.com.twitter.finagle.thrift.Headers.Request.newValues
    ) {
      val serialized = encodeRequest("getRunsAndExperimentsInProject", inputArgs)
      this.service(serialized).flatMap { response =>
        Future.const(serdeCtx.deserialize(response))
      }.respond { response =>
        val responseClass = responseClassifier.applyOrElse(
          ctfs.ReqRep(inputArgs, response),
          ctfs.ResponseClassifier.Default)
        responseClass match {
          case ctfs.ResponseClass.Successful(_) =>
            __stats_getRunsAndExperimentsInProject.SuccessCounter.incr()
          case ctfs.ResponseClass.Failed(_) =>
            __stats_getRunsAndExperimentsInProject.FailuresCounter.incr()
            response match {
              case Throw(ex) =>
                setServiceName(ex)
                __stats_getRunsAndExperimentsInProject.FailuresScope.counter(Throwables.mkString(ex): _*).incr()
              case _ =>
            }
        }
      }
    }
  }
  private[this] object __stats_getProjectOverviews {
    val RequestsCounter = scopedStats.scope("getProjectOverviews").counter("requests")
    val SuccessCounter = scopedStats.scope("getProjectOverviews").counter("success")
    val FailuresCounter = scopedStats.scope("getProjectOverviews").counter("failures")
    val FailuresScope = scopedStats.scope("getProjectOverviews").scope("failures")
  }
  val getProjectOverviewsModelDBServiceReplyDeserializer: Array[Byte] => _root_.com.twitter.util.Try[Seq[modeldb.ProjectOverviewResponse]] = {
    response: Array[Byte] => {
      val result = decodeResponse(response, GetProjectOverviews.Result)
  
      result.firstException() match {
        case Some(exception) => _root_.com.twitter.util.Throw(setServiceName(exception))
        case _ => result.successField match {
          case Some(success) => _root_.com.twitter.util.Return(success)
          case _ => _root_.com.twitter.util.Throw(missingResult("getProjectOverviews"))
        }
      }
    }
  }
  
  def getProjectOverviews(): Future[Seq[modeldb.ProjectOverviewResponse]] = {
    __stats_getProjectOverviews.RequestsCounter.incr()
    val inputArgs = GetProjectOverviews.Args()
  
    val serdeCtx = new _root_.com.twitter.finagle.thrift.ClientDeserializeCtx[Seq[modeldb.ProjectOverviewResponse]](inputArgs, getProjectOverviewsModelDBServiceReplyDeserializer)
    _root_.com.twitter.finagle.context.Contexts.local.let(
      _root_.com.twitter.finagle.thrift.ClientDeserializeCtx.Key,
      serdeCtx,
      _root_.com.twitter.finagle.thrift.Headers.Request.Key,
      _root_.com.twitter.finagle.thrift.Headers.Request.newValues
    ) {
      val serialized = encodeRequest("getProjectOverviews", inputArgs)
      this.service(serialized).flatMap { response =>
        Future.const(serdeCtx.deserialize(response))
      }.respond { response =>
        val responseClass = responseClassifier.applyOrElse(
          ctfs.ReqRep(inputArgs, response),
          ctfs.ResponseClassifier.Default)
        responseClass match {
          case ctfs.ResponseClass.Successful(_) =>
            __stats_getProjectOverviews.SuccessCounter.incr()
          case ctfs.ResponseClass.Failed(_) =>
            __stats_getProjectOverviews.FailuresCounter.incr()
            response match {
              case Throw(ex) =>
                setServiceName(ex)
                __stats_getProjectOverviews.FailuresScope.counter(Throwables.mkString(ex): _*).incr()
              case _ =>
            }
        }
      }
    }
  }
  private[this] object __stats_getExperimentRunDetails {
    val RequestsCounter = scopedStats.scope("getExperimentRunDetails").counter("requests")
    val SuccessCounter = scopedStats.scope("getExperimentRunDetails").counter("success")
    val FailuresCounter = scopedStats.scope("getExperimentRunDetails").counter("failures")
    val FailuresScope = scopedStats.scope("getExperimentRunDetails").scope("failures")
  }
  val getExperimentRunDetailsModelDBServiceReplyDeserializer: Array[Byte] => _root_.com.twitter.util.Try[modeldb.ExperimentRunDetailsResponse] = {
    response: Array[Byte] => {
      val result = decodeResponse(response, GetExperimentRunDetails.Result)
  
      result.firstException() match {
        case Some(exception) => _root_.com.twitter.util.Throw(setServiceName(exception))
        case _ => result.successField match {
          case Some(success) => _root_.com.twitter.util.Return(success)
          case _ => _root_.com.twitter.util.Throw(missingResult("getExperimentRunDetails"))
        }
      }
    }
  }
  
  def getExperimentRunDetails(experimentRunId: Int): Future[modeldb.ExperimentRunDetailsResponse] = {
    __stats_getExperimentRunDetails.RequestsCounter.incr()
    val inputArgs = GetExperimentRunDetails.Args(experimentRunId)
  
    val serdeCtx = new _root_.com.twitter.finagle.thrift.ClientDeserializeCtx[modeldb.ExperimentRunDetailsResponse](inputArgs, getExperimentRunDetailsModelDBServiceReplyDeserializer)
    _root_.com.twitter.finagle.context.Contexts.local.let(
      _root_.com.twitter.finagle.thrift.ClientDeserializeCtx.Key,
      serdeCtx,
      _root_.com.twitter.finagle.thrift.Headers.Request.Key,
      _root_.com.twitter.finagle.thrift.Headers.Request.newValues
    ) {
      val serialized = encodeRequest("getExperimentRunDetails", inputArgs)
      this.service(serialized).flatMap { response =>
        Future.const(serdeCtx.deserialize(response))
      }.respond { response =>
        val responseClass = responseClassifier.applyOrElse(
          ctfs.ReqRep(inputArgs, response),
          ctfs.ResponseClassifier.Default)
        responseClass match {
          case ctfs.ResponseClass.Successful(_) =>
            __stats_getExperimentRunDetails.SuccessCounter.incr()
          case ctfs.ResponseClass.Failed(_) =>
            __stats_getExperimentRunDetails.FailuresCounter.incr()
            response match {
              case Throw(ex) =>
                setServiceName(ex)
                __stats_getExperimentRunDetails.FailuresScope.counter(Throwables.mkString(ex): _*).incr()
              case _ =>
            }
        }
      }
    }
  }
  private[this] object __stats_originalFeatures {
    val RequestsCounter = scopedStats.scope("originalFeatures").counter("requests")
    val SuccessCounter = scopedStats.scope("originalFeatures").counter("success")
    val FailuresCounter = scopedStats.scope("originalFeatures").counter("failures")
    val FailuresScope = scopedStats.scope("originalFeatures").scope("failures")
  }
  val originalFeaturesModelDBServiceReplyDeserializer: Array[Byte] => _root_.com.twitter.util.Try[Seq[String]] = {
    response: Array[Byte] => {
      val result = decodeResponse(response, OriginalFeatures.Result)
  
      result.firstException() match {
        case Some(exception) => _root_.com.twitter.util.Throw(setServiceName(exception))
        case _ => result.successField match {
          case Some(success) => _root_.com.twitter.util.Return(success)
          case _ => _root_.com.twitter.util.Throw(missingResult("originalFeatures"))
        }
      }
    }
  }
  
  def originalFeatures(modelId: Int): Future[Seq[String]] = {
    __stats_originalFeatures.RequestsCounter.incr()
    val inputArgs = OriginalFeatures.Args(modelId)
  
    val serdeCtx = new _root_.com.twitter.finagle.thrift.ClientDeserializeCtx[Seq[String]](inputArgs, originalFeaturesModelDBServiceReplyDeserializer)
    _root_.com.twitter.finagle.context.Contexts.local.let(
      _root_.com.twitter.finagle.thrift.ClientDeserializeCtx.Key,
      serdeCtx,
      _root_.com.twitter.finagle.thrift.Headers.Request.Key,
      _root_.com.twitter.finagle.thrift.Headers.Request.newValues
    ) {
      val serialized = encodeRequest("originalFeatures", inputArgs)
      this.service(serialized).flatMap { response =>
        Future.const(serdeCtx.deserialize(response))
      }.respond { response =>
        val responseClass = responseClassifier.applyOrElse(
          ctfs.ReqRep(inputArgs, response),
          ctfs.ResponseClassifier.Default)
        responseClass match {
          case ctfs.ResponseClass.Successful(_) =>
            __stats_originalFeatures.SuccessCounter.incr()
          case ctfs.ResponseClass.Failed(_) =>
            __stats_originalFeatures.FailuresCounter.incr()
            response match {
              case Throw(ex) =>
                setServiceName(ex)
                __stats_originalFeatures.FailuresScope.counter(Throwables.mkString(ex): _*).incr()
              case _ =>
            }
        }
      }
    }
  }
  private[this] object __stats_storeTreeModel {
    val RequestsCounter = scopedStats.scope("storeTreeModel").counter("requests")
    val SuccessCounter = scopedStats.scope("storeTreeModel").counter("success")
    val FailuresCounter = scopedStats.scope("storeTreeModel").counter("failures")
    val FailuresScope = scopedStats.scope("storeTreeModel").scope("failures")
  }
  val storeTreeModelModelDBServiceReplyDeserializer: Array[Byte] => _root_.com.twitter.util.Try[Boolean] = {
    response: Array[Byte] => {
      val result = decodeResponse(response, StoreTreeModel.Result)
  
      result.firstException() match {
        case Some(exception) => _root_.com.twitter.util.Throw(setServiceName(exception))
        case _ => result.successField match {
          case Some(success) => _root_.com.twitter.util.Return(success)
          case _ => _root_.com.twitter.util.Throw(missingResult("storeTreeModel"))
        }
      }
    }
  }
  
  def storeTreeModel(modelId: Int, model: modeldb.TreeModel): Future[Boolean] = {
    __stats_storeTreeModel.RequestsCounter.incr()
    val inputArgs = StoreTreeModel.Args(modelId, model)
  
    val serdeCtx = new _root_.com.twitter.finagle.thrift.ClientDeserializeCtx[Boolean](inputArgs, storeTreeModelModelDBServiceReplyDeserializer)
    _root_.com.twitter.finagle.context.Contexts.local.let(
      _root_.com.twitter.finagle.thrift.ClientDeserializeCtx.Key,
      serdeCtx,
      _root_.com.twitter.finagle.thrift.Headers.Request.Key,
      _root_.com.twitter.finagle.thrift.Headers.Request.newValues
    ) {
      val serialized = encodeRequest("storeTreeModel", inputArgs)
      this.service(serialized).flatMap { response =>
        Future.const(serdeCtx.deserialize(response))
      }.respond { response =>
        val responseClass = responseClassifier.applyOrElse(
          ctfs.ReqRep(inputArgs, response),
          ctfs.ResponseClassifier.Default)
        responseClass match {
          case ctfs.ResponseClass.Successful(_) =>
            __stats_storeTreeModel.SuccessCounter.incr()
          case ctfs.ResponseClass.Failed(_) =>
            __stats_storeTreeModel.FailuresCounter.incr()
            response match {
              case Throw(ex) =>
                setServiceName(ex)
                __stats_storeTreeModel.FailuresScope.counter(Throwables.mkString(ex): _*).incr()
              case _ =>
            }
        }
      }
    }
  }
  private[this] object __stats_storePipelineTransformEvent {
    val RequestsCounter = scopedStats.scope("storePipelineTransformEvent").counter("requests")
    val SuccessCounter = scopedStats.scope("storePipelineTransformEvent").counter("success")
    val FailuresCounter = scopedStats.scope("storePipelineTransformEvent").counter("failures")
    val FailuresScope = scopedStats.scope("storePipelineTransformEvent").scope("failures")
  }
  val storePipelineTransformEventModelDBServiceReplyDeserializer: Array[Byte] => _root_.com.twitter.util.Try[Seq[modeldb.TransformEventResponse]] = {
    response: Array[Byte] => {
      val result = decodeResponse(response, StorePipelineTransformEvent.Result)
  
      result.firstException() match {
        case Some(exception) => _root_.com.twitter.util.Throw(setServiceName(exception))
        case _ => result.successField match {
          case Some(success) => _root_.com.twitter.util.Return(success)
          case _ => _root_.com.twitter.util.Throw(missingResult("storePipelineTransformEvent"))
        }
      }
    }
  }
  
  def storePipelineTransformEvent(te: Seq[modeldb.TransformEvent] = Seq[modeldb.TransformEvent]()): Future[Seq[modeldb.TransformEventResponse]] = {
    __stats_storePipelineTransformEvent.RequestsCounter.incr()
    val inputArgs = StorePipelineTransformEvent.Args(te)
  
    val serdeCtx = new _root_.com.twitter.finagle.thrift.ClientDeserializeCtx[Seq[modeldb.TransformEventResponse]](inputArgs, storePipelineTransformEventModelDBServiceReplyDeserializer)
    _root_.com.twitter.finagle.context.Contexts.local.let(
      _root_.com.twitter.finagle.thrift.ClientDeserializeCtx.Key,
      serdeCtx,
      _root_.com.twitter.finagle.thrift.Headers.Request.Key,
      _root_.com.twitter.finagle.thrift.Headers.Request.newValues
    ) {
      val serialized = encodeRequest("storePipelineTransformEvent", inputArgs)
      this.service(serialized).flatMap { response =>
        Future.const(serdeCtx.deserialize(response))
      }.respond { response =>
        val responseClass = responseClassifier.applyOrElse(
          ctfs.ReqRep(inputArgs, response),
          ctfs.ResponseClassifier.Default)
        responseClass match {
          case ctfs.ResponseClass.Successful(_) =>
            __stats_storePipelineTransformEvent.SuccessCounter.incr()
          case ctfs.ResponseClass.Failed(_) =>
            __stats_storePipelineTransformEvent.FailuresCounter.incr()
            response match {
              case Throw(ex) =>
                setServiceName(ex)
                __stats_storePipelineTransformEvent.FailuresScope.counter(Throwables.mkString(ex): _*).incr()
              case _ =>
            }
        }
      }
    }
  }
  private[this] object __stats_computeModelAncestry {
    val RequestsCounter = scopedStats.scope("computeModelAncestry").counter("requests")
    val SuccessCounter = scopedStats.scope("computeModelAncestry").counter("success")
    val FailuresCounter = scopedStats.scope("computeModelAncestry").counter("failures")
    val FailuresScope = scopedStats.scope("computeModelAncestry").scope("failures")
  }
  val computeModelAncestryModelDBServiceReplyDeserializer: Array[Byte] => _root_.com.twitter.util.Try[modeldb.ModelAncestryResponse] = {
    response: Array[Byte] => {
      val result = decodeResponse(response, ComputeModelAncestry.Result)
  
      result.firstException() match {
        case Some(exception) => _root_.com.twitter.util.Throw(setServiceName(exception))
        case _ => result.successField match {
          case Some(success) => _root_.com.twitter.util.Return(success)
          case _ => _root_.com.twitter.util.Throw(missingResult("computeModelAncestry"))
        }
      }
    }
  }
  
  def computeModelAncestry(modelId: Int): Future[modeldb.ModelAncestryResponse] = {
    __stats_computeModelAncestry.RequestsCounter.incr()
    val inputArgs = ComputeModelAncestry.Args(modelId)
  
    val serdeCtx = new _root_.com.twitter.finagle.thrift.ClientDeserializeCtx[modeldb.ModelAncestryResponse](inputArgs, computeModelAncestryModelDBServiceReplyDeserializer)
    _root_.com.twitter.finagle.context.Contexts.local.let(
      _root_.com.twitter.finagle.thrift.ClientDeserializeCtx.Key,
      serdeCtx,
      _root_.com.twitter.finagle.thrift.Headers.Request.Key,
      _root_.com.twitter.finagle.thrift.Headers.Request.newValues
    ) {
      val serialized = encodeRequest("computeModelAncestry", inputArgs)
      this.service(serialized).flatMap { response =>
        Future.const(serdeCtx.deserialize(response))
      }.respond { response =>
        val responseClass = responseClassifier.applyOrElse(
          ctfs.ReqRep(inputArgs, response),
          ctfs.ResponseClassifier.Default)
        responseClass match {
          case ctfs.ResponseClass.Successful(_) =>
            __stats_computeModelAncestry.SuccessCounter.incr()
          case ctfs.ResponseClass.Failed(_) =>
            __stats_computeModelAncestry.FailuresCounter.incr()
            response match {
              case Throw(ex) =>
                setServiceName(ex)
                __stats_computeModelAncestry.FailuresScope.counter(Throwables.mkString(ex): _*).incr()
              case _ =>
            }
        }
      }
    }
  }
  private[this] object __stats_extractPipeline {
    val RequestsCounter = scopedStats.scope("extractPipeline").counter("requests")
    val SuccessCounter = scopedStats.scope("extractPipeline").counter("success")
    val FailuresCounter = scopedStats.scope("extractPipeline").counter("failures")
    val FailuresScope = scopedStats.scope("extractPipeline").scope("failures")
  }
  val extractPipelineModelDBServiceReplyDeserializer: Array[Byte] => _root_.com.twitter.util.Try[modeldb.ExtractedPipelineResponse] = {
    response: Array[Byte] => {
      val result = decodeResponse(response, ExtractPipeline.Result)
  
      result.firstException() match {
        case Some(exception) => _root_.com.twitter.util.Throw(setServiceName(exception))
        case _ => result.successField match {
          case Some(success) => _root_.com.twitter.util.Return(success)
          case _ => _root_.com.twitter.util.Throw(missingResult("extractPipeline"))
        }
      }
    }
  }
  
  def extractPipeline(modelId: Int): Future[modeldb.ExtractedPipelineResponse] = {
    __stats_extractPipeline.RequestsCounter.incr()
    val inputArgs = ExtractPipeline.Args(modelId)
  
    val serdeCtx = new _root_.com.twitter.finagle.thrift.ClientDeserializeCtx[modeldb.ExtractedPipelineResponse](inputArgs, extractPipelineModelDBServiceReplyDeserializer)
    _root_.com.twitter.finagle.context.Contexts.local.let(
      _root_.com.twitter.finagle.thrift.ClientDeserializeCtx.Key,
      serdeCtx,
      _root_.com.twitter.finagle.thrift.Headers.Request.Key,
      _root_.com.twitter.finagle.thrift.Headers.Request.newValues
    ) {
      val serialized = encodeRequest("extractPipeline", inputArgs)
      this.service(serialized).flatMap { response =>
        Future.const(serdeCtx.deserialize(response))
      }.respond { response =>
        val responseClass = responseClassifier.applyOrElse(
          ctfs.ReqRep(inputArgs, response),
          ctfs.ResponseClassifier.Default)
        responseClass match {
          case ctfs.ResponseClass.Successful(_) =>
            __stats_extractPipeline.SuccessCounter.incr()
          case ctfs.ResponseClass.Failed(_) =>
            __stats_extractPipeline.FailuresCounter.incr()
            response match {
              case Throw(ex) =>
                setServiceName(ex)
                __stats_extractPipeline.FailuresScope.counter(Throwables.mkString(ex): _*).incr()
              case _ =>
            }
        }
      }
    }
  }
}
