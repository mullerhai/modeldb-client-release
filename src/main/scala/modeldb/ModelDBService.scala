/**
 * Generated by Scrooge
 *   version: 18.10.0
 *   rev: dda071e1412b53f4bfdebc19e474f584e475d475
 *   built at: 20181018-174244
 */
package modeldb

import com.twitter.scrooge._
import com.twitter.finagle.{
  service => ctfs,
  Filter => finagle$Filter,
  Service => finagle$Service,
  thrift => _,
  _
}
import com.twitter.finagle.stats.{Counter, StatsReceiver}
import com.twitter.finagle.thrift.{
  Protocols,
  RichClientParam,
  RichServerParam,
  ServerToReqRep,
  ThriftClientRequest,
  ThriftServiceIface,
  ToThriftService
}
import com.twitter.util.{Future, Return, Throw, Throwables}
import com.twitter.io.Buf
import java.nio.ByteBuffer
import java.util.Arrays
import org.apache.thrift.protocol._
import org.apache.thrift.TApplicationException
import scala.collection.immutable.{Map => immutable$Map, Set => immutable$Set}
import scala.collection.mutable.{
  Builder,
  ArrayBuffer => mutable$ArrayBuffer, Buffer => mutable$Buffer,
  HashMap => mutable$HashMap, HashSet => mutable$HashSet}
import scala.collection.{Map, Set}
import scala.language.higherKinds


@javax.annotation.Generated(value = Array("com.twitter.scrooge.Compiler"))
trait ModelDBService[+MM[_]] extends _root_.com.twitter.finagle.thrift.ThriftService {
  
  def testConnection(): MM[Int]
  
  def storeDataFrame(df: modeldb.DataFrame, experimentRunId: Int): MM[Int]
  
  def pathForTransformer(transformerId: Int): MM[String]
  
  def storeFitEvent(fe: modeldb.FitEvent): MM[modeldb.FitEventResponse]
  
  def storeMetricEvent(me: modeldb.MetricEvent): MM[modeldb.MetricEventResponse]
  
  def getFilePath(t: modeldb.Transformer, experimentRunId: Int, filename: String): MM[String]
  
  def storeTransformEvent(te: modeldb.TransformEvent): MM[modeldb.TransformEventResponse]
  
  def storeRandomSplitEvent(rse: modeldb.RandomSplitEvent): MM[modeldb.RandomSplitEventResponse]
  
  def storePipelineEvent(pipelineEvent: modeldb.PipelineEvent): MM[modeldb.PipelineEventResponse]
  
  def storeCrossValidationEvent(cve: modeldb.CrossValidationEvent): MM[modeldb.CrossValidationEventResponse]
  
  def storeGridSearchCrossValidationEvent(gscve: modeldb.GridSearchCrossValidationEvent): MM[modeldb.GridSearchCrossValidationEventResponse]
  
  def storeAnnotationEvent(ae: modeldb.AnnotationEvent): MM[modeldb.AnnotationEventResponse]
  
  def storeProjectEvent(pr: modeldb.ProjectEvent): MM[modeldb.ProjectEventResponse]
  
  def storeExperimentEvent(er: modeldb.ExperimentEvent): MM[modeldb.ExperimentEventResponse]
  
  def storeExperimentRunEvent(er: modeldb.ExperimentRunEvent): MM[modeldb.ExperimentRunEventResponse]
  
  def storeLinearModel(modelId: Int, model: modeldb.LinearModel): MM[Boolean]
  
  def getDataFrameAncestry(dataFrameId: Int): MM[modeldb.DataFrameAncestry]
  
  def getCommonAncestor(dfId1: Int, dfId2: Int): MM[modeldb.CommonAncestor]
  
  def getCommonAncestorForModels(modelId1: Int, modelId2: Int): MM[modeldb.CommonAncestor]
  
  def getTrainingRowsCount(modelId: Int): MM[Int]
  
  def getTrainingRowsCounts(modelIds: Seq[Int] = Seq[Int]()): MM[Seq[Int]]
  
  def compareHyperparameters(modelId1: Int, modelId2: Int): MM[modeldb.CompareHyperParametersResponse]
  
  def compareFeatures(modelId1: Int, modelId2: Int): MM[modeldb.CompareFeaturesResponse]
  
  def groupByProblemType(modelIds: Seq[Int] = Seq[Int]()): MM[Map[modeldb.ProblemType, Seq[Int]]]
  
  def similarModels(modelId: Int, compMetrics: Seq[modeldb.ModelCompMetric] = Seq[modeldb.ModelCompMetric](), numModels: Int): MM[Seq[Int]]
  
  def linearModelFeatureImportances(modelId: Int): MM[Seq[String]]
  
  def compareLinearModelFeatureImportances(model1Id: Int, model2Id: Int): MM[Seq[modeldb.FeatureImportanceComparison]]
  
  def iterationsUntilConvergence(modelIds: Seq[Int] = Seq[Int](), tolerance: Double): MM[Seq[Int]]
  
  def rankModels(modelIds: Seq[Int] = Seq[Int](), metric: modeldb.ModelRankMetric): MM[Seq[Int]]
  
  def confidenceIntervals(modelId: Int, sigLevel: Double): MM[Seq[modeldb.ConfidenceInterval]]
  
  def modelsWithFeatures(featureNames: Seq[String] = Seq[String]()): MM[Seq[Int]]
  
  def modelsDerivedFromDataFrame(dfId: Int): MM[Seq[Int]]
  
  def getProjectIds(keyValuePairs: Map[String, String] = Map[String, String]()): MM[Seq[Int]]
  
  def getModelIds(keyValuePairs: Map[String, String] = Map[String, String]()): MM[Seq[Int]]
  
  def updateProject(projectId: Int, key: String, value: String): MM[Boolean]
  
  def createOrUpdateScalarField(modelId: Int, key: String, value: String, valueType: String): MM[Boolean]
  
  def createVectorField(modelId: Int, vectorName: String, vectorConfig: Map[String, String] = Map[String, String]()): MM[Boolean]
  
  def updateVectorField(modelId: Int, key: String, valueIndex: Int, value: String, valueType: String): MM[Boolean]
  
  def appendToVectorField(modelId: Int, vectorName: String, value: String, valueType: String): MM[Boolean]
  
  def getModel(modelId: Int): MM[modeldb.ModelResponse]
  
  def getRunsInExperiment(experimentId: Int): MM[Seq[modeldb.ExperimentRun]]
  
  def getRunsAndExperimentsInProject(projId: Int): MM[modeldb.ProjectExperimentsAndRuns]
  
  def getProjectOverviews(): MM[Seq[modeldb.ProjectOverviewResponse]]
  
  def getExperimentRunDetails(experimentRunId: Int): MM[modeldb.ExperimentRunDetailsResponse]
  
  def originalFeatures(modelId: Int): MM[Seq[String]]
  
  def storeTreeModel(modelId: Int, model: modeldb.TreeModel): MM[Boolean]
  
  def storePipelineTransformEvent(te: Seq[modeldb.TransformEvent] = Seq[modeldb.TransformEvent]()): MM[Seq[modeldb.TransformEventResponse]]
  
  def computeModelAncestry(modelId: Int): MM[modeldb.ModelAncestryResponse]
  
  def extractPipeline(modelId: Int): MM[modeldb.ExtractedPipelineResponse]

  /**
   * Used to close the underlying `Service`.
   * Not a user-defined API.
   */
  def asClosable: _root_.com.twitter.util.Closable = _root_.com.twitter.util.Closable.nop
}


object ModelDBService extends _root_.com.twitter.finagle.thrift.GeneratedThriftService { self =>

  val annotations: immutable$Map[String, String] = immutable$Map.empty

  val methods: immutable$Set[ThriftMethod] = immutable$Set(
    self.TestConnection,
    self.StoreDataFrame,
    self.PathForTransformer,
    self.StoreFitEvent,
    self.StoreMetricEvent,
    self.GetFilePath,
    self.StoreTransformEvent,
    self.StoreRandomSplitEvent,
    self.StorePipelineEvent,
    self.StoreCrossValidationEvent,
    self.StoreGridSearchCrossValidationEvent,
    self.StoreAnnotationEvent,
    self.StoreProjectEvent,
    self.StoreExperimentEvent,
    self.StoreExperimentRunEvent,
    self.StoreLinearModel,
    self.GetDataFrameAncestry,
    self.GetCommonAncestor,
    self.GetCommonAncestorForModels,
    self.GetTrainingRowsCount,
    self.GetTrainingRowsCounts,
    self.CompareHyperparameters,
    self.CompareFeatures,
    self.GroupByProblemType,
    self.SimilarModels,
    self.LinearModelFeatureImportances,
    self.CompareLinearModelFeatureImportances,
    self.IterationsUntilConvergence,
    self.RankModels,
    self.ConfidenceIntervals,
    self.ModelsWithFeatures,
    self.ModelsDerivedFromDataFrame,
    self.GetProjectIds,
    self.GetModelIds,
    self.UpdateProject,
    self.CreateOrUpdateScalarField,
    self.CreateVectorField,
    self.UpdateVectorField,
    self.AppendToVectorField,
    self.GetModel,
    self.GetRunsInExperiment,
    self.GetRunsAndExperimentsInProject,
    self.GetProjectOverviews,
    self.GetExperimentRunDetails,
    self.OriginalFeatures,
    self.StoreTreeModel,
    self.StorePipelineTransformEvent,
    self.ComputeModelAncestry,
    self.ExtractPipeline
  )

  trait ServicePerEndpoint
    extends ToThriftService
    with _root_.com.twitter.finagle.thrift.ThriftServiceIface.Filterable[ServicePerEndpoint] {
    def testConnection : _root_.com.twitter.finagle.Service[self.TestConnection.Args, self.TestConnection.SuccessType]
    def storeDataFrame : _root_.com.twitter.finagle.Service[self.StoreDataFrame.Args, self.StoreDataFrame.SuccessType]
    def pathForTransformer : _root_.com.twitter.finagle.Service[self.PathForTransformer.Args, self.PathForTransformer.SuccessType]
    def storeFitEvent : _root_.com.twitter.finagle.Service[self.StoreFitEvent.Args, self.StoreFitEvent.SuccessType]
    def storeMetricEvent : _root_.com.twitter.finagle.Service[self.StoreMetricEvent.Args, self.StoreMetricEvent.SuccessType]
    def getFilePath : _root_.com.twitter.finagle.Service[self.GetFilePath.Args, self.GetFilePath.SuccessType]
    def storeTransformEvent : _root_.com.twitter.finagle.Service[self.StoreTransformEvent.Args, self.StoreTransformEvent.SuccessType]
    def storeRandomSplitEvent : _root_.com.twitter.finagle.Service[self.StoreRandomSplitEvent.Args, self.StoreRandomSplitEvent.SuccessType]
    def storePipelineEvent : _root_.com.twitter.finagle.Service[self.StorePipelineEvent.Args, self.StorePipelineEvent.SuccessType]
    def storeCrossValidationEvent : _root_.com.twitter.finagle.Service[self.StoreCrossValidationEvent.Args, self.StoreCrossValidationEvent.SuccessType]
    def storeGridSearchCrossValidationEvent : _root_.com.twitter.finagle.Service[self.StoreGridSearchCrossValidationEvent.Args, self.StoreGridSearchCrossValidationEvent.SuccessType]
    def storeAnnotationEvent : _root_.com.twitter.finagle.Service[self.StoreAnnotationEvent.Args, self.StoreAnnotationEvent.SuccessType]
    def storeProjectEvent : _root_.com.twitter.finagle.Service[self.StoreProjectEvent.Args, self.StoreProjectEvent.SuccessType]
    def storeExperimentEvent : _root_.com.twitter.finagle.Service[self.StoreExperimentEvent.Args, self.StoreExperimentEvent.SuccessType]
    def storeExperimentRunEvent : _root_.com.twitter.finagle.Service[self.StoreExperimentRunEvent.Args, self.StoreExperimentRunEvent.SuccessType]
    def storeLinearModel : _root_.com.twitter.finagle.Service[self.StoreLinearModel.Args, self.StoreLinearModel.SuccessType]
    def getDataFrameAncestry : _root_.com.twitter.finagle.Service[self.GetDataFrameAncestry.Args, self.GetDataFrameAncestry.SuccessType]
    def getCommonAncestor : _root_.com.twitter.finagle.Service[self.GetCommonAncestor.Args, self.GetCommonAncestor.SuccessType]
    def getCommonAncestorForModels : _root_.com.twitter.finagle.Service[self.GetCommonAncestorForModels.Args, self.GetCommonAncestorForModels.SuccessType]
    def getTrainingRowsCount : _root_.com.twitter.finagle.Service[self.GetTrainingRowsCount.Args, self.GetTrainingRowsCount.SuccessType]
    def getTrainingRowsCounts : _root_.com.twitter.finagle.Service[self.GetTrainingRowsCounts.Args, self.GetTrainingRowsCounts.SuccessType]
    def compareHyperparameters : _root_.com.twitter.finagle.Service[self.CompareHyperparameters.Args, self.CompareHyperparameters.SuccessType]
    def compareFeatures : _root_.com.twitter.finagle.Service[self.CompareFeatures.Args, self.CompareFeatures.SuccessType]
    def groupByProblemType : _root_.com.twitter.finagle.Service[self.GroupByProblemType.Args, self.GroupByProblemType.SuccessType]
    def similarModels : _root_.com.twitter.finagle.Service[self.SimilarModels.Args, self.SimilarModels.SuccessType]
    def linearModelFeatureImportances : _root_.com.twitter.finagle.Service[self.LinearModelFeatureImportances.Args, self.LinearModelFeatureImportances.SuccessType]
    def compareLinearModelFeatureImportances : _root_.com.twitter.finagle.Service[self.CompareLinearModelFeatureImportances.Args, self.CompareLinearModelFeatureImportances.SuccessType]
    def iterationsUntilConvergence : _root_.com.twitter.finagle.Service[self.IterationsUntilConvergence.Args, self.IterationsUntilConvergence.SuccessType]
    def rankModels : _root_.com.twitter.finagle.Service[self.RankModels.Args, self.RankModels.SuccessType]
    def confidenceIntervals : _root_.com.twitter.finagle.Service[self.ConfidenceIntervals.Args, self.ConfidenceIntervals.SuccessType]
    def modelsWithFeatures : _root_.com.twitter.finagle.Service[self.ModelsWithFeatures.Args, self.ModelsWithFeatures.SuccessType]
    def modelsDerivedFromDataFrame : _root_.com.twitter.finagle.Service[self.ModelsDerivedFromDataFrame.Args, self.ModelsDerivedFromDataFrame.SuccessType]
    def getProjectIds : _root_.com.twitter.finagle.Service[self.GetProjectIds.Args, self.GetProjectIds.SuccessType]
    def getModelIds : _root_.com.twitter.finagle.Service[self.GetModelIds.Args, self.GetModelIds.SuccessType]
    def updateProject : _root_.com.twitter.finagle.Service[self.UpdateProject.Args, self.UpdateProject.SuccessType]
    def createOrUpdateScalarField : _root_.com.twitter.finagle.Service[self.CreateOrUpdateScalarField.Args, self.CreateOrUpdateScalarField.SuccessType]
    def createVectorField : _root_.com.twitter.finagle.Service[self.CreateVectorField.Args, self.CreateVectorField.SuccessType]
    def updateVectorField : _root_.com.twitter.finagle.Service[self.UpdateVectorField.Args, self.UpdateVectorField.SuccessType]
    def appendToVectorField : _root_.com.twitter.finagle.Service[self.AppendToVectorField.Args, self.AppendToVectorField.SuccessType]
    def getModel : _root_.com.twitter.finagle.Service[self.GetModel.Args, self.GetModel.SuccessType]
    def getRunsInExperiment : _root_.com.twitter.finagle.Service[self.GetRunsInExperiment.Args, self.GetRunsInExperiment.SuccessType]
    def getRunsAndExperimentsInProject : _root_.com.twitter.finagle.Service[self.GetRunsAndExperimentsInProject.Args, self.GetRunsAndExperimentsInProject.SuccessType]
    def getProjectOverviews : _root_.com.twitter.finagle.Service[self.GetProjectOverviews.Args, self.GetProjectOverviews.SuccessType]
    def getExperimentRunDetails : _root_.com.twitter.finagle.Service[self.GetExperimentRunDetails.Args, self.GetExperimentRunDetails.SuccessType]
    def originalFeatures : _root_.com.twitter.finagle.Service[self.OriginalFeatures.Args, self.OriginalFeatures.SuccessType]
    def storeTreeModel : _root_.com.twitter.finagle.Service[self.StoreTreeModel.Args, self.StoreTreeModel.SuccessType]
    def storePipelineTransformEvent : _root_.com.twitter.finagle.Service[self.StorePipelineTransformEvent.Args, self.StorePipelineTransformEvent.SuccessType]
    def computeModelAncestry : _root_.com.twitter.finagle.Service[self.ComputeModelAncestry.Args, self.ComputeModelAncestry.SuccessType]
    def extractPipeline : _root_.com.twitter.finagle.Service[self.ExtractPipeline.Args, self.ExtractPipeline.SuccessType]

    def withTestConnection(testConnection : _root_.com.twitter.finagle.Service[self.TestConnection.Args, self.TestConnection.SuccessType]): ServicePerEndpoint = this

    def withStoreDataFrame(storeDataFrame : _root_.com.twitter.finagle.Service[self.StoreDataFrame.Args, self.StoreDataFrame.SuccessType]): ServicePerEndpoint = this

    def withPathForTransformer(pathForTransformer : _root_.com.twitter.finagle.Service[self.PathForTransformer.Args, self.PathForTransformer.SuccessType]): ServicePerEndpoint = this

    def withStoreFitEvent(storeFitEvent : _root_.com.twitter.finagle.Service[self.StoreFitEvent.Args, self.StoreFitEvent.SuccessType]): ServicePerEndpoint = this

    def withStoreMetricEvent(storeMetricEvent : _root_.com.twitter.finagle.Service[self.StoreMetricEvent.Args, self.StoreMetricEvent.SuccessType]): ServicePerEndpoint = this

    def withGetFilePath(getFilePath : _root_.com.twitter.finagle.Service[self.GetFilePath.Args, self.GetFilePath.SuccessType]): ServicePerEndpoint = this

    def withStoreTransformEvent(storeTransformEvent : _root_.com.twitter.finagle.Service[self.StoreTransformEvent.Args, self.StoreTransformEvent.SuccessType]): ServicePerEndpoint = this

    def withStoreRandomSplitEvent(storeRandomSplitEvent : _root_.com.twitter.finagle.Service[self.StoreRandomSplitEvent.Args, self.StoreRandomSplitEvent.SuccessType]): ServicePerEndpoint = this

    def withStorePipelineEvent(storePipelineEvent : _root_.com.twitter.finagle.Service[self.StorePipelineEvent.Args, self.StorePipelineEvent.SuccessType]): ServicePerEndpoint = this

    def withStoreCrossValidationEvent(storeCrossValidationEvent : _root_.com.twitter.finagle.Service[self.StoreCrossValidationEvent.Args, self.StoreCrossValidationEvent.SuccessType]): ServicePerEndpoint = this

    def withStoreGridSearchCrossValidationEvent(storeGridSearchCrossValidationEvent : _root_.com.twitter.finagle.Service[self.StoreGridSearchCrossValidationEvent.Args, self.StoreGridSearchCrossValidationEvent.SuccessType]): ServicePerEndpoint = this

    def withStoreAnnotationEvent(storeAnnotationEvent : _root_.com.twitter.finagle.Service[self.StoreAnnotationEvent.Args, self.StoreAnnotationEvent.SuccessType]): ServicePerEndpoint = this

    def withStoreProjectEvent(storeProjectEvent : _root_.com.twitter.finagle.Service[self.StoreProjectEvent.Args, self.StoreProjectEvent.SuccessType]): ServicePerEndpoint = this

    def withStoreExperimentEvent(storeExperimentEvent : _root_.com.twitter.finagle.Service[self.StoreExperimentEvent.Args, self.StoreExperimentEvent.SuccessType]): ServicePerEndpoint = this

    def withStoreExperimentRunEvent(storeExperimentRunEvent : _root_.com.twitter.finagle.Service[self.StoreExperimentRunEvent.Args, self.StoreExperimentRunEvent.SuccessType]): ServicePerEndpoint = this

    def withStoreLinearModel(storeLinearModel : _root_.com.twitter.finagle.Service[self.StoreLinearModel.Args, self.StoreLinearModel.SuccessType]): ServicePerEndpoint = this

    def withGetDataFrameAncestry(getDataFrameAncestry : _root_.com.twitter.finagle.Service[self.GetDataFrameAncestry.Args, self.GetDataFrameAncestry.SuccessType]): ServicePerEndpoint = this

    def withGetCommonAncestor(getCommonAncestor : _root_.com.twitter.finagle.Service[self.GetCommonAncestor.Args, self.GetCommonAncestor.SuccessType]): ServicePerEndpoint = this

    def withGetCommonAncestorForModels(getCommonAncestorForModels : _root_.com.twitter.finagle.Service[self.GetCommonAncestorForModels.Args, self.GetCommonAncestorForModels.SuccessType]): ServicePerEndpoint = this

    def withGetTrainingRowsCount(getTrainingRowsCount : _root_.com.twitter.finagle.Service[self.GetTrainingRowsCount.Args, self.GetTrainingRowsCount.SuccessType]): ServicePerEndpoint = this

    def withGetTrainingRowsCounts(getTrainingRowsCounts : _root_.com.twitter.finagle.Service[self.GetTrainingRowsCounts.Args, self.GetTrainingRowsCounts.SuccessType]): ServicePerEndpoint = this

    def withCompareHyperparameters(compareHyperparameters : _root_.com.twitter.finagle.Service[self.CompareHyperparameters.Args, self.CompareHyperparameters.SuccessType]): ServicePerEndpoint = this

    def withCompareFeatures(compareFeatures : _root_.com.twitter.finagle.Service[self.CompareFeatures.Args, self.CompareFeatures.SuccessType]): ServicePerEndpoint = this

    def withGroupByProblemType(groupByProblemType : _root_.com.twitter.finagle.Service[self.GroupByProblemType.Args, self.GroupByProblemType.SuccessType]): ServicePerEndpoint = this

    def withSimilarModels(similarModels : _root_.com.twitter.finagle.Service[self.SimilarModels.Args, self.SimilarModels.SuccessType]): ServicePerEndpoint = this

    def withLinearModelFeatureImportances(linearModelFeatureImportances : _root_.com.twitter.finagle.Service[self.LinearModelFeatureImportances.Args, self.LinearModelFeatureImportances.SuccessType]): ServicePerEndpoint = this

    def withCompareLinearModelFeatureImportances(compareLinearModelFeatureImportances : _root_.com.twitter.finagle.Service[self.CompareLinearModelFeatureImportances.Args, self.CompareLinearModelFeatureImportances.SuccessType]): ServicePerEndpoint = this

    def withIterationsUntilConvergence(iterationsUntilConvergence : _root_.com.twitter.finagle.Service[self.IterationsUntilConvergence.Args, self.IterationsUntilConvergence.SuccessType]): ServicePerEndpoint = this

    def withRankModels(rankModels : _root_.com.twitter.finagle.Service[self.RankModels.Args, self.RankModels.SuccessType]): ServicePerEndpoint = this

    def withConfidenceIntervals(confidenceIntervals : _root_.com.twitter.finagle.Service[self.ConfidenceIntervals.Args, self.ConfidenceIntervals.SuccessType]): ServicePerEndpoint = this

    def withModelsWithFeatures(modelsWithFeatures : _root_.com.twitter.finagle.Service[self.ModelsWithFeatures.Args, self.ModelsWithFeatures.SuccessType]): ServicePerEndpoint = this

    def withModelsDerivedFromDataFrame(modelsDerivedFromDataFrame : _root_.com.twitter.finagle.Service[self.ModelsDerivedFromDataFrame.Args, self.ModelsDerivedFromDataFrame.SuccessType]): ServicePerEndpoint = this

    def withGetProjectIds(getProjectIds : _root_.com.twitter.finagle.Service[self.GetProjectIds.Args, self.GetProjectIds.SuccessType]): ServicePerEndpoint = this

    def withGetModelIds(getModelIds : _root_.com.twitter.finagle.Service[self.GetModelIds.Args, self.GetModelIds.SuccessType]): ServicePerEndpoint = this

    def withUpdateProject(updateProject : _root_.com.twitter.finagle.Service[self.UpdateProject.Args, self.UpdateProject.SuccessType]): ServicePerEndpoint = this

    def withCreateOrUpdateScalarField(createOrUpdateScalarField : _root_.com.twitter.finagle.Service[self.CreateOrUpdateScalarField.Args, self.CreateOrUpdateScalarField.SuccessType]): ServicePerEndpoint = this

    def withCreateVectorField(createVectorField : _root_.com.twitter.finagle.Service[self.CreateVectorField.Args, self.CreateVectorField.SuccessType]): ServicePerEndpoint = this

    def withUpdateVectorField(updateVectorField : _root_.com.twitter.finagle.Service[self.UpdateVectorField.Args, self.UpdateVectorField.SuccessType]): ServicePerEndpoint = this

    def withAppendToVectorField(appendToVectorField : _root_.com.twitter.finagle.Service[self.AppendToVectorField.Args, self.AppendToVectorField.SuccessType]): ServicePerEndpoint = this

    def withGetModel(getModel : _root_.com.twitter.finagle.Service[self.GetModel.Args, self.GetModel.SuccessType]): ServicePerEndpoint = this

    def withGetRunsInExperiment(getRunsInExperiment : _root_.com.twitter.finagle.Service[self.GetRunsInExperiment.Args, self.GetRunsInExperiment.SuccessType]): ServicePerEndpoint = this

    def withGetRunsAndExperimentsInProject(getRunsAndExperimentsInProject : _root_.com.twitter.finagle.Service[self.GetRunsAndExperimentsInProject.Args, self.GetRunsAndExperimentsInProject.SuccessType]): ServicePerEndpoint = this

    def withGetProjectOverviews(getProjectOverviews : _root_.com.twitter.finagle.Service[self.GetProjectOverviews.Args, self.GetProjectOverviews.SuccessType]): ServicePerEndpoint = this

    def withGetExperimentRunDetails(getExperimentRunDetails : _root_.com.twitter.finagle.Service[self.GetExperimentRunDetails.Args, self.GetExperimentRunDetails.SuccessType]): ServicePerEndpoint = this

    def withOriginalFeatures(originalFeatures : _root_.com.twitter.finagle.Service[self.OriginalFeatures.Args, self.OriginalFeatures.SuccessType]): ServicePerEndpoint = this

    def withStoreTreeModel(storeTreeModel : _root_.com.twitter.finagle.Service[self.StoreTreeModel.Args, self.StoreTreeModel.SuccessType]): ServicePerEndpoint = this

    def withStorePipelineTransformEvent(storePipelineTransformEvent : _root_.com.twitter.finagle.Service[self.StorePipelineTransformEvent.Args, self.StorePipelineTransformEvent.SuccessType]): ServicePerEndpoint = this

    def withComputeModelAncestry(computeModelAncestry : _root_.com.twitter.finagle.Service[self.ComputeModelAncestry.Args, self.ComputeModelAncestry.SuccessType]): ServicePerEndpoint = this

    def withExtractPipeline(extractPipeline : _root_.com.twitter.finagle.Service[self.ExtractPipeline.Args, self.ExtractPipeline.SuccessType]): ServicePerEndpoint = this

    /**
     * Prepends the given type-agnostic `Filter` to all of the `Services`
     * and returns a copy of the `ServicePerEndpoint` now including the filter.
     */
    def filtered(filter: _root_.com.twitter.finagle.Filter.TypeAgnostic): ServicePerEndpoint = this

    /**
     * Converts the `ServicePerEndpoint` to a `GeneratedThriftService`.
     * @see _root_.com.twitter.scrooge.ToThriftService
     */
    def toThriftService: _root_.com.twitter.finagle.thrift.ThriftService = MethodPerEndpoint(this)

    /**
     * Used to close the underlying `Service`.
     * Not a user-defined API.
     */
    def asClosable: _root_.com.twitter.util.Closable = _root_.com.twitter.util.Closable.nop
  }

  trait ReqRepServicePerEndpoint
    extends ToThriftService
    with _root_.com.twitter.finagle.thrift.service.Filterable[ReqRepServicePerEndpoint] {
    def testConnection : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.TestConnection.Args], _root_.com.twitter.scrooge.Response[self.TestConnection.SuccessType]]
    def storeDataFrame : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.StoreDataFrame.Args], _root_.com.twitter.scrooge.Response[self.StoreDataFrame.SuccessType]]
    def pathForTransformer : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.PathForTransformer.Args], _root_.com.twitter.scrooge.Response[self.PathForTransformer.SuccessType]]
    def storeFitEvent : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.StoreFitEvent.Args], _root_.com.twitter.scrooge.Response[self.StoreFitEvent.SuccessType]]
    def storeMetricEvent : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.StoreMetricEvent.Args], _root_.com.twitter.scrooge.Response[self.StoreMetricEvent.SuccessType]]
    def getFilePath : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.GetFilePath.Args], _root_.com.twitter.scrooge.Response[self.GetFilePath.SuccessType]]
    def storeTransformEvent : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.StoreTransformEvent.Args], _root_.com.twitter.scrooge.Response[self.StoreTransformEvent.SuccessType]]
    def storeRandomSplitEvent : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.StoreRandomSplitEvent.Args], _root_.com.twitter.scrooge.Response[self.StoreRandomSplitEvent.SuccessType]]
    def storePipelineEvent : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.StorePipelineEvent.Args], _root_.com.twitter.scrooge.Response[self.StorePipelineEvent.SuccessType]]
    def storeCrossValidationEvent : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.StoreCrossValidationEvent.Args], _root_.com.twitter.scrooge.Response[self.StoreCrossValidationEvent.SuccessType]]
    def storeGridSearchCrossValidationEvent : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.StoreGridSearchCrossValidationEvent.Args], _root_.com.twitter.scrooge.Response[self.StoreGridSearchCrossValidationEvent.SuccessType]]
    def storeAnnotationEvent : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.StoreAnnotationEvent.Args], _root_.com.twitter.scrooge.Response[self.StoreAnnotationEvent.SuccessType]]
    def storeProjectEvent : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.StoreProjectEvent.Args], _root_.com.twitter.scrooge.Response[self.StoreProjectEvent.SuccessType]]
    def storeExperimentEvent : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.StoreExperimentEvent.Args], _root_.com.twitter.scrooge.Response[self.StoreExperimentEvent.SuccessType]]
    def storeExperimentRunEvent : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.StoreExperimentRunEvent.Args], _root_.com.twitter.scrooge.Response[self.StoreExperimentRunEvent.SuccessType]]
    def storeLinearModel : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.StoreLinearModel.Args], _root_.com.twitter.scrooge.Response[self.StoreLinearModel.SuccessType]]
    def getDataFrameAncestry : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.GetDataFrameAncestry.Args], _root_.com.twitter.scrooge.Response[self.GetDataFrameAncestry.SuccessType]]
    def getCommonAncestor : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.GetCommonAncestor.Args], _root_.com.twitter.scrooge.Response[self.GetCommonAncestor.SuccessType]]
    def getCommonAncestorForModels : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.GetCommonAncestorForModels.Args], _root_.com.twitter.scrooge.Response[self.GetCommonAncestorForModels.SuccessType]]
    def getTrainingRowsCount : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.GetTrainingRowsCount.Args], _root_.com.twitter.scrooge.Response[self.GetTrainingRowsCount.SuccessType]]
    def getTrainingRowsCounts : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.GetTrainingRowsCounts.Args], _root_.com.twitter.scrooge.Response[self.GetTrainingRowsCounts.SuccessType]]
    def compareHyperparameters : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.CompareHyperparameters.Args], _root_.com.twitter.scrooge.Response[self.CompareHyperparameters.SuccessType]]
    def compareFeatures : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.CompareFeatures.Args], _root_.com.twitter.scrooge.Response[self.CompareFeatures.SuccessType]]
    def groupByProblemType : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.GroupByProblemType.Args], _root_.com.twitter.scrooge.Response[self.GroupByProblemType.SuccessType]]
    def similarModels : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.SimilarModels.Args], _root_.com.twitter.scrooge.Response[self.SimilarModels.SuccessType]]
    def linearModelFeatureImportances : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.LinearModelFeatureImportances.Args], _root_.com.twitter.scrooge.Response[self.LinearModelFeatureImportances.SuccessType]]
    def compareLinearModelFeatureImportances : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.CompareLinearModelFeatureImportances.Args], _root_.com.twitter.scrooge.Response[self.CompareLinearModelFeatureImportances.SuccessType]]
    def iterationsUntilConvergence : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.IterationsUntilConvergence.Args], _root_.com.twitter.scrooge.Response[self.IterationsUntilConvergence.SuccessType]]
    def rankModels : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.RankModels.Args], _root_.com.twitter.scrooge.Response[self.RankModels.SuccessType]]
    def confidenceIntervals : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.ConfidenceIntervals.Args], _root_.com.twitter.scrooge.Response[self.ConfidenceIntervals.SuccessType]]
    def modelsWithFeatures : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.ModelsWithFeatures.Args], _root_.com.twitter.scrooge.Response[self.ModelsWithFeatures.SuccessType]]
    def modelsDerivedFromDataFrame : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.ModelsDerivedFromDataFrame.Args], _root_.com.twitter.scrooge.Response[self.ModelsDerivedFromDataFrame.SuccessType]]
    def getProjectIds : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.GetProjectIds.Args], _root_.com.twitter.scrooge.Response[self.GetProjectIds.SuccessType]]
    def getModelIds : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.GetModelIds.Args], _root_.com.twitter.scrooge.Response[self.GetModelIds.SuccessType]]
    def updateProject : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.UpdateProject.Args], _root_.com.twitter.scrooge.Response[self.UpdateProject.SuccessType]]
    def createOrUpdateScalarField : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.CreateOrUpdateScalarField.Args], _root_.com.twitter.scrooge.Response[self.CreateOrUpdateScalarField.SuccessType]]
    def createVectorField : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.CreateVectorField.Args], _root_.com.twitter.scrooge.Response[self.CreateVectorField.SuccessType]]
    def updateVectorField : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.UpdateVectorField.Args], _root_.com.twitter.scrooge.Response[self.UpdateVectorField.SuccessType]]
    def appendToVectorField : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.AppendToVectorField.Args], _root_.com.twitter.scrooge.Response[self.AppendToVectorField.SuccessType]]
    def getModel : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.GetModel.Args], _root_.com.twitter.scrooge.Response[self.GetModel.SuccessType]]
    def getRunsInExperiment : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.GetRunsInExperiment.Args], _root_.com.twitter.scrooge.Response[self.GetRunsInExperiment.SuccessType]]
    def getRunsAndExperimentsInProject : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.GetRunsAndExperimentsInProject.Args], _root_.com.twitter.scrooge.Response[self.GetRunsAndExperimentsInProject.SuccessType]]
    def getProjectOverviews : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.GetProjectOverviews.Args], _root_.com.twitter.scrooge.Response[self.GetProjectOverviews.SuccessType]]
    def getExperimentRunDetails : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.GetExperimentRunDetails.Args], _root_.com.twitter.scrooge.Response[self.GetExperimentRunDetails.SuccessType]]
    def originalFeatures : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.OriginalFeatures.Args], _root_.com.twitter.scrooge.Response[self.OriginalFeatures.SuccessType]]
    def storeTreeModel : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.StoreTreeModel.Args], _root_.com.twitter.scrooge.Response[self.StoreTreeModel.SuccessType]]
    def storePipelineTransformEvent : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.StorePipelineTransformEvent.Args], _root_.com.twitter.scrooge.Response[self.StorePipelineTransformEvent.SuccessType]]
    def computeModelAncestry : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.ComputeModelAncestry.Args], _root_.com.twitter.scrooge.Response[self.ComputeModelAncestry.SuccessType]]
    def extractPipeline : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.ExtractPipeline.Args], _root_.com.twitter.scrooge.Response[self.ExtractPipeline.SuccessType]]

    def withTestConnection(testConnection : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.TestConnection.Args], _root_.com.twitter.scrooge.Response[self.TestConnection.SuccessType]]): ReqRepServicePerEndpoint = this

    def withStoreDataFrame(storeDataFrame : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.StoreDataFrame.Args], _root_.com.twitter.scrooge.Response[self.StoreDataFrame.SuccessType]]): ReqRepServicePerEndpoint = this

    def withPathForTransformer(pathForTransformer : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.PathForTransformer.Args], _root_.com.twitter.scrooge.Response[self.PathForTransformer.SuccessType]]): ReqRepServicePerEndpoint = this

    def withStoreFitEvent(storeFitEvent : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.StoreFitEvent.Args], _root_.com.twitter.scrooge.Response[self.StoreFitEvent.SuccessType]]): ReqRepServicePerEndpoint = this

    def withStoreMetricEvent(storeMetricEvent : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.StoreMetricEvent.Args], _root_.com.twitter.scrooge.Response[self.StoreMetricEvent.SuccessType]]): ReqRepServicePerEndpoint = this

    def withGetFilePath(getFilePath : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.GetFilePath.Args], _root_.com.twitter.scrooge.Response[self.GetFilePath.SuccessType]]): ReqRepServicePerEndpoint = this

    def withStoreTransformEvent(storeTransformEvent : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.StoreTransformEvent.Args], _root_.com.twitter.scrooge.Response[self.StoreTransformEvent.SuccessType]]): ReqRepServicePerEndpoint = this

    def withStoreRandomSplitEvent(storeRandomSplitEvent : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.StoreRandomSplitEvent.Args], _root_.com.twitter.scrooge.Response[self.StoreRandomSplitEvent.SuccessType]]): ReqRepServicePerEndpoint = this

    def withStorePipelineEvent(storePipelineEvent : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.StorePipelineEvent.Args], _root_.com.twitter.scrooge.Response[self.StorePipelineEvent.SuccessType]]): ReqRepServicePerEndpoint = this

    def withStoreCrossValidationEvent(storeCrossValidationEvent : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.StoreCrossValidationEvent.Args], _root_.com.twitter.scrooge.Response[self.StoreCrossValidationEvent.SuccessType]]): ReqRepServicePerEndpoint = this

    def withStoreGridSearchCrossValidationEvent(storeGridSearchCrossValidationEvent : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.StoreGridSearchCrossValidationEvent.Args], _root_.com.twitter.scrooge.Response[self.StoreGridSearchCrossValidationEvent.SuccessType]]): ReqRepServicePerEndpoint = this

    def withStoreAnnotationEvent(storeAnnotationEvent : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.StoreAnnotationEvent.Args], _root_.com.twitter.scrooge.Response[self.StoreAnnotationEvent.SuccessType]]): ReqRepServicePerEndpoint = this

    def withStoreProjectEvent(storeProjectEvent : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.StoreProjectEvent.Args], _root_.com.twitter.scrooge.Response[self.StoreProjectEvent.SuccessType]]): ReqRepServicePerEndpoint = this

    def withStoreExperimentEvent(storeExperimentEvent : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.StoreExperimentEvent.Args], _root_.com.twitter.scrooge.Response[self.StoreExperimentEvent.SuccessType]]): ReqRepServicePerEndpoint = this

    def withStoreExperimentRunEvent(storeExperimentRunEvent : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.StoreExperimentRunEvent.Args], _root_.com.twitter.scrooge.Response[self.StoreExperimentRunEvent.SuccessType]]): ReqRepServicePerEndpoint = this

    def withStoreLinearModel(storeLinearModel : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.StoreLinearModel.Args], _root_.com.twitter.scrooge.Response[self.StoreLinearModel.SuccessType]]): ReqRepServicePerEndpoint = this

    def withGetDataFrameAncestry(getDataFrameAncestry : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.GetDataFrameAncestry.Args], _root_.com.twitter.scrooge.Response[self.GetDataFrameAncestry.SuccessType]]): ReqRepServicePerEndpoint = this

    def withGetCommonAncestor(getCommonAncestor : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.GetCommonAncestor.Args], _root_.com.twitter.scrooge.Response[self.GetCommonAncestor.SuccessType]]): ReqRepServicePerEndpoint = this

    def withGetCommonAncestorForModels(getCommonAncestorForModels : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.GetCommonAncestorForModels.Args], _root_.com.twitter.scrooge.Response[self.GetCommonAncestorForModels.SuccessType]]): ReqRepServicePerEndpoint = this

    def withGetTrainingRowsCount(getTrainingRowsCount : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.GetTrainingRowsCount.Args], _root_.com.twitter.scrooge.Response[self.GetTrainingRowsCount.SuccessType]]): ReqRepServicePerEndpoint = this

    def withGetTrainingRowsCounts(getTrainingRowsCounts : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.GetTrainingRowsCounts.Args], _root_.com.twitter.scrooge.Response[self.GetTrainingRowsCounts.SuccessType]]): ReqRepServicePerEndpoint = this

    def withCompareHyperparameters(compareHyperparameters : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.CompareHyperparameters.Args], _root_.com.twitter.scrooge.Response[self.CompareHyperparameters.SuccessType]]): ReqRepServicePerEndpoint = this

    def withCompareFeatures(compareFeatures : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.CompareFeatures.Args], _root_.com.twitter.scrooge.Response[self.CompareFeatures.SuccessType]]): ReqRepServicePerEndpoint = this

    def withGroupByProblemType(groupByProblemType : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.GroupByProblemType.Args], _root_.com.twitter.scrooge.Response[self.GroupByProblemType.SuccessType]]): ReqRepServicePerEndpoint = this

    def withSimilarModels(similarModels : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.SimilarModels.Args], _root_.com.twitter.scrooge.Response[self.SimilarModels.SuccessType]]): ReqRepServicePerEndpoint = this

    def withLinearModelFeatureImportances(linearModelFeatureImportances : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.LinearModelFeatureImportances.Args], _root_.com.twitter.scrooge.Response[self.LinearModelFeatureImportances.SuccessType]]): ReqRepServicePerEndpoint = this

    def withCompareLinearModelFeatureImportances(compareLinearModelFeatureImportances : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.CompareLinearModelFeatureImportances.Args], _root_.com.twitter.scrooge.Response[self.CompareLinearModelFeatureImportances.SuccessType]]): ReqRepServicePerEndpoint = this

    def withIterationsUntilConvergence(iterationsUntilConvergence : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.IterationsUntilConvergence.Args], _root_.com.twitter.scrooge.Response[self.IterationsUntilConvergence.SuccessType]]): ReqRepServicePerEndpoint = this

    def withRankModels(rankModels : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.RankModels.Args], _root_.com.twitter.scrooge.Response[self.RankModels.SuccessType]]): ReqRepServicePerEndpoint = this

    def withConfidenceIntervals(confidenceIntervals : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.ConfidenceIntervals.Args], _root_.com.twitter.scrooge.Response[self.ConfidenceIntervals.SuccessType]]): ReqRepServicePerEndpoint = this

    def withModelsWithFeatures(modelsWithFeatures : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.ModelsWithFeatures.Args], _root_.com.twitter.scrooge.Response[self.ModelsWithFeatures.SuccessType]]): ReqRepServicePerEndpoint = this

    def withModelsDerivedFromDataFrame(modelsDerivedFromDataFrame : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.ModelsDerivedFromDataFrame.Args], _root_.com.twitter.scrooge.Response[self.ModelsDerivedFromDataFrame.SuccessType]]): ReqRepServicePerEndpoint = this

    def withGetProjectIds(getProjectIds : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.GetProjectIds.Args], _root_.com.twitter.scrooge.Response[self.GetProjectIds.SuccessType]]): ReqRepServicePerEndpoint = this

    def withGetModelIds(getModelIds : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.GetModelIds.Args], _root_.com.twitter.scrooge.Response[self.GetModelIds.SuccessType]]): ReqRepServicePerEndpoint = this

    def withUpdateProject(updateProject : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.UpdateProject.Args], _root_.com.twitter.scrooge.Response[self.UpdateProject.SuccessType]]): ReqRepServicePerEndpoint = this

    def withCreateOrUpdateScalarField(createOrUpdateScalarField : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.CreateOrUpdateScalarField.Args], _root_.com.twitter.scrooge.Response[self.CreateOrUpdateScalarField.SuccessType]]): ReqRepServicePerEndpoint = this

    def withCreateVectorField(createVectorField : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.CreateVectorField.Args], _root_.com.twitter.scrooge.Response[self.CreateVectorField.SuccessType]]): ReqRepServicePerEndpoint = this

    def withUpdateVectorField(updateVectorField : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.UpdateVectorField.Args], _root_.com.twitter.scrooge.Response[self.UpdateVectorField.SuccessType]]): ReqRepServicePerEndpoint = this

    def withAppendToVectorField(appendToVectorField : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.AppendToVectorField.Args], _root_.com.twitter.scrooge.Response[self.AppendToVectorField.SuccessType]]): ReqRepServicePerEndpoint = this

    def withGetModel(getModel : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.GetModel.Args], _root_.com.twitter.scrooge.Response[self.GetModel.SuccessType]]): ReqRepServicePerEndpoint = this

    def withGetRunsInExperiment(getRunsInExperiment : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.GetRunsInExperiment.Args], _root_.com.twitter.scrooge.Response[self.GetRunsInExperiment.SuccessType]]): ReqRepServicePerEndpoint = this

    def withGetRunsAndExperimentsInProject(getRunsAndExperimentsInProject : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.GetRunsAndExperimentsInProject.Args], _root_.com.twitter.scrooge.Response[self.GetRunsAndExperimentsInProject.SuccessType]]): ReqRepServicePerEndpoint = this

    def withGetProjectOverviews(getProjectOverviews : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.GetProjectOverviews.Args], _root_.com.twitter.scrooge.Response[self.GetProjectOverviews.SuccessType]]): ReqRepServicePerEndpoint = this

    def withGetExperimentRunDetails(getExperimentRunDetails : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.GetExperimentRunDetails.Args], _root_.com.twitter.scrooge.Response[self.GetExperimentRunDetails.SuccessType]]): ReqRepServicePerEndpoint = this

    def withOriginalFeatures(originalFeatures : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.OriginalFeatures.Args], _root_.com.twitter.scrooge.Response[self.OriginalFeatures.SuccessType]]): ReqRepServicePerEndpoint = this

    def withStoreTreeModel(storeTreeModel : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.StoreTreeModel.Args], _root_.com.twitter.scrooge.Response[self.StoreTreeModel.SuccessType]]): ReqRepServicePerEndpoint = this

    def withStorePipelineTransformEvent(storePipelineTransformEvent : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.StorePipelineTransformEvent.Args], _root_.com.twitter.scrooge.Response[self.StorePipelineTransformEvent.SuccessType]]): ReqRepServicePerEndpoint = this

    def withComputeModelAncestry(computeModelAncestry : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.ComputeModelAncestry.Args], _root_.com.twitter.scrooge.Response[self.ComputeModelAncestry.SuccessType]]): ReqRepServicePerEndpoint = this

    def withExtractPipeline(extractPipeline : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.ExtractPipeline.Args], _root_.com.twitter.scrooge.Response[self.ExtractPipeline.SuccessType]]): ReqRepServicePerEndpoint = this

    /**
     * Prepends the given type-agnostic `Filter` to all of the `Services`
     * and returns a copy of the `ServicePerEndpoint` now including the filter.
     */
    def filtered(filter: com.twitter.finagle.Filter.TypeAgnostic): ReqRepServicePerEndpoint = this

    /**
     * Converts the `ServicePerEndpoint` to a `GeneratedThriftService`.
     * @see _root_.com.twitter.scrooge.ToThriftService
     */
    def toThriftService: _root_.com.twitter.finagle.thrift.ThriftService = ReqRepMethodPerEndpoint(this)

    /**
     * Used to close the underlying `Service`.
     * Not a user-defined API.
     */
    def asClosable: _root_.com.twitter.util.Closable = _root_.com.twitter.util.Closable.nop
  }

  @deprecated("Use ServicePerEndpoint", "2017-11-07")
  trait BaseServiceIface extends ToThriftService {
    def testConnection : com.twitter.finagle.Service[self.TestConnection.Args, self.TestConnection.SuccessType]
    def storeDataFrame : com.twitter.finagle.Service[self.StoreDataFrame.Args, self.StoreDataFrame.SuccessType]
    def pathForTransformer : com.twitter.finagle.Service[self.PathForTransformer.Args, self.PathForTransformer.SuccessType]
    def storeFitEvent : com.twitter.finagle.Service[self.StoreFitEvent.Args, self.StoreFitEvent.SuccessType]
    def storeMetricEvent : com.twitter.finagle.Service[self.StoreMetricEvent.Args, self.StoreMetricEvent.SuccessType]
    def getFilePath : com.twitter.finagle.Service[self.GetFilePath.Args, self.GetFilePath.SuccessType]
    def storeTransformEvent : com.twitter.finagle.Service[self.StoreTransformEvent.Args, self.StoreTransformEvent.SuccessType]
    def storeRandomSplitEvent : com.twitter.finagle.Service[self.StoreRandomSplitEvent.Args, self.StoreRandomSplitEvent.SuccessType]
    def storePipelineEvent : com.twitter.finagle.Service[self.StorePipelineEvent.Args, self.StorePipelineEvent.SuccessType]
    def storeCrossValidationEvent : com.twitter.finagle.Service[self.StoreCrossValidationEvent.Args, self.StoreCrossValidationEvent.SuccessType]
    def storeGridSearchCrossValidationEvent : com.twitter.finagle.Service[self.StoreGridSearchCrossValidationEvent.Args, self.StoreGridSearchCrossValidationEvent.SuccessType]
    def storeAnnotationEvent : com.twitter.finagle.Service[self.StoreAnnotationEvent.Args, self.StoreAnnotationEvent.SuccessType]
    def storeProjectEvent : com.twitter.finagle.Service[self.StoreProjectEvent.Args, self.StoreProjectEvent.SuccessType]
    def storeExperimentEvent : com.twitter.finagle.Service[self.StoreExperimentEvent.Args, self.StoreExperimentEvent.SuccessType]
    def storeExperimentRunEvent : com.twitter.finagle.Service[self.StoreExperimentRunEvent.Args, self.StoreExperimentRunEvent.SuccessType]
    def storeLinearModel : com.twitter.finagle.Service[self.StoreLinearModel.Args, self.StoreLinearModel.SuccessType]
    def getDataFrameAncestry : com.twitter.finagle.Service[self.GetDataFrameAncestry.Args, self.GetDataFrameAncestry.SuccessType]
    def getCommonAncestor : com.twitter.finagle.Service[self.GetCommonAncestor.Args, self.GetCommonAncestor.SuccessType]
    def getCommonAncestorForModels : com.twitter.finagle.Service[self.GetCommonAncestorForModels.Args, self.GetCommonAncestorForModels.SuccessType]
    def getTrainingRowsCount : com.twitter.finagle.Service[self.GetTrainingRowsCount.Args, self.GetTrainingRowsCount.SuccessType]
    def getTrainingRowsCounts : com.twitter.finagle.Service[self.GetTrainingRowsCounts.Args, self.GetTrainingRowsCounts.SuccessType]
    def compareHyperparameters : com.twitter.finagle.Service[self.CompareHyperparameters.Args, self.CompareHyperparameters.SuccessType]
    def compareFeatures : com.twitter.finagle.Service[self.CompareFeatures.Args, self.CompareFeatures.SuccessType]
    def groupByProblemType : com.twitter.finagle.Service[self.GroupByProblemType.Args, self.GroupByProblemType.SuccessType]
    def similarModels : com.twitter.finagle.Service[self.SimilarModels.Args, self.SimilarModels.SuccessType]
    def linearModelFeatureImportances : com.twitter.finagle.Service[self.LinearModelFeatureImportances.Args, self.LinearModelFeatureImportances.SuccessType]
    def compareLinearModelFeatureImportances : com.twitter.finagle.Service[self.CompareLinearModelFeatureImportances.Args, self.CompareLinearModelFeatureImportances.SuccessType]
    def iterationsUntilConvergence : com.twitter.finagle.Service[self.IterationsUntilConvergence.Args, self.IterationsUntilConvergence.SuccessType]
    def rankModels : com.twitter.finagle.Service[self.RankModels.Args, self.RankModels.SuccessType]
    def confidenceIntervals : com.twitter.finagle.Service[self.ConfidenceIntervals.Args, self.ConfidenceIntervals.SuccessType]
    def modelsWithFeatures : com.twitter.finagle.Service[self.ModelsWithFeatures.Args, self.ModelsWithFeatures.SuccessType]
    def modelsDerivedFromDataFrame : com.twitter.finagle.Service[self.ModelsDerivedFromDataFrame.Args, self.ModelsDerivedFromDataFrame.SuccessType]
    def getProjectIds : com.twitter.finagle.Service[self.GetProjectIds.Args, self.GetProjectIds.SuccessType]
    def getModelIds : com.twitter.finagle.Service[self.GetModelIds.Args, self.GetModelIds.SuccessType]
    def updateProject : com.twitter.finagle.Service[self.UpdateProject.Args, self.UpdateProject.SuccessType]
    def createOrUpdateScalarField : com.twitter.finagle.Service[self.CreateOrUpdateScalarField.Args, self.CreateOrUpdateScalarField.SuccessType]
    def createVectorField : com.twitter.finagle.Service[self.CreateVectorField.Args, self.CreateVectorField.SuccessType]
    def updateVectorField : com.twitter.finagle.Service[self.UpdateVectorField.Args, self.UpdateVectorField.SuccessType]
    def appendToVectorField : com.twitter.finagle.Service[self.AppendToVectorField.Args, self.AppendToVectorField.SuccessType]
    def getModel : com.twitter.finagle.Service[self.GetModel.Args, self.GetModel.SuccessType]
    def getRunsInExperiment : com.twitter.finagle.Service[self.GetRunsInExperiment.Args, self.GetRunsInExperiment.SuccessType]
    def getRunsAndExperimentsInProject : com.twitter.finagle.Service[self.GetRunsAndExperimentsInProject.Args, self.GetRunsAndExperimentsInProject.SuccessType]
    def getProjectOverviews : com.twitter.finagle.Service[self.GetProjectOverviews.Args, self.GetProjectOverviews.SuccessType]
    def getExperimentRunDetails : com.twitter.finagle.Service[self.GetExperimentRunDetails.Args, self.GetExperimentRunDetails.SuccessType]
    def originalFeatures : com.twitter.finagle.Service[self.OriginalFeatures.Args, self.OriginalFeatures.SuccessType]
    def storeTreeModel : com.twitter.finagle.Service[self.StoreTreeModel.Args, self.StoreTreeModel.SuccessType]
    def storePipelineTransformEvent : com.twitter.finagle.Service[self.StorePipelineTransformEvent.Args, self.StorePipelineTransformEvent.SuccessType]
    def computeModelAncestry : com.twitter.finagle.Service[self.ComputeModelAncestry.Args, self.ComputeModelAncestry.SuccessType]
    def extractPipeline : com.twitter.finagle.Service[self.ExtractPipeline.Args, self.ExtractPipeline.SuccessType]

    def toThriftService: _root_.com.twitter.finagle.thrift.ThriftService = new MethodIface(this)
  }

  object ServicePerEndpoint {

    def apply(
      testConnection : _root_.com.twitter.finagle.Service[self.TestConnection.Args, self.TestConnection.SuccessType],
      storeDataFrame : _root_.com.twitter.finagle.Service[self.StoreDataFrame.Args, self.StoreDataFrame.SuccessType],
      pathForTransformer : _root_.com.twitter.finagle.Service[self.PathForTransformer.Args, self.PathForTransformer.SuccessType],
      storeFitEvent : _root_.com.twitter.finagle.Service[self.StoreFitEvent.Args, self.StoreFitEvent.SuccessType],
      storeMetricEvent : _root_.com.twitter.finagle.Service[self.StoreMetricEvent.Args, self.StoreMetricEvent.SuccessType],
      getFilePath : _root_.com.twitter.finagle.Service[self.GetFilePath.Args, self.GetFilePath.SuccessType],
      storeTransformEvent : _root_.com.twitter.finagle.Service[self.StoreTransformEvent.Args, self.StoreTransformEvent.SuccessType],
      storeRandomSplitEvent : _root_.com.twitter.finagle.Service[self.StoreRandomSplitEvent.Args, self.StoreRandomSplitEvent.SuccessType],
      storePipelineEvent : _root_.com.twitter.finagle.Service[self.StorePipelineEvent.Args, self.StorePipelineEvent.SuccessType],
      storeCrossValidationEvent : _root_.com.twitter.finagle.Service[self.StoreCrossValidationEvent.Args, self.StoreCrossValidationEvent.SuccessType],
      storeGridSearchCrossValidationEvent : _root_.com.twitter.finagle.Service[self.StoreGridSearchCrossValidationEvent.Args, self.StoreGridSearchCrossValidationEvent.SuccessType],
      storeAnnotationEvent : _root_.com.twitter.finagle.Service[self.StoreAnnotationEvent.Args, self.StoreAnnotationEvent.SuccessType],
      storeProjectEvent : _root_.com.twitter.finagle.Service[self.StoreProjectEvent.Args, self.StoreProjectEvent.SuccessType],
      storeExperimentEvent : _root_.com.twitter.finagle.Service[self.StoreExperimentEvent.Args, self.StoreExperimentEvent.SuccessType],
      storeExperimentRunEvent : _root_.com.twitter.finagle.Service[self.StoreExperimentRunEvent.Args, self.StoreExperimentRunEvent.SuccessType],
      storeLinearModel : _root_.com.twitter.finagle.Service[self.StoreLinearModel.Args, self.StoreLinearModel.SuccessType],
      getDataFrameAncestry : _root_.com.twitter.finagle.Service[self.GetDataFrameAncestry.Args, self.GetDataFrameAncestry.SuccessType],
      getCommonAncestor : _root_.com.twitter.finagle.Service[self.GetCommonAncestor.Args, self.GetCommonAncestor.SuccessType],
      getCommonAncestorForModels : _root_.com.twitter.finagle.Service[self.GetCommonAncestorForModels.Args, self.GetCommonAncestorForModels.SuccessType],
      getTrainingRowsCount : _root_.com.twitter.finagle.Service[self.GetTrainingRowsCount.Args, self.GetTrainingRowsCount.SuccessType],
      getTrainingRowsCounts : _root_.com.twitter.finagle.Service[self.GetTrainingRowsCounts.Args, self.GetTrainingRowsCounts.SuccessType],
      compareHyperparameters : _root_.com.twitter.finagle.Service[self.CompareHyperparameters.Args, self.CompareHyperparameters.SuccessType],
      compareFeatures : _root_.com.twitter.finagle.Service[self.CompareFeatures.Args, self.CompareFeatures.SuccessType],
      groupByProblemType : _root_.com.twitter.finagle.Service[self.GroupByProblemType.Args, self.GroupByProblemType.SuccessType],
      similarModels : _root_.com.twitter.finagle.Service[self.SimilarModels.Args, self.SimilarModels.SuccessType],
      linearModelFeatureImportances : _root_.com.twitter.finagle.Service[self.LinearModelFeatureImportances.Args, self.LinearModelFeatureImportances.SuccessType],
      compareLinearModelFeatureImportances : _root_.com.twitter.finagle.Service[self.CompareLinearModelFeatureImportances.Args, self.CompareLinearModelFeatureImportances.SuccessType],
      iterationsUntilConvergence : _root_.com.twitter.finagle.Service[self.IterationsUntilConvergence.Args, self.IterationsUntilConvergence.SuccessType],
      rankModels : _root_.com.twitter.finagle.Service[self.RankModels.Args, self.RankModels.SuccessType],
      confidenceIntervals : _root_.com.twitter.finagle.Service[self.ConfidenceIntervals.Args, self.ConfidenceIntervals.SuccessType],
      modelsWithFeatures : _root_.com.twitter.finagle.Service[self.ModelsWithFeatures.Args, self.ModelsWithFeatures.SuccessType],
      modelsDerivedFromDataFrame : _root_.com.twitter.finagle.Service[self.ModelsDerivedFromDataFrame.Args, self.ModelsDerivedFromDataFrame.SuccessType],
      getProjectIds : _root_.com.twitter.finagle.Service[self.GetProjectIds.Args, self.GetProjectIds.SuccessType],
      getModelIds : _root_.com.twitter.finagle.Service[self.GetModelIds.Args, self.GetModelIds.SuccessType],
      updateProject : _root_.com.twitter.finagle.Service[self.UpdateProject.Args, self.UpdateProject.SuccessType],
      createOrUpdateScalarField : _root_.com.twitter.finagle.Service[self.CreateOrUpdateScalarField.Args, self.CreateOrUpdateScalarField.SuccessType],
      createVectorField : _root_.com.twitter.finagle.Service[self.CreateVectorField.Args, self.CreateVectorField.SuccessType],
      updateVectorField : _root_.com.twitter.finagle.Service[self.UpdateVectorField.Args, self.UpdateVectorField.SuccessType],
      appendToVectorField : _root_.com.twitter.finagle.Service[self.AppendToVectorField.Args, self.AppendToVectorField.SuccessType],
      getModel : _root_.com.twitter.finagle.Service[self.GetModel.Args, self.GetModel.SuccessType],
      getRunsInExperiment : _root_.com.twitter.finagle.Service[self.GetRunsInExperiment.Args, self.GetRunsInExperiment.SuccessType],
      getRunsAndExperimentsInProject : _root_.com.twitter.finagle.Service[self.GetRunsAndExperimentsInProject.Args, self.GetRunsAndExperimentsInProject.SuccessType],
      getProjectOverviews : _root_.com.twitter.finagle.Service[self.GetProjectOverviews.Args, self.GetProjectOverviews.SuccessType],
      getExperimentRunDetails : _root_.com.twitter.finagle.Service[self.GetExperimentRunDetails.Args, self.GetExperimentRunDetails.SuccessType],
      originalFeatures : _root_.com.twitter.finagle.Service[self.OriginalFeatures.Args, self.OriginalFeatures.SuccessType],
      storeTreeModel : _root_.com.twitter.finagle.Service[self.StoreTreeModel.Args, self.StoreTreeModel.SuccessType],
      storePipelineTransformEvent : _root_.com.twitter.finagle.Service[self.StorePipelineTransformEvent.Args, self.StorePipelineTransformEvent.SuccessType],
      computeModelAncestry : _root_.com.twitter.finagle.Service[self.ComputeModelAncestry.Args, self.ComputeModelAncestry.SuccessType],
      extractPipeline : _root_.com.twitter.finagle.Service[self.ExtractPipeline.Args, self.ExtractPipeline.SuccessType]
    ): ServicePerEndpoint = new ServicePerEndpointImpl(testConnection, storeDataFrame, pathForTransformer, storeFitEvent, storeMetricEvent, getFilePath, storeTransformEvent, storeRandomSplitEvent, storePipelineEvent, storeCrossValidationEvent, storeGridSearchCrossValidationEvent, storeAnnotationEvent, storeProjectEvent, storeExperimentEvent, storeExperimentRunEvent, storeLinearModel, getDataFrameAncestry, getCommonAncestor, getCommonAncestorForModels, getTrainingRowsCount, getTrainingRowsCounts, compareHyperparameters, compareFeatures, groupByProblemType, similarModels, linearModelFeatureImportances, compareLinearModelFeatureImportances, iterationsUntilConvergence, rankModels, confidenceIntervals, modelsWithFeatures, modelsDerivedFromDataFrame, getProjectIds, getModelIds, updateProject, createOrUpdateScalarField, createVectorField, updateVectorField, appendToVectorField, getModel, getRunsInExperiment, getRunsAndExperimentsInProject, getProjectOverviews, getExperimentRunDetails, originalFeatures, storeTreeModel, storePipelineTransformEvent, computeModelAncestry, extractPipeline)

    private final class ServicePerEndpointImpl(
      override val testConnection : _root_.com.twitter.finagle.Service[self.TestConnection.Args, self.TestConnection.SuccessType],
      override val storeDataFrame : _root_.com.twitter.finagle.Service[self.StoreDataFrame.Args, self.StoreDataFrame.SuccessType],
      override val pathForTransformer : _root_.com.twitter.finagle.Service[self.PathForTransformer.Args, self.PathForTransformer.SuccessType],
      override val storeFitEvent : _root_.com.twitter.finagle.Service[self.StoreFitEvent.Args, self.StoreFitEvent.SuccessType],
      override val storeMetricEvent : _root_.com.twitter.finagle.Service[self.StoreMetricEvent.Args, self.StoreMetricEvent.SuccessType],
      override val getFilePath : _root_.com.twitter.finagle.Service[self.GetFilePath.Args, self.GetFilePath.SuccessType],
      override val storeTransformEvent : _root_.com.twitter.finagle.Service[self.StoreTransformEvent.Args, self.StoreTransformEvent.SuccessType],
      override val storeRandomSplitEvent : _root_.com.twitter.finagle.Service[self.StoreRandomSplitEvent.Args, self.StoreRandomSplitEvent.SuccessType],
      override val storePipelineEvent : _root_.com.twitter.finagle.Service[self.StorePipelineEvent.Args, self.StorePipelineEvent.SuccessType],
      override val storeCrossValidationEvent : _root_.com.twitter.finagle.Service[self.StoreCrossValidationEvent.Args, self.StoreCrossValidationEvent.SuccessType],
      override val storeGridSearchCrossValidationEvent : _root_.com.twitter.finagle.Service[self.StoreGridSearchCrossValidationEvent.Args, self.StoreGridSearchCrossValidationEvent.SuccessType],
      override val storeAnnotationEvent : _root_.com.twitter.finagle.Service[self.StoreAnnotationEvent.Args, self.StoreAnnotationEvent.SuccessType],
      override val storeProjectEvent : _root_.com.twitter.finagle.Service[self.StoreProjectEvent.Args, self.StoreProjectEvent.SuccessType],
      override val storeExperimentEvent : _root_.com.twitter.finagle.Service[self.StoreExperimentEvent.Args, self.StoreExperimentEvent.SuccessType],
      override val storeExperimentRunEvent : _root_.com.twitter.finagle.Service[self.StoreExperimentRunEvent.Args, self.StoreExperimentRunEvent.SuccessType],
      override val storeLinearModel : _root_.com.twitter.finagle.Service[self.StoreLinearModel.Args, self.StoreLinearModel.SuccessType],
      override val getDataFrameAncestry : _root_.com.twitter.finagle.Service[self.GetDataFrameAncestry.Args, self.GetDataFrameAncestry.SuccessType],
      override val getCommonAncestor : _root_.com.twitter.finagle.Service[self.GetCommonAncestor.Args, self.GetCommonAncestor.SuccessType],
      override val getCommonAncestorForModels : _root_.com.twitter.finagle.Service[self.GetCommonAncestorForModels.Args, self.GetCommonAncestorForModels.SuccessType],
      override val getTrainingRowsCount : _root_.com.twitter.finagle.Service[self.GetTrainingRowsCount.Args, self.GetTrainingRowsCount.SuccessType],
      override val getTrainingRowsCounts : _root_.com.twitter.finagle.Service[self.GetTrainingRowsCounts.Args, self.GetTrainingRowsCounts.SuccessType],
      override val compareHyperparameters : _root_.com.twitter.finagle.Service[self.CompareHyperparameters.Args, self.CompareHyperparameters.SuccessType],
      override val compareFeatures : _root_.com.twitter.finagle.Service[self.CompareFeatures.Args, self.CompareFeatures.SuccessType],
      override val groupByProblemType : _root_.com.twitter.finagle.Service[self.GroupByProblemType.Args, self.GroupByProblemType.SuccessType],
      override val similarModels : _root_.com.twitter.finagle.Service[self.SimilarModels.Args, self.SimilarModels.SuccessType],
      override val linearModelFeatureImportances : _root_.com.twitter.finagle.Service[self.LinearModelFeatureImportances.Args, self.LinearModelFeatureImportances.SuccessType],
      override val compareLinearModelFeatureImportances : _root_.com.twitter.finagle.Service[self.CompareLinearModelFeatureImportances.Args, self.CompareLinearModelFeatureImportances.SuccessType],
      override val iterationsUntilConvergence : _root_.com.twitter.finagle.Service[self.IterationsUntilConvergence.Args, self.IterationsUntilConvergence.SuccessType],
      override val rankModels : _root_.com.twitter.finagle.Service[self.RankModels.Args, self.RankModels.SuccessType],
      override val confidenceIntervals : _root_.com.twitter.finagle.Service[self.ConfidenceIntervals.Args, self.ConfidenceIntervals.SuccessType],
      override val modelsWithFeatures : _root_.com.twitter.finagle.Service[self.ModelsWithFeatures.Args, self.ModelsWithFeatures.SuccessType],
      override val modelsDerivedFromDataFrame : _root_.com.twitter.finagle.Service[self.ModelsDerivedFromDataFrame.Args, self.ModelsDerivedFromDataFrame.SuccessType],
      override val getProjectIds : _root_.com.twitter.finagle.Service[self.GetProjectIds.Args, self.GetProjectIds.SuccessType],
      override val getModelIds : _root_.com.twitter.finagle.Service[self.GetModelIds.Args, self.GetModelIds.SuccessType],
      override val updateProject : _root_.com.twitter.finagle.Service[self.UpdateProject.Args, self.UpdateProject.SuccessType],
      override val createOrUpdateScalarField : _root_.com.twitter.finagle.Service[self.CreateOrUpdateScalarField.Args, self.CreateOrUpdateScalarField.SuccessType],
      override val createVectorField : _root_.com.twitter.finagle.Service[self.CreateVectorField.Args, self.CreateVectorField.SuccessType],
      override val updateVectorField : _root_.com.twitter.finagle.Service[self.UpdateVectorField.Args, self.UpdateVectorField.SuccessType],
      override val appendToVectorField : _root_.com.twitter.finagle.Service[self.AppendToVectorField.Args, self.AppendToVectorField.SuccessType],
      override val getModel : _root_.com.twitter.finagle.Service[self.GetModel.Args, self.GetModel.SuccessType],
      override val getRunsInExperiment : _root_.com.twitter.finagle.Service[self.GetRunsInExperiment.Args, self.GetRunsInExperiment.SuccessType],
      override val getRunsAndExperimentsInProject : _root_.com.twitter.finagle.Service[self.GetRunsAndExperimentsInProject.Args, self.GetRunsAndExperimentsInProject.SuccessType],
      override val getProjectOverviews : _root_.com.twitter.finagle.Service[self.GetProjectOverviews.Args, self.GetProjectOverviews.SuccessType],
      override val getExperimentRunDetails : _root_.com.twitter.finagle.Service[self.GetExperimentRunDetails.Args, self.GetExperimentRunDetails.SuccessType],
      override val originalFeatures : _root_.com.twitter.finagle.Service[self.OriginalFeatures.Args, self.OriginalFeatures.SuccessType],
      override val storeTreeModel : _root_.com.twitter.finagle.Service[self.StoreTreeModel.Args, self.StoreTreeModel.SuccessType],
      override val storePipelineTransformEvent : _root_.com.twitter.finagle.Service[self.StorePipelineTransformEvent.Args, self.StorePipelineTransformEvent.SuccessType],
      override val computeModelAncestry : _root_.com.twitter.finagle.Service[self.ComputeModelAncestry.Args, self.ComputeModelAncestry.SuccessType],
      override val extractPipeline : _root_.com.twitter.finagle.Service[self.ExtractPipeline.Args, self.ExtractPipeline.SuccessType]
    ) extends ServicePerEndpoint {

      override def withTestConnection(
        testConnection : _root_.com.twitter.finagle.Service[self.TestConnection.Args, self.TestConnection.SuccessType]
      ): ServicePerEndpoint =
        new ServicePerEndpointImpl(testConnection, storeDataFrame, pathForTransformer, storeFitEvent, storeMetricEvent, getFilePath, storeTransformEvent, storeRandomSplitEvent, storePipelineEvent, storeCrossValidationEvent, storeGridSearchCrossValidationEvent, storeAnnotationEvent, storeProjectEvent, storeExperimentEvent, storeExperimentRunEvent, storeLinearModel, getDataFrameAncestry, getCommonAncestor, getCommonAncestorForModels, getTrainingRowsCount, getTrainingRowsCounts, compareHyperparameters, compareFeatures, groupByProblemType, similarModels, linearModelFeatureImportances, compareLinearModelFeatureImportances, iterationsUntilConvergence, rankModels, confidenceIntervals, modelsWithFeatures, modelsDerivedFromDataFrame, getProjectIds, getModelIds, updateProject, createOrUpdateScalarField, createVectorField, updateVectorField, appendToVectorField, getModel, getRunsInExperiment, getRunsAndExperimentsInProject, getProjectOverviews, getExperimentRunDetails, originalFeatures, storeTreeModel, storePipelineTransformEvent, computeModelAncestry, extractPipeline)

      override def withStoreDataFrame(
        storeDataFrame : _root_.com.twitter.finagle.Service[self.StoreDataFrame.Args, self.StoreDataFrame.SuccessType]
      ): ServicePerEndpoint =
        new ServicePerEndpointImpl(testConnection, storeDataFrame, pathForTransformer, storeFitEvent, storeMetricEvent, getFilePath, storeTransformEvent, storeRandomSplitEvent, storePipelineEvent, storeCrossValidationEvent, storeGridSearchCrossValidationEvent, storeAnnotationEvent, storeProjectEvent, storeExperimentEvent, storeExperimentRunEvent, storeLinearModel, getDataFrameAncestry, getCommonAncestor, getCommonAncestorForModels, getTrainingRowsCount, getTrainingRowsCounts, compareHyperparameters, compareFeatures, groupByProblemType, similarModels, linearModelFeatureImportances, compareLinearModelFeatureImportances, iterationsUntilConvergence, rankModels, confidenceIntervals, modelsWithFeatures, modelsDerivedFromDataFrame, getProjectIds, getModelIds, updateProject, createOrUpdateScalarField, createVectorField, updateVectorField, appendToVectorField, getModel, getRunsInExperiment, getRunsAndExperimentsInProject, getProjectOverviews, getExperimentRunDetails, originalFeatures, storeTreeModel, storePipelineTransformEvent, computeModelAncestry, extractPipeline)

      override def withPathForTransformer(
        pathForTransformer : _root_.com.twitter.finagle.Service[self.PathForTransformer.Args, self.PathForTransformer.SuccessType]
      ): ServicePerEndpoint =
        new ServicePerEndpointImpl(testConnection, storeDataFrame, pathForTransformer, storeFitEvent, storeMetricEvent, getFilePath, storeTransformEvent, storeRandomSplitEvent, storePipelineEvent, storeCrossValidationEvent, storeGridSearchCrossValidationEvent, storeAnnotationEvent, storeProjectEvent, storeExperimentEvent, storeExperimentRunEvent, storeLinearModel, getDataFrameAncestry, getCommonAncestor, getCommonAncestorForModels, getTrainingRowsCount, getTrainingRowsCounts, compareHyperparameters, compareFeatures, groupByProblemType, similarModels, linearModelFeatureImportances, compareLinearModelFeatureImportances, iterationsUntilConvergence, rankModels, confidenceIntervals, modelsWithFeatures, modelsDerivedFromDataFrame, getProjectIds, getModelIds, updateProject, createOrUpdateScalarField, createVectorField, updateVectorField, appendToVectorField, getModel, getRunsInExperiment, getRunsAndExperimentsInProject, getProjectOverviews, getExperimentRunDetails, originalFeatures, storeTreeModel, storePipelineTransformEvent, computeModelAncestry, extractPipeline)

      override def withStoreFitEvent(
        storeFitEvent : _root_.com.twitter.finagle.Service[self.StoreFitEvent.Args, self.StoreFitEvent.SuccessType]
      ): ServicePerEndpoint =
        new ServicePerEndpointImpl(testConnection, storeDataFrame, pathForTransformer, storeFitEvent, storeMetricEvent, getFilePath, storeTransformEvent, storeRandomSplitEvent, storePipelineEvent, storeCrossValidationEvent, storeGridSearchCrossValidationEvent, storeAnnotationEvent, storeProjectEvent, storeExperimentEvent, storeExperimentRunEvent, storeLinearModel, getDataFrameAncestry, getCommonAncestor, getCommonAncestorForModels, getTrainingRowsCount, getTrainingRowsCounts, compareHyperparameters, compareFeatures, groupByProblemType, similarModels, linearModelFeatureImportances, compareLinearModelFeatureImportances, iterationsUntilConvergence, rankModels, confidenceIntervals, modelsWithFeatures, modelsDerivedFromDataFrame, getProjectIds, getModelIds, updateProject, createOrUpdateScalarField, createVectorField, updateVectorField, appendToVectorField, getModel, getRunsInExperiment, getRunsAndExperimentsInProject, getProjectOverviews, getExperimentRunDetails, originalFeatures, storeTreeModel, storePipelineTransformEvent, computeModelAncestry, extractPipeline)

      override def withStoreMetricEvent(
        storeMetricEvent : _root_.com.twitter.finagle.Service[self.StoreMetricEvent.Args, self.StoreMetricEvent.SuccessType]
      ): ServicePerEndpoint =
        new ServicePerEndpointImpl(testConnection, storeDataFrame, pathForTransformer, storeFitEvent, storeMetricEvent, getFilePath, storeTransformEvent, storeRandomSplitEvent, storePipelineEvent, storeCrossValidationEvent, storeGridSearchCrossValidationEvent, storeAnnotationEvent, storeProjectEvent, storeExperimentEvent, storeExperimentRunEvent, storeLinearModel, getDataFrameAncestry, getCommonAncestor, getCommonAncestorForModels, getTrainingRowsCount, getTrainingRowsCounts, compareHyperparameters, compareFeatures, groupByProblemType, similarModels, linearModelFeatureImportances, compareLinearModelFeatureImportances, iterationsUntilConvergence, rankModels, confidenceIntervals, modelsWithFeatures, modelsDerivedFromDataFrame, getProjectIds, getModelIds, updateProject, createOrUpdateScalarField, createVectorField, updateVectorField, appendToVectorField, getModel, getRunsInExperiment, getRunsAndExperimentsInProject, getProjectOverviews, getExperimentRunDetails, originalFeatures, storeTreeModel, storePipelineTransformEvent, computeModelAncestry, extractPipeline)

      override def withGetFilePath(
        getFilePath : _root_.com.twitter.finagle.Service[self.GetFilePath.Args, self.GetFilePath.SuccessType]
      ): ServicePerEndpoint =
        new ServicePerEndpointImpl(testConnection, storeDataFrame, pathForTransformer, storeFitEvent, storeMetricEvent, getFilePath, storeTransformEvent, storeRandomSplitEvent, storePipelineEvent, storeCrossValidationEvent, storeGridSearchCrossValidationEvent, storeAnnotationEvent, storeProjectEvent, storeExperimentEvent, storeExperimentRunEvent, storeLinearModel, getDataFrameAncestry, getCommonAncestor, getCommonAncestorForModels, getTrainingRowsCount, getTrainingRowsCounts, compareHyperparameters, compareFeatures, groupByProblemType, similarModels, linearModelFeatureImportances, compareLinearModelFeatureImportances, iterationsUntilConvergence, rankModels, confidenceIntervals, modelsWithFeatures, modelsDerivedFromDataFrame, getProjectIds, getModelIds, updateProject, createOrUpdateScalarField, createVectorField, updateVectorField, appendToVectorField, getModel, getRunsInExperiment, getRunsAndExperimentsInProject, getProjectOverviews, getExperimentRunDetails, originalFeatures, storeTreeModel, storePipelineTransformEvent, computeModelAncestry, extractPipeline)

      override def withStoreTransformEvent(
        storeTransformEvent : _root_.com.twitter.finagle.Service[self.StoreTransformEvent.Args, self.StoreTransformEvent.SuccessType]
      ): ServicePerEndpoint =
        new ServicePerEndpointImpl(testConnection, storeDataFrame, pathForTransformer, storeFitEvent, storeMetricEvent, getFilePath, storeTransformEvent, storeRandomSplitEvent, storePipelineEvent, storeCrossValidationEvent, storeGridSearchCrossValidationEvent, storeAnnotationEvent, storeProjectEvent, storeExperimentEvent, storeExperimentRunEvent, storeLinearModel, getDataFrameAncestry, getCommonAncestor, getCommonAncestorForModels, getTrainingRowsCount, getTrainingRowsCounts, compareHyperparameters, compareFeatures, groupByProblemType, similarModels, linearModelFeatureImportances, compareLinearModelFeatureImportances, iterationsUntilConvergence, rankModels, confidenceIntervals, modelsWithFeatures, modelsDerivedFromDataFrame, getProjectIds, getModelIds, updateProject, createOrUpdateScalarField, createVectorField, updateVectorField, appendToVectorField, getModel, getRunsInExperiment, getRunsAndExperimentsInProject, getProjectOverviews, getExperimentRunDetails, originalFeatures, storeTreeModel, storePipelineTransformEvent, computeModelAncestry, extractPipeline)

      override def withStoreRandomSplitEvent(
        storeRandomSplitEvent : _root_.com.twitter.finagle.Service[self.StoreRandomSplitEvent.Args, self.StoreRandomSplitEvent.SuccessType]
      ): ServicePerEndpoint =
        new ServicePerEndpointImpl(testConnection, storeDataFrame, pathForTransformer, storeFitEvent, storeMetricEvent, getFilePath, storeTransformEvent, storeRandomSplitEvent, storePipelineEvent, storeCrossValidationEvent, storeGridSearchCrossValidationEvent, storeAnnotationEvent, storeProjectEvent, storeExperimentEvent, storeExperimentRunEvent, storeLinearModel, getDataFrameAncestry, getCommonAncestor, getCommonAncestorForModels, getTrainingRowsCount, getTrainingRowsCounts, compareHyperparameters, compareFeatures, groupByProblemType, similarModels, linearModelFeatureImportances, compareLinearModelFeatureImportances, iterationsUntilConvergence, rankModels, confidenceIntervals, modelsWithFeatures, modelsDerivedFromDataFrame, getProjectIds, getModelIds, updateProject, createOrUpdateScalarField, createVectorField, updateVectorField, appendToVectorField, getModel, getRunsInExperiment, getRunsAndExperimentsInProject, getProjectOverviews, getExperimentRunDetails, originalFeatures, storeTreeModel, storePipelineTransformEvent, computeModelAncestry, extractPipeline)

      override def withStorePipelineEvent(
        storePipelineEvent : _root_.com.twitter.finagle.Service[self.StorePipelineEvent.Args, self.StorePipelineEvent.SuccessType]
      ): ServicePerEndpoint =
        new ServicePerEndpointImpl(testConnection, storeDataFrame, pathForTransformer, storeFitEvent, storeMetricEvent, getFilePath, storeTransformEvent, storeRandomSplitEvent, storePipelineEvent, storeCrossValidationEvent, storeGridSearchCrossValidationEvent, storeAnnotationEvent, storeProjectEvent, storeExperimentEvent, storeExperimentRunEvent, storeLinearModel, getDataFrameAncestry, getCommonAncestor, getCommonAncestorForModels, getTrainingRowsCount, getTrainingRowsCounts, compareHyperparameters, compareFeatures, groupByProblemType, similarModels, linearModelFeatureImportances, compareLinearModelFeatureImportances, iterationsUntilConvergence, rankModels, confidenceIntervals, modelsWithFeatures, modelsDerivedFromDataFrame, getProjectIds, getModelIds, updateProject, createOrUpdateScalarField, createVectorField, updateVectorField, appendToVectorField, getModel, getRunsInExperiment, getRunsAndExperimentsInProject, getProjectOverviews, getExperimentRunDetails, originalFeatures, storeTreeModel, storePipelineTransformEvent, computeModelAncestry, extractPipeline)

      override def withStoreCrossValidationEvent(
        storeCrossValidationEvent : _root_.com.twitter.finagle.Service[self.StoreCrossValidationEvent.Args, self.StoreCrossValidationEvent.SuccessType]
      ): ServicePerEndpoint =
        new ServicePerEndpointImpl(testConnection, storeDataFrame, pathForTransformer, storeFitEvent, storeMetricEvent, getFilePath, storeTransformEvent, storeRandomSplitEvent, storePipelineEvent, storeCrossValidationEvent, storeGridSearchCrossValidationEvent, storeAnnotationEvent, storeProjectEvent, storeExperimentEvent, storeExperimentRunEvent, storeLinearModel, getDataFrameAncestry, getCommonAncestor, getCommonAncestorForModels, getTrainingRowsCount, getTrainingRowsCounts, compareHyperparameters, compareFeatures, groupByProblemType, similarModels, linearModelFeatureImportances, compareLinearModelFeatureImportances, iterationsUntilConvergence, rankModels, confidenceIntervals, modelsWithFeatures, modelsDerivedFromDataFrame, getProjectIds, getModelIds, updateProject, createOrUpdateScalarField, createVectorField, updateVectorField, appendToVectorField, getModel, getRunsInExperiment, getRunsAndExperimentsInProject, getProjectOverviews, getExperimentRunDetails, originalFeatures, storeTreeModel, storePipelineTransformEvent, computeModelAncestry, extractPipeline)

      override def withStoreGridSearchCrossValidationEvent(
        storeGridSearchCrossValidationEvent : _root_.com.twitter.finagle.Service[self.StoreGridSearchCrossValidationEvent.Args, self.StoreGridSearchCrossValidationEvent.SuccessType]
      ): ServicePerEndpoint =
        new ServicePerEndpointImpl(testConnection, storeDataFrame, pathForTransformer, storeFitEvent, storeMetricEvent, getFilePath, storeTransformEvent, storeRandomSplitEvent, storePipelineEvent, storeCrossValidationEvent, storeGridSearchCrossValidationEvent, storeAnnotationEvent, storeProjectEvent, storeExperimentEvent, storeExperimentRunEvent, storeLinearModel, getDataFrameAncestry, getCommonAncestor, getCommonAncestorForModels, getTrainingRowsCount, getTrainingRowsCounts, compareHyperparameters, compareFeatures, groupByProblemType, similarModels, linearModelFeatureImportances, compareLinearModelFeatureImportances, iterationsUntilConvergence, rankModels, confidenceIntervals, modelsWithFeatures, modelsDerivedFromDataFrame, getProjectIds, getModelIds, updateProject, createOrUpdateScalarField, createVectorField, updateVectorField, appendToVectorField, getModel, getRunsInExperiment, getRunsAndExperimentsInProject, getProjectOverviews, getExperimentRunDetails, originalFeatures, storeTreeModel, storePipelineTransformEvent, computeModelAncestry, extractPipeline)

      override def withStoreAnnotationEvent(
        storeAnnotationEvent : _root_.com.twitter.finagle.Service[self.StoreAnnotationEvent.Args, self.StoreAnnotationEvent.SuccessType]
      ): ServicePerEndpoint =
        new ServicePerEndpointImpl(testConnection, storeDataFrame, pathForTransformer, storeFitEvent, storeMetricEvent, getFilePath, storeTransformEvent, storeRandomSplitEvent, storePipelineEvent, storeCrossValidationEvent, storeGridSearchCrossValidationEvent, storeAnnotationEvent, storeProjectEvent, storeExperimentEvent, storeExperimentRunEvent, storeLinearModel, getDataFrameAncestry, getCommonAncestor, getCommonAncestorForModels, getTrainingRowsCount, getTrainingRowsCounts, compareHyperparameters, compareFeatures, groupByProblemType, similarModels, linearModelFeatureImportances, compareLinearModelFeatureImportances, iterationsUntilConvergence, rankModels, confidenceIntervals, modelsWithFeatures, modelsDerivedFromDataFrame, getProjectIds, getModelIds, updateProject, createOrUpdateScalarField, createVectorField, updateVectorField, appendToVectorField, getModel, getRunsInExperiment, getRunsAndExperimentsInProject, getProjectOverviews, getExperimentRunDetails, originalFeatures, storeTreeModel, storePipelineTransformEvent, computeModelAncestry, extractPipeline)

      override def withStoreProjectEvent(
        storeProjectEvent : _root_.com.twitter.finagle.Service[self.StoreProjectEvent.Args, self.StoreProjectEvent.SuccessType]
      ): ServicePerEndpoint =
        new ServicePerEndpointImpl(testConnection, storeDataFrame, pathForTransformer, storeFitEvent, storeMetricEvent, getFilePath, storeTransformEvent, storeRandomSplitEvent, storePipelineEvent, storeCrossValidationEvent, storeGridSearchCrossValidationEvent, storeAnnotationEvent, storeProjectEvent, storeExperimentEvent, storeExperimentRunEvent, storeLinearModel, getDataFrameAncestry, getCommonAncestor, getCommonAncestorForModels, getTrainingRowsCount, getTrainingRowsCounts, compareHyperparameters, compareFeatures, groupByProblemType, similarModels, linearModelFeatureImportances, compareLinearModelFeatureImportances, iterationsUntilConvergence, rankModels, confidenceIntervals, modelsWithFeatures, modelsDerivedFromDataFrame, getProjectIds, getModelIds, updateProject, createOrUpdateScalarField, createVectorField, updateVectorField, appendToVectorField, getModel, getRunsInExperiment, getRunsAndExperimentsInProject, getProjectOverviews, getExperimentRunDetails, originalFeatures, storeTreeModel, storePipelineTransformEvent, computeModelAncestry, extractPipeline)

      override def withStoreExperimentEvent(
        storeExperimentEvent : _root_.com.twitter.finagle.Service[self.StoreExperimentEvent.Args, self.StoreExperimentEvent.SuccessType]
      ): ServicePerEndpoint =
        new ServicePerEndpointImpl(testConnection, storeDataFrame, pathForTransformer, storeFitEvent, storeMetricEvent, getFilePath, storeTransformEvent, storeRandomSplitEvent, storePipelineEvent, storeCrossValidationEvent, storeGridSearchCrossValidationEvent, storeAnnotationEvent, storeProjectEvent, storeExperimentEvent, storeExperimentRunEvent, storeLinearModel, getDataFrameAncestry, getCommonAncestor, getCommonAncestorForModels, getTrainingRowsCount, getTrainingRowsCounts, compareHyperparameters, compareFeatures, groupByProblemType, similarModels, linearModelFeatureImportances, compareLinearModelFeatureImportances, iterationsUntilConvergence, rankModels, confidenceIntervals, modelsWithFeatures, modelsDerivedFromDataFrame, getProjectIds, getModelIds, updateProject, createOrUpdateScalarField, createVectorField, updateVectorField, appendToVectorField, getModel, getRunsInExperiment, getRunsAndExperimentsInProject, getProjectOverviews, getExperimentRunDetails, originalFeatures, storeTreeModel, storePipelineTransformEvent, computeModelAncestry, extractPipeline)

      override def withStoreExperimentRunEvent(
        storeExperimentRunEvent : _root_.com.twitter.finagle.Service[self.StoreExperimentRunEvent.Args, self.StoreExperimentRunEvent.SuccessType]
      ): ServicePerEndpoint =
        new ServicePerEndpointImpl(testConnection, storeDataFrame, pathForTransformer, storeFitEvent, storeMetricEvent, getFilePath, storeTransformEvent, storeRandomSplitEvent, storePipelineEvent, storeCrossValidationEvent, storeGridSearchCrossValidationEvent, storeAnnotationEvent, storeProjectEvent, storeExperimentEvent, storeExperimentRunEvent, storeLinearModel, getDataFrameAncestry, getCommonAncestor, getCommonAncestorForModels, getTrainingRowsCount, getTrainingRowsCounts, compareHyperparameters, compareFeatures, groupByProblemType, similarModels, linearModelFeatureImportances, compareLinearModelFeatureImportances, iterationsUntilConvergence, rankModels, confidenceIntervals, modelsWithFeatures, modelsDerivedFromDataFrame, getProjectIds, getModelIds, updateProject, createOrUpdateScalarField, createVectorField, updateVectorField, appendToVectorField, getModel, getRunsInExperiment, getRunsAndExperimentsInProject, getProjectOverviews, getExperimentRunDetails, originalFeatures, storeTreeModel, storePipelineTransformEvent, computeModelAncestry, extractPipeline)

      override def withStoreLinearModel(
        storeLinearModel : _root_.com.twitter.finagle.Service[self.StoreLinearModel.Args, self.StoreLinearModel.SuccessType]
      ): ServicePerEndpoint =
        new ServicePerEndpointImpl(testConnection, storeDataFrame, pathForTransformer, storeFitEvent, storeMetricEvent, getFilePath, storeTransformEvent, storeRandomSplitEvent, storePipelineEvent, storeCrossValidationEvent, storeGridSearchCrossValidationEvent, storeAnnotationEvent, storeProjectEvent, storeExperimentEvent, storeExperimentRunEvent, storeLinearModel, getDataFrameAncestry, getCommonAncestor, getCommonAncestorForModels, getTrainingRowsCount, getTrainingRowsCounts, compareHyperparameters, compareFeatures, groupByProblemType, similarModels, linearModelFeatureImportances, compareLinearModelFeatureImportances, iterationsUntilConvergence, rankModels, confidenceIntervals, modelsWithFeatures, modelsDerivedFromDataFrame, getProjectIds, getModelIds, updateProject, createOrUpdateScalarField, createVectorField, updateVectorField, appendToVectorField, getModel, getRunsInExperiment, getRunsAndExperimentsInProject, getProjectOverviews, getExperimentRunDetails, originalFeatures, storeTreeModel, storePipelineTransformEvent, computeModelAncestry, extractPipeline)

      override def withGetDataFrameAncestry(
        getDataFrameAncestry : _root_.com.twitter.finagle.Service[self.GetDataFrameAncestry.Args, self.GetDataFrameAncestry.SuccessType]
      ): ServicePerEndpoint =
        new ServicePerEndpointImpl(testConnection, storeDataFrame, pathForTransformer, storeFitEvent, storeMetricEvent, getFilePath, storeTransformEvent, storeRandomSplitEvent, storePipelineEvent, storeCrossValidationEvent, storeGridSearchCrossValidationEvent, storeAnnotationEvent, storeProjectEvent, storeExperimentEvent, storeExperimentRunEvent, storeLinearModel, getDataFrameAncestry, getCommonAncestor, getCommonAncestorForModels, getTrainingRowsCount, getTrainingRowsCounts, compareHyperparameters, compareFeatures, groupByProblemType, similarModels, linearModelFeatureImportances, compareLinearModelFeatureImportances, iterationsUntilConvergence, rankModels, confidenceIntervals, modelsWithFeatures, modelsDerivedFromDataFrame, getProjectIds, getModelIds, updateProject, createOrUpdateScalarField, createVectorField, updateVectorField, appendToVectorField, getModel, getRunsInExperiment, getRunsAndExperimentsInProject, getProjectOverviews, getExperimentRunDetails, originalFeatures, storeTreeModel, storePipelineTransformEvent, computeModelAncestry, extractPipeline)

      override def withGetCommonAncestor(
        getCommonAncestor : _root_.com.twitter.finagle.Service[self.GetCommonAncestor.Args, self.GetCommonAncestor.SuccessType]
      ): ServicePerEndpoint =
        new ServicePerEndpointImpl(testConnection, storeDataFrame, pathForTransformer, storeFitEvent, storeMetricEvent, getFilePath, storeTransformEvent, storeRandomSplitEvent, storePipelineEvent, storeCrossValidationEvent, storeGridSearchCrossValidationEvent, storeAnnotationEvent, storeProjectEvent, storeExperimentEvent, storeExperimentRunEvent, storeLinearModel, getDataFrameAncestry, getCommonAncestor, getCommonAncestorForModels, getTrainingRowsCount, getTrainingRowsCounts, compareHyperparameters, compareFeatures, groupByProblemType, similarModels, linearModelFeatureImportances, compareLinearModelFeatureImportances, iterationsUntilConvergence, rankModels, confidenceIntervals, modelsWithFeatures, modelsDerivedFromDataFrame, getProjectIds, getModelIds, updateProject, createOrUpdateScalarField, createVectorField, updateVectorField, appendToVectorField, getModel, getRunsInExperiment, getRunsAndExperimentsInProject, getProjectOverviews, getExperimentRunDetails, originalFeatures, storeTreeModel, storePipelineTransformEvent, computeModelAncestry, extractPipeline)

      override def withGetCommonAncestorForModels(
        getCommonAncestorForModels : _root_.com.twitter.finagle.Service[self.GetCommonAncestorForModels.Args, self.GetCommonAncestorForModels.SuccessType]
      ): ServicePerEndpoint =
        new ServicePerEndpointImpl(testConnection, storeDataFrame, pathForTransformer, storeFitEvent, storeMetricEvent, getFilePath, storeTransformEvent, storeRandomSplitEvent, storePipelineEvent, storeCrossValidationEvent, storeGridSearchCrossValidationEvent, storeAnnotationEvent, storeProjectEvent, storeExperimentEvent, storeExperimentRunEvent, storeLinearModel, getDataFrameAncestry, getCommonAncestor, getCommonAncestorForModels, getTrainingRowsCount, getTrainingRowsCounts, compareHyperparameters, compareFeatures, groupByProblemType, similarModels, linearModelFeatureImportances, compareLinearModelFeatureImportances, iterationsUntilConvergence, rankModels, confidenceIntervals, modelsWithFeatures, modelsDerivedFromDataFrame, getProjectIds, getModelIds, updateProject, createOrUpdateScalarField, createVectorField, updateVectorField, appendToVectorField, getModel, getRunsInExperiment, getRunsAndExperimentsInProject, getProjectOverviews, getExperimentRunDetails, originalFeatures, storeTreeModel, storePipelineTransformEvent, computeModelAncestry, extractPipeline)

      override def withGetTrainingRowsCount(
        getTrainingRowsCount : _root_.com.twitter.finagle.Service[self.GetTrainingRowsCount.Args, self.GetTrainingRowsCount.SuccessType]
      ): ServicePerEndpoint =
        new ServicePerEndpointImpl(testConnection, storeDataFrame, pathForTransformer, storeFitEvent, storeMetricEvent, getFilePath, storeTransformEvent, storeRandomSplitEvent, storePipelineEvent, storeCrossValidationEvent, storeGridSearchCrossValidationEvent, storeAnnotationEvent, storeProjectEvent, storeExperimentEvent, storeExperimentRunEvent, storeLinearModel, getDataFrameAncestry, getCommonAncestor, getCommonAncestorForModels, getTrainingRowsCount, getTrainingRowsCounts, compareHyperparameters, compareFeatures, groupByProblemType, similarModels, linearModelFeatureImportances, compareLinearModelFeatureImportances, iterationsUntilConvergence, rankModels, confidenceIntervals, modelsWithFeatures, modelsDerivedFromDataFrame, getProjectIds, getModelIds, updateProject, createOrUpdateScalarField, createVectorField, updateVectorField, appendToVectorField, getModel, getRunsInExperiment, getRunsAndExperimentsInProject, getProjectOverviews, getExperimentRunDetails, originalFeatures, storeTreeModel, storePipelineTransformEvent, computeModelAncestry, extractPipeline)

      override def withGetTrainingRowsCounts(
        getTrainingRowsCounts : _root_.com.twitter.finagle.Service[self.GetTrainingRowsCounts.Args, self.GetTrainingRowsCounts.SuccessType]
      ): ServicePerEndpoint =
        new ServicePerEndpointImpl(testConnection, storeDataFrame, pathForTransformer, storeFitEvent, storeMetricEvent, getFilePath, storeTransformEvent, storeRandomSplitEvent, storePipelineEvent, storeCrossValidationEvent, storeGridSearchCrossValidationEvent, storeAnnotationEvent, storeProjectEvent, storeExperimentEvent, storeExperimentRunEvent, storeLinearModel, getDataFrameAncestry, getCommonAncestor, getCommonAncestorForModels, getTrainingRowsCount, getTrainingRowsCounts, compareHyperparameters, compareFeatures, groupByProblemType, similarModels, linearModelFeatureImportances, compareLinearModelFeatureImportances, iterationsUntilConvergence, rankModels, confidenceIntervals, modelsWithFeatures, modelsDerivedFromDataFrame, getProjectIds, getModelIds, updateProject, createOrUpdateScalarField, createVectorField, updateVectorField, appendToVectorField, getModel, getRunsInExperiment, getRunsAndExperimentsInProject, getProjectOverviews, getExperimentRunDetails, originalFeatures, storeTreeModel, storePipelineTransformEvent, computeModelAncestry, extractPipeline)

      override def withCompareHyperparameters(
        compareHyperparameters : _root_.com.twitter.finagle.Service[self.CompareHyperparameters.Args, self.CompareHyperparameters.SuccessType]
      ): ServicePerEndpoint =
        new ServicePerEndpointImpl(testConnection, storeDataFrame, pathForTransformer, storeFitEvent, storeMetricEvent, getFilePath, storeTransformEvent, storeRandomSplitEvent, storePipelineEvent, storeCrossValidationEvent, storeGridSearchCrossValidationEvent, storeAnnotationEvent, storeProjectEvent, storeExperimentEvent, storeExperimentRunEvent, storeLinearModel, getDataFrameAncestry, getCommonAncestor, getCommonAncestorForModels, getTrainingRowsCount, getTrainingRowsCounts, compareHyperparameters, compareFeatures, groupByProblemType, similarModels, linearModelFeatureImportances, compareLinearModelFeatureImportances, iterationsUntilConvergence, rankModels, confidenceIntervals, modelsWithFeatures, modelsDerivedFromDataFrame, getProjectIds, getModelIds, updateProject, createOrUpdateScalarField, createVectorField, updateVectorField, appendToVectorField, getModel, getRunsInExperiment, getRunsAndExperimentsInProject, getProjectOverviews, getExperimentRunDetails, originalFeatures, storeTreeModel, storePipelineTransformEvent, computeModelAncestry, extractPipeline)

      override def withCompareFeatures(
        compareFeatures : _root_.com.twitter.finagle.Service[self.CompareFeatures.Args, self.CompareFeatures.SuccessType]
      ): ServicePerEndpoint =
        new ServicePerEndpointImpl(testConnection, storeDataFrame, pathForTransformer, storeFitEvent, storeMetricEvent, getFilePath, storeTransformEvent, storeRandomSplitEvent, storePipelineEvent, storeCrossValidationEvent, storeGridSearchCrossValidationEvent, storeAnnotationEvent, storeProjectEvent, storeExperimentEvent, storeExperimentRunEvent, storeLinearModel, getDataFrameAncestry, getCommonAncestor, getCommonAncestorForModels, getTrainingRowsCount, getTrainingRowsCounts, compareHyperparameters, compareFeatures, groupByProblemType, similarModels, linearModelFeatureImportances, compareLinearModelFeatureImportances, iterationsUntilConvergence, rankModels, confidenceIntervals, modelsWithFeatures, modelsDerivedFromDataFrame, getProjectIds, getModelIds, updateProject, createOrUpdateScalarField, createVectorField, updateVectorField, appendToVectorField, getModel, getRunsInExperiment, getRunsAndExperimentsInProject, getProjectOverviews, getExperimentRunDetails, originalFeatures, storeTreeModel, storePipelineTransformEvent, computeModelAncestry, extractPipeline)

      override def withGroupByProblemType(
        groupByProblemType : _root_.com.twitter.finagle.Service[self.GroupByProblemType.Args, self.GroupByProblemType.SuccessType]
      ): ServicePerEndpoint =
        new ServicePerEndpointImpl(testConnection, storeDataFrame, pathForTransformer, storeFitEvent, storeMetricEvent, getFilePath, storeTransformEvent, storeRandomSplitEvent, storePipelineEvent, storeCrossValidationEvent, storeGridSearchCrossValidationEvent, storeAnnotationEvent, storeProjectEvent, storeExperimentEvent, storeExperimentRunEvent, storeLinearModel, getDataFrameAncestry, getCommonAncestor, getCommonAncestorForModels, getTrainingRowsCount, getTrainingRowsCounts, compareHyperparameters, compareFeatures, groupByProblemType, similarModels, linearModelFeatureImportances, compareLinearModelFeatureImportances, iterationsUntilConvergence, rankModels, confidenceIntervals, modelsWithFeatures, modelsDerivedFromDataFrame, getProjectIds, getModelIds, updateProject, createOrUpdateScalarField, createVectorField, updateVectorField, appendToVectorField, getModel, getRunsInExperiment, getRunsAndExperimentsInProject, getProjectOverviews, getExperimentRunDetails, originalFeatures, storeTreeModel, storePipelineTransformEvent, computeModelAncestry, extractPipeline)

      override def withSimilarModels(
        similarModels : _root_.com.twitter.finagle.Service[self.SimilarModels.Args, self.SimilarModels.SuccessType]
      ): ServicePerEndpoint =
        new ServicePerEndpointImpl(testConnection, storeDataFrame, pathForTransformer, storeFitEvent, storeMetricEvent, getFilePath, storeTransformEvent, storeRandomSplitEvent, storePipelineEvent, storeCrossValidationEvent, storeGridSearchCrossValidationEvent, storeAnnotationEvent, storeProjectEvent, storeExperimentEvent, storeExperimentRunEvent, storeLinearModel, getDataFrameAncestry, getCommonAncestor, getCommonAncestorForModels, getTrainingRowsCount, getTrainingRowsCounts, compareHyperparameters, compareFeatures, groupByProblemType, similarModels, linearModelFeatureImportances, compareLinearModelFeatureImportances, iterationsUntilConvergence, rankModels, confidenceIntervals, modelsWithFeatures, modelsDerivedFromDataFrame, getProjectIds, getModelIds, updateProject, createOrUpdateScalarField, createVectorField, updateVectorField, appendToVectorField, getModel, getRunsInExperiment, getRunsAndExperimentsInProject, getProjectOverviews, getExperimentRunDetails, originalFeatures, storeTreeModel, storePipelineTransformEvent, computeModelAncestry, extractPipeline)

      override def withLinearModelFeatureImportances(
        linearModelFeatureImportances : _root_.com.twitter.finagle.Service[self.LinearModelFeatureImportances.Args, self.LinearModelFeatureImportances.SuccessType]
      ): ServicePerEndpoint =
        new ServicePerEndpointImpl(testConnection, storeDataFrame, pathForTransformer, storeFitEvent, storeMetricEvent, getFilePath, storeTransformEvent, storeRandomSplitEvent, storePipelineEvent, storeCrossValidationEvent, storeGridSearchCrossValidationEvent, storeAnnotationEvent, storeProjectEvent, storeExperimentEvent, storeExperimentRunEvent, storeLinearModel, getDataFrameAncestry, getCommonAncestor, getCommonAncestorForModels, getTrainingRowsCount, getTrainingRowsCounts, compareHyperparameters, compareFeatures, groupByProblemType, similarModels, linearModelFeatureImportances, compareLinearModelFeatureImportances, iterationsUntilConvergence, rankModels, confidenceIntervals, modelsWithFeatures, modelsDerivedFromDataFrame, getProjectIds, getModelIds, updateProject, createOrUpdateScalarField, createVectorField, updateVectorField, appendToVectorField, getModel, getRunsInExperiment, getRunsAndExperimentsInProject, getProjectOverviews, getExperimentRunDetails, originalFeatures, storeTreeModel, storePipelineTransformEvent, computeModelAncestry, extractPipeline)

      override def withCompareLinearModelFeatureImportances(
        compareLinearModelFeatureImportances : _root_.com.twitter.finagle.Service[self.CompareLinearModelFeatureImportances.Args, self.CompareLinearModelFeatureImportances.SuccessType]
      ): ServicePerEndpoint =
        new ServicePerEndpointImpl(testConnection, storeDataFrame, pathForTransformer, storeFitEvent, storeMetricEvent, getFilePath, storeTransformEvent, storeRandomSplitEvent, storePipelineEvent, storeCrossValidationEvent, storeGridSearchCrossValidationEvent, storeAnnotationEvent, storeProjectEvent, storeExperimentEvent, storeExperimentRunEvent, storeLinearModel, getDataFrameAncestry, getCommonAncestor, getCommonAncestorForModels, getTrainingRowsCount, getTrainingRowsCounts, compareHyperparameters, compareFeatures, groupByProblemType, similarModels, linearModelFeatureImportances, compareLinearModelFeatureImportances, iterationsUntilConvergence, rankModels, confidenceIntervals, modelsWithFeatures, modelsDerivedFromDataFrame, getProjectIds, getModelIds, updateProject, createOrUpdateScalarField, createVectorField, updateVectorField, appendToVectorField, getModel, getRunsInExperiment, getRunsAndExperimentsInProject, getProjectOverviews, getExperimentRunDetails, originalFeatures, storeTreeModel, storePipelineTransformEvent, computeModelAncestry, extractPipeline)

      override def withIterationsUntilConvergence(
        iterationsUntilConvergence : _root_.com.twitter.finagle.Service[self.IterationsUntilConvergence.Args, self.IterationsUntilConvergence.SuccessType]
      ): ServicePerEndpoint =
        new ServicePerEndpointImpl(testConnection, storeDataFrame, pathForTransformer, storeFitEvent, storeMetricEvent, getFilePath, storeTransformEvent, storeRandomSplitEvent, storePipelineEvent, storeCrossValidationEvent, storeGridSearchCrossValidationEvent, storeAnnotationEvent, storeProjectEvent, storeExperimentEvent, storeExperimentRunEvent, storeLinearModel, getDataFrameAncestry, getCommonAncestor, getCommonAncestorForModels, getTrainingRowsCount, getTrainingRowsCounts, compareHyperparameters, compareFeatures, groupByProblemType, similarModels, linearModelFeatureImportances, compareLinearModelFeatureImportances, iterationsUntilConvergence, rankModels, confidenceIntervals, modelsWithFeatures, modelsDerivedFromDataFrame, getProjectIds, getModelIds, updateProject, createOrUpdateScalarField, createVectorField, updateVectorField, appendToVectorField, getModel, getRunsInExperiment, getRunsAndExperimentsInProject, getProjectOverviews, getExperimentRunDetails, originalFeatures, storeTreeModel, storePipelineTransformEvent, computeModelAncestry, extractPipeline)

      override def withRankModels(
        rankModels : _root_.com.twitter.finagle.Service[self.RankModels.Args, self.RankModels.SuccessType]
      ): ServicePerEndpoint =
        new ServicePerEndpointImpl(testConnection, storeDataFrame, pathForTransformer, storeFitEvent, storeMetricEvent, getFilePath, storeTransformEvent, storeRandomSplitEvent, storePipelineEvent, storeCrossValidationEvent, storeGridSearchCrossValidationEvent, storeAnnotationEvent, storeProjectEvent, storeExperimentEvent, storeExperimentRunEvent, storeLinearModel, getDataFrameAncestry, getCommonAncestor, getCommonAncestorForModels, getTrainingRowsCount, getTrainingRowsCounts, compareHyperparameters, compareFeatures, groupByProblemType, similarModels, linearModelFeatureImportances, compareLinearModelFeatureImportances, iterationsUntilConvergence, rankModels, confidenceIntervals, modelsWithFeatures, modelsDerivedFromDataFrame, getProjectIds, getModelIds, updateProject, createOrUpdateScalarField, createVectorField, updateVectorField, appendToVectorField, getModel, getRunsInExperiment, getRunsAndExperimentsInProject, getProjectOverviews, getExperimentRunDetails, originalFeatures, storeTreeModel, storePipelineTransformEvent, computeModelAncestry, extractPipeline)

      override def withConfidenceIntervals(
        confidenceIntervals : _root_.com.twitter.finagle.Service[self.ConfidenceIntervals.Args, self.ConfidenceIntervals.SuccessType]
      ): ServicePerEndpoint =
        new ServicePerEndpointImpl(testConnection, storeDataFrame, pathForTransformer, storeFitEvent, storeMetricEvent, getFilePath, storeTransformEvent, storeRandomSplitEvent, storePipelineEvent, storeCrossValidationEvent, storeGridSearchCrossValidationEvent, storeAnnotationEvent, storeProjectEvent, storeExperimentEvent, storeExperimentRunEvent, storeLinearModel, getDataFrameAncestry, getCommonAncestor, getCommonAncestorForModels, getTrainingRowsCount, getTrainingRowsCounts, compareHyperparameters, compareFeatures, groupByProblemType, similarModels, linearModelFeatureImportances, compareLinearModelFeatureImportances, iterationsUntilConvergence, rankModels, confidenceIntervals, modelsWithFeatures, modelsDerivedFromDataFrame, getProjectIds, getModelIds, updateProject, createOrUpdateScalarField, createVectorField, updateVectorField, appendToVectorField, getModel, getRunsInExperiment, getRunsAndExperimentsInProject, getProjectOverviews, getExperimentRunDetails, originalFeatures, storeTreeModel, storePipelineTransformEvent, computeModelAncestry, extractPipeline)

      override def withModelsWithFeatures(
        modelsWithFeatures : _root_.com.twitter.finagle.Service[self.ModelsWithFeatures.Args, self.ModelsWithFeatures.SuccessType]
      ): ServicePerEndpoint =
        new ServicePerEndpointImpl(testConnection, storeDataFrame, pathForTransformer, storeFitEvent, storeMetricEvent, getFilePath, storeTransformEvent, storeRandomSplitEvent, storePipelineEvent, storeCrossValidationEvent, storeGridSearchCrossValidationEvent, storeAnnotationEvent, storeProjectEvent, storeExperimentEvent, storeExperimentRunEvent, storeLinearModel, getDataFrameAncestry, getCommonAncestor, getCommonAncestorForModels, getTrainingRowsCount, getTrainingRowsCounts, compareHyperparameters, compareFeatures, groupByProblemType, similarModels, linearModelFeatureImportances, compareLinearModelFeatureImportances, iterationsUntilConvergence, rankModels, confidenceIntervals, modelsWithFeatures, modelsDerivedFromDataFrame, getProjectIds, getModelIds, updateProject, createOrUpdateScalarField, createVectorField, updateVectorField, appendToVectorField, getModel, getRunsInExperiment, getRunsAndExperimentsInProject, getProjectOverviews, getExperimentRunDetails, originalFeatures, storeTreeModel, storePipelineTransformEvent, computeModelAncestry, extractPipeline)

      override def withModelsDerivedFromDataFrame(
        modelsDerivedFromDataFrame : _root_.com.twitter.finagle.Service[self.ModelsDerivedFromDataFrame.Args, self.ModelsDerivedFromDataFrame.SuccessType]
      ): ServicePerEndpoint =
        new ServicePerEndpointImpl(testConnection, storeDataFrame, pathForTransformer, storeFitEvent, storeMetricEvent, getFilePath, storeTransformEvent, storeRandomSplitEvent, storePipelineEvent, storeCrossValidationEvent, storeGridSearchCrossValidationEvent, storeAnnotationEvent, storeProjectEvent, storeExperimentEvent, storeExperimentRunEvent, storeLinearModel, getDataFrameAncestry, getCommonAncestor, getCommonAncestorForModels, getTrainingRowsCount, getTrainingRowsCounts, compareHyperparameters, compareFeatures, groupByProblemType, similarModels, linearModelFeatureImportances, compareLinearModelFeatureImportances, iterationsUntilConvergence, rankModels, confidenceIntervals, modelsWithFeatures, modelsDerivedFromDataFrame, getProjectIds, getModelIds, updateProject, createOrUpdateScalarField, createVectorField, updateVectorField, appendToVectorField, getModel, getRunsInExperiment, getRunsAndExperimentsInProject, getProjectOverviews, getExperimentRunDetails, originalFeatures, storeTreeModel, storePipelineTransformEvent, computeModelAncestry, extractPipeline)

      override def withGetProjectIds(
        getProjectIds : _root_.com.twitter.finagle.Service[self.GetProjectIds.Args, self.GetProjectIds.SuccessType]
      ): ServicePerEndpoint =
        new ServicePerEndpointImpl(testConnection, storeDataFrame, pathForTransformer, storeFitEvent, storeMetricEvent, getFilePath, storeTransformEvent, storeRandomSplitEvent, storePipelineEvent, storeCrossValidationEvent, storeGridSearchCrossValidationEvent, storeAnnotationEvent, storeProjectEvent, storeExperimentEvent, storeExperimentRunEvent, storeLinearModel, getDataFrameAncestry, getCommonAncestor, getCommonAncestorForModels, getTrainingRowsCount, getTrainingRowsCounts, compareHyperparameters, compareFeatures, groupByProblemType, similarModels, linearModelFeatureImportances, compareLinearModelFeatureImportances, iterationsUntilConvergence, rankModels, confidenceIntervals, modelsWithFeatures, modelsDerivedFromDataFrame, getProjectIds, getModelIds, updateProject, createOrUpdateScalarField, createVectorField, updateVectorField, appendToVectorField, getModel, getRunsInExperiment, getRunsAndExperimentsInProject, getProjectOverviews, getExperimentRunDetails, originalFeatures, storeTreeModel, storePipelineTransformEvent, computeModelAncestry, extractPipeline)

      override def withGetModelIds(
        getModelIds : _root_.com.twitter.finagle.Service[self.GetModelIds.Args, self.GetModelIds.SuccessType]
      ): ServicePerEndpoint =
        new ServicePerEndpointImpl(testConnection, storeDataFrame, pathForTransformer, storeFitEvent, storeMetricEvent, getFilePath, storeTransformEvent, storeRandomSplitEvent, storePipelineEvent, storeCrossValidationEvent, storeGridSearchCrossValidationEvent, storeAnnotationEvent, storeProjectEvent, storeExperimentEvent, storeExperimentRunEvent, storeLinearModel, getDataFrameAncestry, getCommonAncestor, getCommonAncestorForModels, getTrainingRowsCount, getTrainingRowsCounts, compareHyperparameters, compareFeatures, groupByProblemType, similarModels, linearModelFeatureImportances, compareLinearModelFeatureImportances, iterationsUntilConvergence, rankModels, confidenceIntervals, modelsWithFeatures, modelsDerivedFromDataFrame, getProjectIds, getModelIds, updateProject, createOrUpdateScalarField, createVectorField, updateVectorField, appendToVectorField, getModel, getRunsInExperiment, getRunsAndExperimentsInProject, getProjectOverviews, getExperimentRunDetails, originalFeatures, storeTreeModel, storePipelineTransformEvent, computeModelAncestry, extractPipeline)

      override def withUpdateProject(
        updateProject : _root_.com.twitter.finagle.Service[self.UpdateProject.Args, self.UpdateProject.SuccessType]
      ): ServicePerEndpoint =
        new ServicePerEndpointImpl(testConnection, storeDataFrame, pathForTransformer, storeFitEvent, storeMetricEvent, getFilePath, storeTransformEvent, storeRandomSplitEvent, storePipelineEvent, storeCrossValidationEvent, storeGridSearchCrossValidationEvent, storeAnnotationEvent, storeProjectEvent, storeExperimentEvent, storeExperimentRunEvent, storeLinearModel, getDataFrameAncestry, getCommonAncestor, getCommonAncestorForModels, getTrainingRowsCount, getTrainingRowsCounts, compareHyperparameters, compareFeatures, groupByProblemType, similarModels, linearModelFeatureImportances, compareLinearModelFeatureImportances, iterationsUntilConvergence, rankModels, confidenceIntervals, modelsWithFeatures, modelsDerivedFromDataFrame, getProjectIds, getModelIds, updateProject, createOrUpdateScalarField, createVectorField, updateVectorField, appendToVectorField, getModel, getRunsInExperiment, getRunsAndExperimentsInProject, getProjectOverviews, getExperimentRunDetails, originalFeatures, storeTreeModel, storePipelineTransformEvent, computeModelAncestry, extractPipeline)

      override def withCreateOrUpdateScalarField(
        createOrUpdateScalarField : _root_.com.twitter.finagle.Service[self.CreateOrUpdateScalarField.Args, self.CreateOrUpdateScalarField.SuccessType]
      ): ServicePerEndpoint =
        new ServicePerEndpointImpl(testConnection, storeDataFrame, pathForTransformer, storeFitEvent, storeMetricEvent, getFilePath, storeTransformEvent, storeRandomSplitEvent, storePipelineEvent, storeCrossValidationEvent, storeGridSearchCrossValidationEvent, storeAnnotationEvent, storeProjectEvent, storeExperimentEvent, storeExperimentRunEvent, storeLinearModel, getDataFrameAncestry, getCommonAncestor, getCommonAncestorForModels, getTrainingRowsCount, getTrainingRowsCounts, compareHyperparameters, compareFeatures, groupByProblemType, similarModels, linearModelFeatureImportances, compareLinearModelFeatureImportances, iterationsUntilConvergence, rankModels, confidenceIntervals, modelsWithFeatures, modelsDerivedFromDataFrame, getProjectIds, getModelIds, updateProject, createOrUpdateScalarField, createVectorField, updateVectorField, appendToVectorField, getModel, getRunsInExperiment, getRunsAndExperimentsInProject, getProjectOverviews, getExperimentRunDetails, originalFeatures, storeTreeModel, storePipelineTransformEvent, computeModelAncestry, extractPipeline)

      override def withCreateVectorField(
        createVectorField : _root_.com.twitter.finagle.Service[self.CreateVectorField.Args, self.CreateVectorField.SuccessType]
      ): ServicePerEndpoint =
        new ServicePerEndpointImpl(testConnection, storeDataFrame, pathForTransformer, storeFitEvent, storeMetricEvent, getFilePath, storeTransformEvent, storeRandomSplitEvent, storePipelineEvent, storeCrossValidationEvent, storeGridSearchCrossValidationEvent, storeAnnotationEvent, storeProjectEvent, storeExperimentEvent, storeExperimentRunEvent, storeLinearModel, getDataFrameAncestry, getCommonAncestor, getCommonAncestorForModels, getTrainingRowsCount, getTrainingRowsCounts, compareHyperparameters, compareFeatures, groupByProblemType, similarModels, linearModelFeatureImportances, compareLinearModelFeatureImportances, iterationsUntilConvergence, rankModels, confidenceIntervals, modelsWithFeatures, modelsDerivedFromDataFrame, getProjectIds, getModelIds, updateProject, createOrUpdateScalarField, createVectorField, updateVectorField, appendToVectorField, getModel, getRunsInExperiment, getRunsAndExperimentsInProject, getProjectOverviews, getExperimentRunDetails, originalFeatures, storeTreeModel, storePipelineTransformEvent, computeModelAncestry, extractPipeline)

      override def withUpdateVectorField(
        updateVectorField : _root_.com.twitter.finagle.Service[self.UpdateVectorField.Args, self.UpdateVectorField.SuccessType]
      ): ServicePerEndpoint =
        new ServicePerEndpointImpl(testConnection, storeDataFrame, pathForTransformer, storeFitEvent, storeMetricEvent, getFilePath, storeTransformEvent, storeRandomSplitEvent, storePipelineEvent, storeCrossValidationEvent, storeGridSearchCrossValidationEvent, storeAnnotationEvent, storeProjectEvent, storeExperimentEvent, storeExperimentRunEvent, storeLinearModel, getDataFrameAncestry, getCommonAncestor, getCommonAncestorForModels, getTrainingRowsCount, getTrainingRowsCounts, compareHyperparameters, compareFeatures, groupByProblemType, similarModels, linearModelFeatureImportances, compareLinearModelFeatureImportances, iterationsUntilConvergence, rankModels, confidenceIntervals, modelsWithFeatures, modelsDerivedFromDataFrame, getProjectIds, getModelIds, updateProject, createOrUpdateScalarField, createVectorField, updateVectorField, appendToVectorField, getModel, getRunsInExperiment, getRunsAndExperimentsInProject, getProjectOverviews, getExperimentRunDetails, originalFeatures, storeTreeModel, storePipelineTransformEvent, computeModelAncestry, extractPipeline)

      override def withAppendToVectorField(
        appendToVectorField : _root_.com.twitter.finagle.Service[self.AppendToVectorField.Args, self.AppendToVectorField.SuccessType]
      ): ServicePerEndpoint =
        new ServicePerEndpointImpl(testConnection, storeDataFrame, pathForTransformer, storeFitEvent, storeMetricEvent, getFilePath, storeTransformEvent, storeRandomSplitEvent, storePipelineEvent, storeCrossValidationEvent, storeGridSearchCrossValidationEvent, storeAnnotationEvent, storeProjectEvent, storeExperimentEvent, storeExperimentRunEvent, storeLinearModel, getDataFrameAncestry, getCommonAncestor, getCommonAncestorForModels, getTrainingRowsCount, getTrainingRowsCounts, compareHyperparameters, compareFeatures, groupByProblemType, similarModels, linearModelFeatureImportances, compareLinearModelFeatureImportances, iterationsUntilConvergence, rankModels, confidenceIntervals, modelsWithFeatures, modelsDerivedFromDataFrame, getProjectIds, getModelIds, updateProject, createOrUpdateScalarField, createVectorField, updateVectorField, appendToVectorField, getModel, getRunsInExperiment, getRunsAndExperimentsInProject, getProjectOverviews, getExperimentRunDetails, originalFeatures, storeTreeModel, storePipelineTransformEvent, computeModelAncestry, extractPipeline)

      override def withGetModel(
        getModel : _root_.com.twitter.finagle.Service[self.GetModel.Args, self.GetModel.SuccessType]
      ): ServicePerEndpoint =
        new ServicePerEndpointImpl(testConnection, storeDataFrame, pathForTransformer, storeFitEvent, storeMetricEvent, getFilePath, storeTransformEvent, storeRandomSplitEvent, storePipelineEvent, storeCrossValidationEvent, storeGridSearchCrossValidationEvent, storeAnnotationEvent, storeProjectEvent, storeExperimentEvent, storeExperimentRunEvent, storeLinearModel, getDataFrameAncestry, getCommonAncestor, getCommonAncestorForModels, getTrainingRowsCount, getTrainingRowsCounts, compareHyperparameters, compareFeatures, groupByProblemType, similarModels, linearModelFeatureImportances, compareLinearModelFeatureImportances, iterationsUntilConvergence, rankModels, confidenceIntervals, modelsWithFeatures, modelsDerivedFromDataFrame, getProjectIds, getModelIds, updateProject, createOrUpdateScalarField, createVectorField, updateVectorField, appendToVectorField, getModel, getRunsInExperiment, getRunsAndExperimentsInProject, getProjectOverviews, getExperimentRunDetails, originalFeatures, storeTreeModel, storePipelineTransformEvent, computeModelAncestry, extractPipeline)

      override def withGetRunsInExperiment(
        getRunsInExperiment : _root_.com.twitter.finagle.Service[self.GetRunsInExperiment.Args, self.GetRunsInExperiment.SuccessType]
      ): ServicePerEndpoint =
        new ServicePerEndpointImpl(testConnection, storeDataFrame, pathForTransformer, storeFitEvent, storeMetricEvent, getFilePath, storeTransformEvent, storeRandomSplitEvent, storePipelineEvent, storeCrossValidationEvent, storeGridSearchCrossValidationEvent, storeAnnotationEvent, storeProjectEvent, storeExperimentEvent, storeExperimentRunEvent, storeLinearModel, getDataFrameAncestry, getCommonAncestor, getCommonAncestorForModels, getTrainingRowsCount, getTrainingRowsCounts, compareHyperparameters, compareFeatures, groupByProblemType, similarModels, linearModelFeatureImportances, compareLinearModelFeatureImportances, iterationsUntilConvergence, rankModels, confidenceIntervals, modelsWithFeatures, modelsDerivedFromDataFrame, getProjectIds, getModelIds, updateProject, createOrUpdateScalarField, createVectorField, updateVectorField, appendToVectorField, getModel, getRunsInExperiment, getRunsAndExperimentsInProject, getProjectOverviews, getExperimentRunDetails, originalFeatures, storeTreeModel, storePipelineTransformEvent, computeModelAncestry, extractPipeline)

      override def withGetRunsAndExperimentsInProject(
        getRunsAndExperimentsInProject : _root_.com.twitter.finagle.Service[self.GetRunsAndExperimentsInProject.Args, self.GetRunsAndExperimentsInProject.SuccessType]
      ): ServicePerEndpoint =
        new ServicePerEndpointImpl(testConnection, storeDataFrame, pathForTransformer, storeFitEvent, storeMetricEvent, getFilePath, storeTransformEvent, storeRandomSplitEvent, storePipelineEvent, storeCrossValidationEvent, storeGridSearchCrossValidationEvent, storeAnnotationEvent, storeProjectEvent, storeExperimentEvent, storeExperimentRunEvent, storeLinearModel, getDataFrameAncestry, getCommonAncestor, getCommonAncestorForModels, getTrainingRowsCount, getTrainingRowsCounts, compareHyperparameters, compareFeatures, groupByProblemType, similarModels, linearModelFeatureImportances, compareLinearModelFeatureImportances, iterationsUntilConvergence, rankModels, confidenceIntervals, modelsWithFeatures, modelsDerivedFromDataFrame, getProjectIds, getModelIds, updateProject, createOrUpdateScalarField, createVectorField, updateVectorField, appendToVectorField, getModel, getRunsInExperiment, getRunsAndExperimentsInProject, getProjectOverviews, getExperimentRunDetails, originalFeatures, storeTreeModel, storePipelineTransformEvent, computeModelAncestry, extractPipeline)

      override def withGetProjectOverviews(
        getProjectOverviews : _root_.com.twitter.finagle.Service[self.GetProjectOverviews.Args, self.GetProjectOverviews.SuccessType]
      ): ServicePerEndpoint =
        new ServicePerEndpointImpl(testConnection, storeDataFrame, pathForTransformer, storeFitEvent, storeMetricEvent, getFilePath, storeTransformEvent, storeRandomSplitEvent, storePipelineEvent, storeCrossValidationEvent, storeGridSearchCrossValidationEvent, storeAnnotationEvent, storeProjectEvent, storeExperimentEvent, storeExperimentRunEvent, storeLinearModel, getDataFrameAncestry, getCommonAncestor, getCommonAncestorForModels, getTrainingRowsCount, getTrainingRowsCounts, compareHyperparameters, compareFeatures, groupByProblemType, similarModels, linearModelFeatureImportances, compareLinearModelFeatureImportances, iterationsUntilConvergence, rankModels, confidenceIntervals, modelsWithFeatures, modelsDerivedFromDataFrame, getProjectIds, getModelIds, updateProject, createOrUpdateScalarField, createVectorField, updateVectorField, appendToVectorField, getModel, getRunsInExperiment, getRunsAndExperimentsInProject, getProjectOverviews, getExperimentRunDetails, originalFeatures, storeTreeModel, storePipelineTransformEvent, computeModelAncestry, extractPipeline)

      override def withGetExperimentRunDetails(
        getExperimentRunDetails : _root_.com.twitter.finagle.Service[self.GetExperimentRunDetails.Args, self.GetExperimentRunDetails.SuccessType]
      ): ServicePerEndpoint =
        new ServicePerEndpointImpl(testConnection, storeDataFrame, pathForTransformer, storeFitEvent, storeMetricEvent, getFilePath, storeTransformEvent, storeRandomSplitEvent, storePipelineEvent, storeCrossValidationEvent, storeGridSearchCrossValidationEvent, storeAnnotationEvent, storeProjectEvent, storeExperimentEvent, storeExperimentRunEvent, storeLinearModel, getDataFrameAncestry, getCommonAncestor, getCommonAncestorForModels, getTrainingRowsCount, getTrainingRowsCounts, compareHyperparameters, compareFeatures, groupByProblemType, similarModels, linearModelFeatureImportances, compareLinearModelFeatureImportances, iterationsUntilConvergence, rankModels, confidenceIntervals, modelsWithFeatures, modelsDerivedFromDataFrame, getProjectIds, getModelIds, updateProject, createOrUpdateScalarField, createVectorField, updateVectorField, appendToVectorField, getModel, getRunsInExperiment, getRunsAndExperimentsInProject, getProjectOverviews, getExperimentRunDetails, originalFeatures, storeTreeModel, storePipelineTransformEvent, computeModelAncestry, extractPipeline)

      override def withOriginalFeatures(
        originalFeatures : _root_.com.twitter.finagle.Service[self.OriginalFeatures.Args, self.OriginalFeatures.SuccessType]
      ): ServicePerEndpoint =
        new ServicePerEndpointImpl(testConnection, storeDataFrame, pathForTransformer, storeFitEvent, storeMetricEvent, getFilePath, storeTransformEvent, storeRandomSplitEvent, storePipelineEvent, storeCrossValidationEvent, storeGridSearchCrossValidationEvent, storeAnnotationEvent, storeProjectEvent, storeExperimentEvent, storeExperimentRunEvent, storeLinearModel, getDataFrameAncestry, getCommonAncestor, getCommonAncestorForModels, getTrainingRowsCount, getTrainingRowsCounts, compareHyperparameters, compareFeatures, groupByProblemType, similarModels, linearModelFeatureImportances, compareLinearModelFeatureImportances, iterationsUntilConvergence, rankModels, confidenceIntervals, modelsWithFeatures, modelsDerivedFromDataFrame, getProjectIds, getModelIds, updateProject, createOrUpdateScalarField, createVectorField, updateVectorField, appendToVectorField, getModel, getRunsInExperiment, getRunsAndExperimentsInProject, getProjectOverviews, getExperimentRunDetails, originalFeatures, storeTreeModel, storePipelineTransformEvent, computeModelAncestry, extractPipeline)

      override def withStoreTreeModel(
        storeTreeModel : _root_.com.twitter.finagle.Service[self.StoreTreeModel.Args, self.StoreTreeModel.SuccessType]
      ): ServicePerEndpoint =
        new ServicePerEndpointImpl(testConnection, storeDataFrame, pathForTransformer, storeFitEvent, storeMetricEvent, getFilePath, storeTransformEvent, storeRandomSplitEvent, storePipelineEvent, storeCrossValidationEvent, storeGridSearchCrossValidationEvent, storeAnnotationEvent, storeProjectEvent, storeExperimentEvent, storeExperimentRunEvent, storeLinearModel, getDataFrameAncestry, getCommonAncestor, getCommonAncestorForModels, getTrainingRowsCount, getTrainingRowsCounts, compareHyperparameters, compareFeatures, groupByProblemType, similarModels, linearModelFeatureImportances, compareLinearModelFeatureImportances, iterationsUntilConvergence, rankModels, confidenceIntervals, modelsWithFeatures, modelsDerivedFromDataFrame, getProjectIds, getModelIds, updateProject, createOrUpdateScalarField, createVectorField, updateVectorField, appendToVectorField, getModel, getRunsInExperiment, getRunsAndExperimentsInProject, getProjectOverviews, getExperimentRunDetails, originalFeatures, storeTreeModel, storePipelineTransformEvent, computeModelAncestry, extractPipeline)

      override def withStorePipelineTransformEvent(
        storePipelineTransformEvent : _root_.com.twitter.finagle.Service[self.StorePipelineTransformEvent.Args, self.StorePipelineTransformEvent.SuccessType]
      ): ServicePerEndpoint =
        new ServicePerEndpointImpl(testConnection, storeDataFrame, pathForTransformer, storeFitEvent, storeMetricEvent, getFilePath, storeTransformEvent, storeRandomSplitEvent, storePipelineEvent, storeCrossValidationEvent, storeGridSearchCrossValidationEvent, storeAnnotationEvent, storeProjectEvent, storeExperimentEvent, storeExperimentRunEvent, storeLinearModel, getDataFrameAncestry, getCommonAncestor, getCommonAncestorForModels, getTrainingRowsCount, getTrainingRowsCounts, compareHyperparameters, compareFeatures, groupByProblemType, similarModels, linearModelFeatureImportances, compareLinearModelFeatureImportances, iterationsUntilConvergence, rankModels, confidenceIntervals, modelsWithFeatures, modelsDerivedFromDataFrame, getProjectIds, getModelIds, updateProject, createOrUpdateScalarField, createVectorField, updateVectorField, appendToVectorField, getModel, getRunsInExperiment, getRunsAndExperimentsInProject, getProjectOverviews, getExperimentRunDetails, originalFeatures, storeTreeModel, storePipelineTransformEvent, computeModelAncestry, extractPipeline)

      override def withComputeModelAncestry(
        computeModelAncestry : _root_.com.twitter.finagle.Service[self.ComputeModelAncestry.Args, self.ComputeModelAncestry.SuccessType]
      ): ServicePerEndpoint =
        new ServicePerEndpointImpl(testConnection, storeDataFrame, pathForTransformer, storeFitEvent, storeMetricEvent, getFilePath, storeTransformEvent, storeRandomSplitEvent, storePipelineEvent, storeCrossValidationEvent, storeGridSearchCrossValidationEvent, storeAnnotationEvent, storeProjectEvent, storeExperimentEvent, storeExperimentRunEvent, storeLinearModel, getDataFrameAncestry, getCommonAncestor, getCommonAncestorForModels, getTrainingRowsCount, getTrainingRowsCounts, compareHyperparameters, compareFeatures, groupByProblemType, similarModels, linearModelFeatureImportances, compareLinearModelFeatureImportances, iterationsUntilConvergence, rankModels, confidenceIntervals, modelsWithFeatures, modelsDerivedFromDataFrame, getProjectIds, getModelIds, updateProject, createOrUpdateScalarField, createVectorField, updateVectorField, appendToVectorField, getModel, getRunsInExperiment, getRunsAndExperimentsInProject, getProjectOverviews, getExperimentRunDetails, originalFeatures, storeTreeModel, storePipelineTransformEvent, computeModelAncestry, extractPipeline)

      override def withExtractPipeline(
        extractPipeline : _root_.com.twitter.finagle.Service[self.ExtractPipeline.Args, self.ExtractPipeline.SuccessType]
      ): ServicePerEndpoint =
        new ServicePerEndpointImpl(testConnection, storeDataFrame, pathForTransformer, storeFitEvent, storeMetricEvent, getFilePath, storeTransformEvent, storeRandomSplitEvent, storePipelineEvent, storeCrossValidationEvent, storeGridSearchCrossValidationEvent, storeAnnotationEvent, storeProjectEvent, storeExperimentEvent, storeExperimentRunEvent, storeLinearModel, getDataFrameAncestry, getCommonAncestor, getCommonAncestorForModels, getTrainingRowsCount, getTrainingRowsCounts, compareHyperparameters, compareFeatures, groupByProblemType, similarModels, linearModelFeatureImportances, compareLinearModelFeatureImportances, iterationsUntilConvergence, rankModels, confidenceIntervals, modelsWithFeatures, modelsDerivedFromDataFrame, getProjectIds, getModelIds, updateProject, createOrUpdateScalarField, createVectorField, updateVectorField, appendToVectorField, getModel, getRunsInExperiment, getRunsAndExperimentsInProject, getProjectOverviews, getExperimentRunDetails, originalFeatures, storeTreeModel, storePipelineTransformEvent, computeModelAncestry, extractPipeline)

      override def filtered(filter: _root_.com.twitter.finagle.Filter.TypeAgnostic): ServicePerEndpoint =
        new ServicePerEndpointImpl(
          testConnection = filter.toFilter.andThen(testConnection),
          storeDataFrame = filter.toFilter.andThen(storeDataFrame),
          pathForTransformer = filter.toFilter.andThen(pathForTransformer),
          storeFitEvent = filter.toFilter.andThen(storeFitEvent),
          storeMetricEvent = filter.toFilter.andThen(storeMetricEvent),
          getFilePath = filter.toFilter.andThen(getFilePath),
          storeTransformEvent = filter.toFilter.andThen(storeTransformEvent),
          storeRandomSplitEvent = filter.toFilter.andThen(storeRandomSplitEvent),
          storePipelineEvent = filter.toFilter.andThen(storePipelineEvent),
          storeCrossValidationEvent = filter.toFilter.andThen(storeCrossValidationEvent),
          storeGridSearchCrossValidationEvent = filter.toFilter.andThen(storeGridSearchCrossValidationEvent),
          storeAnnotationEvent = filter.toFilter.andThen(storeAnnotationEvent),
          storeProjectEvent = filter.toFilter.andThen(storeProjectEvent),
          storeExperimentEvent = filter.toFilter.andThen(storeExperimentEvent),
          storeExperimentRunEvent = filter.toFilter.andThen(storeExperimentRunEvent),
          storeLinearModel = filter.toFilter.andThen(storeLinearModel),
          getDataFrameAncestry = filter.toFilter.andThen(getDataFrameAncestry),
          getCommonAncestor = filter.toFilter.andThen(getCommonAncestor),
          getCommonAncestorForModels = filter.toFilter.andThen(getCommonAncestorForModels),
          getTrainingRowsCount = filter.toFilter.andThen(getTrainingRowsCount),
          getTrainingRowsCounts = filter.toFilter.andThen(getTrainingRowsCounts),
          compareHyperparameters = filter.toFilter.andThen(compareHyperparameters),
          compareFeatures = filter.toFilter.andThen(compareFeatures),
          groupByProblemType = filter.toFilter.andThen(groupByProblemType),
          similarModels = filter.toFilter.andThen(similarModels),
          linearModelFeatureImportances = filter.toFilter.andThen(linearModelFeatureImportances),
          compareLinearModelFeatureImportances = filter.toFilter.andThen(compareLinearModelFeatureImportances),
          iterationsUntilConvergence = filter.toFilter.andThen(iterationsUntilConvergence),
          rankModels = filter.toFilter.andThen(rankModels),
          confidenceIntervals = filter.toFilter.andThen(confidenceIntervals),
          modelsWithFeatures = filter.toFilter.andThen(modelsWithFeatures),
          modelsDerivedFromDataFrame = filter.toFilter.andThen(modelsDerivedFromDataFrame),
          getProjectIds = filter.toFilter.andThen(getProjectIds),
          getModelIds = filter.toFilter.andThen(getModelIds),
          updateProject = filter.toFilter.andThen(updateProject),
          createOrUpdateScalarField = filter.toFilter.andThen(createOrUpdateScalarField),
          createVectorField = filter.toFilter.andThen(createVectorField),
          updateVectorField = filter.toFilter.andThen(updateVectorField),
          appendToVectorField = filter.toFilter.andThen(appendToVectorField),
          getModel = filter.toFilter.andThen(getModel),
          getRunsInExperiment = filter.toFilter.andThen(getRunsInExperiment),
          getRunsAndExperimentsInProject = filter.toFilter.andThen(getRunsAndExperimentsInProject),
          getProjectOverviews = filter.toFilter.andThen(getProjectOverviews),
          getExperimentRunDetails = filter.toFilter.andThen(getExperimentRunDetails),
          originalFeatures = filter.toFilter.andThen(originalFeatures),
          storeTreeModel = filter.toFilter.andThen(storeTreeModel),
          storePipelineTransformEvent = filter.toFilter.andThen(storePipelineTransformEvent),
          computeModelAncestry = filter.toFilter.andThen(computeModelAncestry),
          extractPipeline = filter.toFilter.andThen(extractPipeline)
        )

      override def asClosable: _root_.com.twitter.util.Closable =
        _root_.com.twitter.util.Closable.all(
          this.testConnection,
          this.storeDataFrame,
          this.pathForTransformer,
          this.storeFitEvent,
          this.storeMetricEvent,
          this.getFilePath,
          this.storeTransformEvent,
          this.storeRandomSplitEvent,
          this.storePipelineEvent,
          this.storeCrossValidationEvent,
          this.storeGridSearchCrossValidationEvent,
          this.storeAnnotationEvent,
          this.storeProjectEvent,
          this.storeExperimentEvent,
          this.storeExperimentRunEvent,
          this.storeLinearModel,
          this.getDataFrameAncestry,
          this.getCommonAncestor,
          this.getCommonAncestorForModels,
          this.getTrainingRowsCount,
          this.getTrainingRowsCounts,
          this.compareHyperparameters,
          this.compareFeatures,
          this.groupByProblemType,
          this.similarModels,
          this.linearModelFeatureImportances,
          this.compareLinearModelFeatureImportances,
          this.iterationsUntilConvergence,
          this.rankModels,
          this.confidenceIntervals,
          this.modelsWithFeatures,
          this.modelsDerivedFromDataFrame,
          this.getProjectIds,
          this.getModelIds,
          this.updateProject,
          this.createOrUpdateScalarField,
          this.createVectorField,
          this.updateVectorField,
          this.appendToVectorField,
          this.getModel,
          this.getRunsInExperiment,
          this.getRunsAndExperimentsInProject,
          this.getProjectOverviews,
          this.getExperimentRunDetails,
          this.originalFeatures,
          this.storeTreeModel,
          this.storePipelineTransformEvent,
          this.computeModelAncestry,
          this.extractPipeline
        )
    }
  }

  object ReqRepServicePerEndpoint {

    def apply(
      testConnection :  _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.TestConnection.Args], _root_.com.twitter.scrooge.Response[self.TestConnection.SuccessType]],
      storeDataFrame :  _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.StoreDataFrame.Args], _root_.com.twitter.scrooge.Response[self.StoreDataFrame.SuccessType]],
      pathForTransformer :  _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.PathForTransformer.Args], _root_.com.twitter.scrooge.Response[self.PathForTransformer.SuccessType]],
      storeFitEvent :  _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.StoreFitEvent.Args], _root_.com.twitter.scrooge.Response[self.StoreFitEvent.SuccessType]],
      storeMetricEvent :  _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.StoreMetricEvent.Args], _root_.com.twitter.scrooge.Response[self.StoreMetricEvent.SuccessType]],
      getFilePath :  _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.GetFilePath.Args], _root_.com.twitter.scrooge.Response[self.GetFilePath.SuccessType]],
      storeTransformEvent :  _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.StoreTransformEvent.Args], _root_.com.twitter.scrooge.Response[self.StoreTransformEvent.SuccessType]],
      storeRandomSplitEvent :  _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.StoreRandomSplitEvent.Args], _root_.com.twitter.scrooge.Response[self.StoreRandomSplitEvent.SuccessType]],
      storePipelineEvent :  _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.StorePipelineEvent.Args], _root_.com.twitter.scrooge.Response[self.StorePipelineEvent.SuccessType]],
      storeCrossValidationEvent :  _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.StoreCrossValidationEvent.Args], _root_.com.twitter.scrooge.Response[self.StoreCrossValidationEvent.SuccessType]],
      storeGridSearchCrossValidationEvent :  _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.StoreGridSearchCrossValidationEvent.Args], _root_.com.twitter.scrooge.Response[self.StoreGridSearchCrossValidationEvent.SuccessType]],
      storeAnnotationEvent :  _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.StoreAnnotationEvent.Args], _root_.com.twitter.scrooge.Response[self.StoreAnnotationEvent.SuccessType]],
      storeProjectEvent :  _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.StoreProjectEvent.Args], _root_.com.twitter.scrooge.Response[self.StoreProjectEvent.SuccessType]],
      storeExperimentEvent :  _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.StoreExperimentEvent.Args], _root_.com.twitter.scrooge.Response[self.StoreExperimentEvent.SuccessType]],
      storeExperimentRunEvent :  _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.StoreExperimentRunEvent.Args], _root_.com.twitter.scrooge.Response[self.StoreExperimentRunEvent.SuccessType]],
      storeLinearModel :  _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.StoreLinearModel.Args], _root_.com.twitter.scrooge.Response[self.StoreLinearModel.SuccessType]],
      getDataFrameAncestry :  _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.GetDataFrameAncestry.Args], _root_.com.twitter.scrooge.Response[self.GetDataFrameAncestry.SuccessType]],
      getCommonAncestor :  _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.GetCommonAncestor.Args], _root_.com.twitter.scrooge.Response[self.GetCommonAncestor.SuccessType]],
      getCommonAncestorForModels :  _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.GetCommonAncestorForModels.Args], _root_.com.twitter.scrooge.Response[self.GetCommonAncestorForModels.SuccessType]],
      getTrainingRowsCount :  _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.GetTrainingRowsCount.Args], _root_.com.twitter.scrooge.Response[self.GetTrainingRowsCount.SuccessType]],
      getTrainingRowsCounts :  _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.GetTrainingRowsCounts.Args], _root_.com.twitter.scrooge.Response[self.GetTrainingRowsCounts.SuccessType]],
      compareHyperparameters :  _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.CompareHyperparameters.Args], _root_.com.twitter.scrooge.Response[self.CompareHyperparameters.SuccessType]],
      compareFeatures :  _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.CompareFeatures.Args], _root_.com.twitter.scrooge.Response[self.CompareFeatures.SuccessType]],
      groupByProblemType :  _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.GroupByProblemType.Args], _root_.com.twitter.scrooge.Response[self.GroupByProblemType.SuccessType]],
      similarModels :  _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.SimilarModels.Args], _root_.com.twitter.scrooge.Response[self.SimilarModels.SuccessType]],
      linearModelFeatureImportances :  _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.LinearModelFeatureImportances.Args], _root_.com.twitter.scrooge.Response[self.LinearModelFeatureImportances.SuccessType]],
      compareLinearModelFeatureImportances :  _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.CompareLinearModelFeatureImportances.Args], _root_.com.twitter.scrooge.Response[self.CompareLinearModelFeatureImportances.SuccessType]],
      iterationsUntilConvergence :  _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.IterationsUntilConvergence.Args], _root_.com.twitter.scrooge.Response[self.IterationsUntilConvergence.SuccessType]],
      rankModels :  _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.RankModels.Args], _root_.com.twitter.scrooge.Response[self.RankModels.SuccessType]],
      confidenceIntervals :  _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.ConfidenceIntervals.Args], _root_.com.twitter.scrooge.Response[self.ConfidenceIntervals.SuccessType]],
      modelsWithFeatures :  _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.ModelsWithFeatures.Args], _root_.com.twitter.scrooge.Response[self.ModelsWithFeatures.SuccessType]],
      modelsDerivedFromDataFrame :  _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.ModelsDerivedFromDataFrame.Args], _root_.com.twitter.scrooge.Response[self.ModelsDerivedFromDataFrame.SuccessType]],
      getProjectIds :  _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.GetProjectIds.Args], _root_.com.twitter.scrooge.Response[self.GetProjectIds.SuccessType]],
      getModelIds :  _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.GetModelIds.Args], _root_.com.twitter.scrooge.Response[self.GetModelIds.SuccessType]],
      updateProject :  _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.UpdateProject.Args], _root_.com.twitter.scrooge.Response[self.UpdateProject.SuccessType]],
      createOrUpdateScalarField :  _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.CreateOrUpdateScalarField.Args], _root_.com.twitter.scrooge.Response[self.CreateOrUpdateScalarField.SuccessType]],
      createVectorField :  _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.CreateVectorField.Args], _root_.com.twitter.scrooge.Response[self.CreateVectorField.SuccessType]],
      updateVectorField :  _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.UpdateVectorField.Args], _root_.com.twitter.scrooge.Response[self.UpdateVectorField.SuccessType]],
      appendToVectorField :  _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.AppendToVectorField.Args], _root_.com.twitter.scrooge.Response[self.AppendToVectorField.SuccessType]],
      getModel :  _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.GetModel.Args], _root_.com.twitter.scrooge.Response[self.GetModel.SuccessType]],
      getRunsInExperiment :  _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.GetRunsInExperiment.Args], _root_.com.twitter.scrooge.Response[self.GetRunsInExperiment.SuccessType]],
      getRunsAndExperimentsInProject :  _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.GetRunsAndExperimentsInProject.Args], _root_.com.twitter.scrooge.Response[self.GetRunsAndExperimentsInProject.SuccessType]],
      getProjectOverviews :  _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.GetProjectOverviews.Args], _root_.com.twitter.scrooge.Response[self.GetProjectOverviews.SuccessType]],
      getExperimentRunDetails :  _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.GetExperimentRunDetails.Args], _root_.com.twitter.scrooge.Response[self.GetExperimentRunDetails.SuccessType]],
      originalFeatures :  _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.OriginalFeatures.Args], _root_.com.twitter.scrooge.Response[self.OriginalFeatures.SuccessType]],
      storeTreeModel :  _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.StoreTreeModel.Args], _root_.com.twitter.scrooge.Response[self.StoreTreeModel.SuccessType]],
      storePipelineTransformEvent :  _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.StorePipelineTransformEvent.Args], _root_.com.twitter.scrooge.Response[self.StorePipelineTransformEvent.SuccessType]],
      computeModelAncestry :  _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.ComputeModelAncestry.Args], _root_.com.twitter.scrooge.Response[self.ComputeModelAncestry.SuccessType]],
      extractPipeline :  _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.ExtractPipeline.Args], _root_.com.twitter.scrooge.Response[self.ExtractPipeline.SuccessType]]
    ): ReqRepServicePerEndpoint =
      new ReqRepServicePerEndpointImpl(testConnection, storeDataFrame, pathForTransformer, storeFitEvent, storeMetricEvent, getFilePath, storeTransformEvent, storeRandomSplitEvent, storePipelineEvent, storeCrossValidationEvent, storeGridSearchCrossValidationEvent, storeAnnotationEvent, storeProjectEvent, storeExperimentEvent, storeExperimentRunEvent, storeLinearModel, getDataFrameAncestry, getCommonAncestor, getCommonAncestorForModels, getTrainingRowsCount, getTrainingRowsCounts, compareHyperparameters, compareFeatures, groupByProblemType, similarModels, linearModelFeatureImportances, compareLinearModelFeatureImportances, iterationsUntilConvergence, rankModels, confidenceIntervals, modelsWithFeatures, modelsDerivedFromDataFrame, getProjectIds, getModelIds, updateProject, createOrUpdateScalarField, createVectorField, updateVectorField, appendToVectorField, getModel, getRunsInExperiment, getRunsAndExperimentsInProject, getProjectOverviews, getExperimentRunDetails, originalFeatures, storeTreeModel, storePipelineTransformEvent, computeModelAncestry, extractPipeline)

    private final class ReqRepServicePerEndpointImpl(
      override val testConnection : _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.TestConnection.Args], _root_.com.twitter.scrooge.Response[self.TestConnection.SuccessType]],
      override val storeDataFrame : _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.StoreDataFrame.Args], _root_.com.twitter.scrooge.Response[self.StoreDataFrame.SuccessType]],
      override val pathForTransformer : _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.PathForTransformer.Args], _root_.com.twitter.scrooge.Response[self.PathForTransformer.SuccessType]],
      override val storeFitEvent : _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.StoreFitEvent.Args], _root_.com.twitter.scrooge.Response[self.StoreFitEvent.SuccessType]],
      override val storeMetricEvent : _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.StoreMetricEvent.Args], _root_.com.twitter.scrooge.Response[self.StoreMetricEvent.SuccessType]],
      override val getFilePath : _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.GetFilePath.Args], _root_.com.twitter.scrooge.Response[self.GetFilePath.SuccessType]],
      override val storeTransformEvent : _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.StoreTransformEvent.Args], _root_.com.twitter.scrooge.Response[self.StoreTransformEvent.SuccessType]],
      override val storeRandomSplitEvent : _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.StoreRandomSplitEvent.Args], _root_.com.twitter.scrooge.Response[self.StoreRandomSplitEvent.SuccessType]],
      override val storePipelineEvent : _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.StorePipelineEvent.Args], _root_.com.twitter.scrooge.Response[self.StorePipelineEvent.SuccessType]],
      override val storeCrossValidationEvent : _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.StoreCrossValidationEvent.Args], _root_.com.twitter.scrooge.Response[self.StoreCrossValidationEvent.SuccessType]],
      override val storeGridSearchCrossValidationEvent : _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.StoreGridSearchCrossValidationEvent.Args], _root_.com.twitter.scrooge.Response[self.StoreGridSearchCrossValidationEvent.SuccessType]],
      override val storeAnnotationEvent : _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.StoreAnnotationEvent.Args], _root_.com.twitter.scrooge.Response[self.StoreAnnotationEvent.SuccessType]],
      override val storeProjectEvent : _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.StoreProjectEvent.Args], _root_.com.twitter.scrooge.Response[self.StoreProjectEvent.SuccessType]],
      override val storeExperimentEvent : _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.StoreExperimentEvent.Args], _root_.com.twitter.scrooge.Response[self.StoreExperimentEvent.SuccessType]],
      override val storeExperimentRunEvent : _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.StoreExperimentRunEvent.Args], _root_.com.twitter.scrooge.Response[self.StoreExperimentRunEvent.SuccessType]],
      override val storeLinearModel : _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.StoreLinearModel.Args], _root_.com.twitter.scrooge.Response[self.StoreLinearModel.SuccessType]],
      override val getDataFrameAncestry : _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.GetDataFrameAncestry.Args], _root_.com.twitter.scrooge.Response[self.GetDataFrameAncestry.SuccessType]],
      override val getCommonAncestor : _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.GetCommonAncestor.Args], _root_.com.twitter.scrooge.Response[self.GetCommonAncestor.SuccessType]],
      override val getCommonAncestorForModels : _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.GetCommonAncestorForModels.Args], _root_.com.twitter.scrooge.Response[self.GetCommonAncestorForModels.SuccessType]],
      override val getTrainingRowsCount : _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.GetTrainingRowsCount.Args], _root_.com.twitter.scrooge.Response[self.GetTrainingRowsCount.SuccessType]],
      override val getTrainingRowsCounts : _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.GetTrainingRowsCounts.Args], _root_.com.twitter.scrooge.Response[self.GetTrainingRowsCounts.SuccessType]],
      override val compareHyperparameters : _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.CompareHyperparameters.Args], _root_.com.twitter.scrooge.Response[self.CompareHyperparameters.SuccessType]],
      override val compareFeatures : _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.CompareFeatures.Args], _root_.com.twitter.scrooge.Response[self.CompareFeatures.SuccessType]],
      override val groupByProblemType : _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.GroupByProblemType.Args], _root_.com.twitter.scrooge.Response[self.GroupByProblemType.SuccessType]],
      override val similarModels : _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.SimilarModels.Args], _root_.com.twitter.scrooge.Response[self.SimilarModels.SuccessType]],
      override val linearModelFeatureImportances : _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.LinearModelFeatureImportances.Args], _root_.com.twitter.scrooge.Response[self.LinearModelFeatureImportances.SuccessType]],
      override val compareLinearModelFeatureImportances : _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.CompareLinearModelFeatureImportances.Args], _root_.com.twitter.scrooge.Response[self.CompareLinearModelFeatureImportances.SuccessType]],
      override val iterationsUntilConvergence : _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.IterationsUntilConvergence.Args], _root_.com.twitter.scrooge.Response[self.IterationsUntilConvergence.SuccessType]],
      override val rankModels : _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.RankModels.Args], _root_.com.twitter.scrooge.Response[self.RankModels.SuccessType]],
      override val confidenceIntervals : _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.ConfidenceIntervals.Args], _root_.com.twitter.scrooge.Response[self.ConfidenceIntervals.SuccessType]],
      override val modelsWithFeatures : _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.ModelsWithFeatures.Args], _root_.com.twitter.scrooge.Response[self.ModelsWithFeatures.SuccessType]],
      override val modelsDerivedFromDataFrame : _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.ModelsDerivedFromDataFrame.Args], _root_.com.twitter.scrooge.Response[self.ModelsDerivedFromDataFrame.SuccessType]],
      override val getProjectIds : _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.GetProjectIds.Args], _root_.com.twitter.scrooge.Response[self.GetProjectIds.SuccessType]],
      override val getModelIds : _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.GetModelIds.Args], _root_.com.twitter.scrooge.Response[self.GetModelIds.SuccessType]],
      override val updateProject : _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.UpdateProject.Args], _root_.com.twitter.scrooge.Response[self.UpdateProject.SuccessType]],
      override val createOrUpdateScalarField : _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.CreateOrUpdateScalarField.Args], _root_.com.twitter.scrooge.Response[self.CreateOrUpdateScalarField.SuccessType]],
      override val createVectorField : _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.CreateVectorField.Args], _root_.com.twitter.scrooge.Response[self.CreateVectorField.SuccessType]],
      override val updateVectorField : _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.UpdateVectorField.Args], _root_.com.twitter.scrooge.Response[self.UpdateVectorField.SuccessType]],
      override val appendToVectorField : _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.AppendToVectorField.Args], _root_.com.twitter.scrooge.Response[self.AppendToVectorField.SuccessType]],
      override val getModel : _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.GetModel.Args], _root_.com.twitter.scrooge.Response[self.GetModel.SuccessType]],
      override val getRunsInExperiment : _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.GetRunsInExperiment.Args], _root_.com.twitter.scrooge.Response[self.GetRunsInExperiment.SuccessType]],
      override val getRunsAndExperimentsInProject : _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.GetRunsAndExperimentsInProject.Args], _root_.com.twitter.scrooge.Response[self.GetRunsAndExperimentsInProject.SuccessType]],
      override val getProjectOverviews : _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.GetProjectOverviews.Args], _root_.com.twitter.scrooge.Response[self.GetProjectOverviews.SuccessType]],
      override val getExperimentRunDetails : _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.GetExperimentRunDetails.Args], _root_.com.twitter.scrooge.Response[self.GetExperimentRunDetails.SuccessType]],
      override val originalFeatures : _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.OriginalFeatures.Args], _root_.com.twitter.scrooge.Response[self.OriginalFeatures.SuccessType]],
      override val storeTreeModel : _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.StoreTreeModel.Args], _root_.com.twitter.scrooge.Response[self.StoreTreeModel.SuccessType]],
      override val storePipelineTransformEvent : _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.StorePipelineTransformEvent.Args], _root_.com.twitter.scrooge.Response[self.StorePipelineTransformEvent.SuccessType]],
      override val computeModelAncestry : _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.ComputeModelAncestry.Args], _root_.com.twitter.scrooge.Response[self.ComputeModelAncestry.SuccessType]],
      override val extractPipeline : _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[self.ExtractPipeline.Args], _root_.com.twitter.scrooge.Response[self.ExtractPipeline.SuccessType]]
    ) extends ReqRepServicePerEndpoint {

      override def withTestConnection(
        testConnection : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.TestConnection.Args], _root_.com.twitter.scrooge.Response[self.TestConnection.SuccessType]]
      ): ReqRepServicePerEndpoint =
        new ReqRepServicePerEndpointImpl(testConnection, storeDataFrame, pathForTransformer, storeFitEvent, storeMetricEvent, getFilePath, storeTransformEvent, storeRandomSplitEvent, storePipelineEvent, storeCrossValidationEvent, storeGridSearchCrossValidationEvent, storeAnnotationEvent, storeProjectEvent, storeExperimentEvent, storeExperimentRunEvent, storeLinearModel, getDataFrameAncestry, getCommonAncestor, getCommonAncestorForModels, getTrainingRowsCount, getTrainingRowsCounts, compareHyperparameters, compareFeatures, groupByProblemType, similarModels, linearModelFeatureImportances, compareLinearModelFeatureImportances, iterationsUntilConvergence, rankModels, confidenceIntervals, modelsWithFeatures, modelsDerivedFromDataFrame, getProjectIds, getModelIds, updateProject, createOrUpdateScalarField, createVectorField, updateVectorField, appendToVectorField, getModel, getRunsInExperiment, getRunsAndExperimentsInProject, getProjectOverviews, getExperimentRunDetails, originalFeatures, storeTreeModel, storePipelineTransformEvent, computeModelAncestry, extractPipeline)
      override def withStoreDataFrame(
        storeDataFrame : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.StoreDataFrame.Args], _root_.com.twitter.scrooge.Response[self.StoreDataFrame.SuccessType]]
      ): ReqRepServicePerEndpoint =
        new ReqRepServicePerEndpointImpl(testConnection, storeDataFrame, pathForTransformer, storeFitEvent, storeMetricEvent, getFilePath, storeTransformEvent, storeRandomSplitEvent, storePipelineEvent, storeCrossValidationEvent, storeGridSearchCrossValidationEvent, storeAnnotationEvent, storeProjectEvent, storeExperimentEvent, storeExperimentRunEvent, storeLinearModel, getDataFrameAncestry, getCommonAncestor, getCommonAncestorForModels, getTrainingRowsCount, getTrainingRowsCounts, compareHyperparameters, compareFeatures, groupByProblemType, similarModels, linearModelFeatureImportances, compareLinearModelFeatureImportances, iterationsUntilConvergence, rankModels, confidenceIntervals, modelsWithFeatures, modelsDerivedFromDataFrame, getProjectIds, getModelIds, updateProject, createOrUpdateScalarField, createVectorField, updateVectorField, appendToVectorField, getModel, getRunsInExperiment, getRunsAndExperimentsInProject, getProjectOverviews, getExperimentRunDetails, originalFeatures, storeTreeModel, storePipelineTransformEvent, computeModelAncestry, extractPipeline)
      override def withPathForTransformer(
        pathForTransformer : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.PathForTransformer.Args], _root_.com.twitter.scrooge.Response[self.PathForTransformer.SuccessType]]
      ): ReqRepServicePerEndpoint =
        new ReqRepServicePerEndpointImpl(testConnection, storeDataFrame, pathForTransformer, storeFitEvent, storeMetricEvent, getFilePath, storeTransformEvent, storeRandomSplitEvent, storePipelineEvent, storeCrossValidationEvent, storeGridSearchCrossValidationEvent, storeAnnotationEvent, storeProjectEvent, storeExperimentEvent, storeExperimentRunEvent, storeLinearModel, getDataFrameAncestry, getCommonAncestor, getCommonAncestorForModels, getTrainingRowsCount, getTrainingRowsCounts, compareHyperparameters, compareFeatures, groupByProblemType, similarModels, linearModelFeatureImportances, compareLinearModelFeatureImportances, iterationsUntilConvergence, rankModels, confidenceIntervals, modelsWithFeatures, modelsDerivedFromDataFrame, getProjectIds, getModelIds, updateProject, createOrUpdateScalarField, createVectorField, updateVectorField, appendToVectorField, getModel, getRunsInExperiment, getRunsAndExperimentsInProject, getProjectOverviews, getExperimentRunDetails, originalFeatures, storeTreeModel, storePipelineTransformEvent, computeModelAncestry, extractPipeline)
      override def withStoreFitEvent(
        storeFitEvent : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.StoreFitEvent.Args], _root_.com.twitter.scrooge.Response[self.StoreFitEvent.SuccessType]]
      ): ReqRepServicePerEndpoint =
        new ReqRepServicePerEndpointImpl(testConnection, storeDataFrame, pathForTransformer, storeFitEvent, storeMetricEvent, getFilePath, storeTransformEvent, storeRandomSplitEvent, storePipelineEvent, storeCrossValidationEvent, storeGridSearchCrossValidationEvent, storeAnnotationEvent, storeProjectEvent, storeExperimentEvent, storeExperimentRunEvent, storeLinearModel, getDataFrameAncestry, getCommonAncestor, getCommonAncestorForModels, getTrainingRowsCount, getTrainingRowsCounts, compareHyperparameters, compareFeatures, groupByProblemType, similarModels, linearModelFeatureImportances, compareLinearModelFeatureImportances, iterationsUntilConvergence, rankModels, confidenceIntervals, modelsWithFeatures, modelsDerivedFromDataFrame, getProjectIds, getModelIds, updateProject, createOrUpdateScalarField, createVectorField, updateVectorField, appendToVectorField, getModel, getRunsInExperiment, getRunsAndExperimentsInProject, getProjectOverviews, getExperimentRunDetails, originalFeatures, storeTreeModel, storePipelineTransformEvent, computeModelAncestry, extractPipeline)
      override def withStoreMetricEvent(
        storeMetricEvent : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.StoreMetricEvent.Args], _root_.com.twitter.scrooge.Response[self.StoreMetricEvent.SuccessType]]
      ): ReqRepServicePerEndpoint =
        new ReqRepServicePerEndpointImpl(testConnection, storeDataFrame, pathForTransformer, storeFitEvent, storeMetricEvent, getFilePath, storeTransformEvent, storeRandomSplitEvent, storePipelineEvent, storeCrossValidationEvent, storeGridSearchCrossValidationEvent, storeAnnotationEvent, storeProjectEvent, storeExperimentEvent, storeExperimentRunEvent, storeLinearModel, getDataFrameAncestry, getCommonAncestor, getCommonAncestorForModels, getTrainingRowsCount, getTrainingRowsCounts, compareHyperparameters, compareFeatures, groupByProblemType, similarModels, linearModelFeatureImportances, compareLinearModelFeatureImportances, iterationsUntilConvergence, rankModels, confidenceIntervals, modelsWithFeatures, modelsDerivedFromDataFrame, getProjectIds, getModelIds, updateProject, createOrUpdateScalarField, createVectorField, updateVectorField, appendToVectorField, getModel, getRunsInExperiment, getRunsAndExperimentsInProject, getProjectOverviews, getExperimentRunDetails, originalFeatures, storeTreeModel, storePipelineTransformEvent, computeModelAncestry, extractPipeline)
      override def withGetFilePath(
        getFilePath : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.GetFilePath.Args], _root_.com.twitter.scrooge.Response[self.GetFilePath.SuccessType]]
      ): ReqRepServicePerEndpoint =
        new ReqRepServicePerEndpointImpl(testConnection, storeDataFrame, pathForTransformer, storeFitEvent, storeMetricEvent, getFilePath, storeTransformEvent, storeRandomSplitEvent, storePipelineEvent, storeCrossValidationEvent, storeGridSearchCrossValidationEvent, storeAnnotationEvent, storeProjectEvent, storeExperimentEvent, storeExperimentRunEvent, storeLinearModel, getDataFrameAncestry, getCommonAncestor, getCommonAncestorForModels, getTrainingRowsCount, getTrainingRowsCounts, compareHyperparameters, compareFeatures, groupByProblemType, similarModels, linearModelFeatureImportances, compareLinearModelFeatureImportances, iterationsUntilConvergence, rankModels, confidenceIntervals, modelsWithFeatures, modelsDerivedFromDataFrame, getProjectIds, getModelIds, updateProject, createOrUpdateScalarField, createVectorField, updateVectorField, appendToVectorField, getModel, getRunsInExperiment, getRunsAndExperimentsInProject, getProjectOverviews, getExperimentRunDetails, originalFeatures, storeTreeModel, storePipelineTransformEvent, computeModelAncestry, extractPipeline)
      override def withStoreTransformEvent(
        storeTransformEvent : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.StoreTransformEvent.Args], _root_.com.twitter.scrooge.Response[self.StoreTransformEvent.SuccessType]]
      ): ReqRepServicePerEndpoint =
        new ReqRepServicePerEndpointImpl(testConnection, storeDataFrame, pathForTransformer, storeFitEvent, storeMetricEvent, getFilePath, storeTransformEvent, storeRandomSplitEvent, storePipelineEvent, storeCrossValidationEvent, storeGridSearchCrossValidationEvent, storeAnnotationEvent, storeProjectEvent, storeExperimentEvent, storeExperimentRunEvent, storeLinearModel, getDataFrameAncestry, getCommonAncestor, getCommonAncestorForModels, getTrainingRowsCount, getTrainingRowsCounts, compareHyperparameters, compareFeatures, groupByProblemType, similarModels, linearModelFeatureImportances, compareLinearModelFeatureImportances, iterationsUntilConvergence, rankModels, confidenceIntervals, modelsWithFeatures, modelsDerivedFromDataFrame, getProjectIds, getModelIds, updateProject, createOrUpdateScalarField, createVectorField, updateVectorField, appendToVectorField, getModel, getRunsInExperiment, getRunsAndExperimentsInProject, getProjectOverviews, getExperimentRunDetails, originalFeatures, storeTreeModel, storePipelineTransformEvent, computeModelAncestry, extractPipeline)
      override def withStoreRandomSplitEvent(
        storeRandomSplitEvent : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.StoreRandomSplitEvent.Args], _root_.com.twitter.scrooge.Response[self.StoreRandomSplitEvent.SuccessType]]
      ): ReqRepServicePerEndpoint =
        new ReqRepServicePerEndpointImpl(testConnection, storeDataFrame, pathForTransformer, storeFitEvent, storeMetricEvent, getFilePath, storeTransformEvent, storeRandomSplitEvent, storePipelineEvent, storeCrossValidationEvent, storeGridSearchCrossValidationEvent, storeAnnotationEvent, storeProjectEvent, storeExperimentEvent, storeExperimentRunEvent, storeLinearModel, getDataFrameAncestry, getCommonAncestor, getCommonAncestorForModels, getTrainingRowsCount, getTrainingRowsCounts, compareHyperparameters, compareFeatures, groupByProblemType, similarModels, linearModelFeatureImportances, compareLinearModelFeatureImportances, iterationsUntilConvergence, rankModels, confidenceIntervals, modelsWithFeatures, modelsDerivedFromDataFrame, getProjectIds, getModelIds, updateProject, createOrUpdateScalarField, createVectorField, updateVectorField, appendToVectorField, getModel, getRunsInExperiment, getRunsAndExperimentsInProject, getProjectOverviews, getExperimentRunDetails, originalFeatures, storeTreeModel, storePipelineTransformEvent, computeModelAncestry, extractPipeline)
      override def withStorePipelineEvent(
        storePipelineEvent : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.StorePipelineEvent.Args], _root_.com.twitter.scrooge.Response[self.StorePipelineEvent.SuccessType]]
      ): ReqRepServicePerEndpoint =
        new ReqRepServicePerEndpointImpl(testConnection, storeDataFrame, pathForTransformer, storeFitEvent, storeMetricEvent, getFilePath, storeTransformEvent, storeRandomSplitEvent, storePipelineEvent, storeCrossValidationEvent, storeGridSearchCrossValidationEvent, storeAnnotationEvent, storeProjectEvent, storeExperimentEvent, storeExperimentRunEvent, storeLinearModel, getDataFrameAncestry, getCommonAncestor, getCommonAncestorForModels, getTrainingRowsCount, getTrainingRowsCounts, compareHyperparameters, compareFeatures, groupByProblemType, similarModels, linearModelFeatureImportances, compareLinearModelFeatureImportances, iterationsUntilConvergence, rankModels, confidenceIntervals, modelsWithFeatures, modelsDerivedFromDataFrame, getProjectIds, getModelIds, updateProject, createOrUpdateScalarField, createVectorField, updateVectorField, appendToVectorField, getModel, getRunsInExperiment, getRunsAndExperimentsInProject, getProjectOverviews, getExperimentRunDetails, originalFeatures, storeTreeModel, storePipelineTransformEvent, computeModelAncestry, extractPipeline)
      override def withStoreCrossValidationEvent(
        storeCrossValidationEvent : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.StoreCrossValidationEvent.Args], _root_.com.twitter.scrooge.Response[self.StoreCrossValidationEvent.SuccessType]]
      ): ReqRepServicePerEndpoint =
        new ReqRepServicePerEndpointImpl(testConnection, storeDataFrame, pathForTransformer, storeFitEvent, storeMetricEvent, getFilePath, storeTransformEvent, storeRandomSplitEvent, storePipelineEvent, storeCrossValidationEvent, storeGridSearchCrossValidationEvent, storeAnnotationEvent, storeProjectEvent, storeExperimentEvent, storeExperimentRunEvent, storeLinearModel, getDataFrameAncestry, getCommonAncestor, getCommonAncestorForModels, getTrainingRowsCount, getTrainingRowsCounts, compareHyperparameters, compareFeatures, groupByProblemType, similarModels, linearModelFeatureImportances, compareLinearModelFeatureImportances, iterationsUntilConvergence, rankModels, confidenceIntervals, modelsWithFeatures, modelsDerivedFromDataFrame, getProjectIds, getModelIds, updateProject, createOrUpdateScalarField, createVectorField, updateVectorField, appendToVectorField, getModel, getRunsInExperiment, getRunsAndExperimentsInProject, getProjectOverviews, getExperimentRunDetails, originalFeatures, storeTreeModel, storePipelineTransformEvent, computeModelAncestry, extractPipeline)
      override def withStoreGridSearchCrossValidationEvent(
        storeGridSearchCrossValidationEvent : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.StoreGridSearchCrossValidationEvent.Args], _root_.com.twitter.scrooge.Response[self.StoreGridSearchCrossValidationEvent.SuccessType]]
      ): ReqRepServicePerEndpoint =
        new ReqRepServicePerEndpointImpl(testConnection, storeDataFrame, pathForTransformer, storeFitEvent, storeMetricEvent, getFilePath, storeTransformEvent, storeRandomSplitEvent, storePipelineEvent, storeCrossValidationEvent, storeGridSearchCrossValidationEvent, storeAnnotationEvent, storeProjectEvent, storeExperimentEvent, storeExperimentRunEvent, storeLinearModel, getDataFrameAncestry, getCommonAncestor, getCommonAncestorForModels, getTrainingRowsCount, getTrainingRowsCounts, compareHyperparameters, compareFeatures, groupByProblemType, similarModels, linearModelFeatureImportances, compareLinearModelFeatureImportances, iterationsUntilConvergence, rankModels, confidenceIntervals, modelsWithFeatures, modelsDerivedFromDataFrame, getProjectIds, getModelIds, updateProject, createOrUpdateScalarField, createVectorField, updateVectorField, appendToVectorField, getModel, getRunsInExperiment, getRunsAndExperimentsInProject, getProjectOverviews, getExperimentRunDetails, originalFeatures, storeTreeModel, storePipelineTransformEvent, computeModelAncestry, extractPipeline)
      override def withStoreAnnotationEvent(
        storeAnnotationEvent : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.StoreAnnotationEvent.Args], _root_.com.twitter.scrooge.Response[self.StoreAnnotationEvent.SuccessType]]
      ): ReqRepServicePerEndpoint =
        new ReqRepServicePerEndpointImpl(testConnection, storeDataFrame, pathForTransformer, storeFitEvent, storeMetricEvent, getFilePath, storeTransformEvent, storeRandomSplitEvent, storePipelineEvent, storeCrossValidationEvent, storeGridSearchCrossValidationEvent, storeAnnotationEvent, storeProjectEvent, storeExperimentEvent, storeExperimentRunEvent, storeLinearModel, getDataFrameAncestry, getCommonAncestor, getCommonAncestorForModels, getTrainingRowsCount, getTrainingRowsCounts, compareHyperparameters, compareFeatures, groupByProblemType, similarModels, linearModelFeatureImportances, compareLinearModelFeatureImportances, iterationsUntilConvergence, rankModels, confidenceIntervals, modelsWithFeatures, modelsDerivedFromDataFrame, getProjectIds, getModelIds, updateProject, createOrUpdateScalarField, createVectorField, updateVectorField, appendToVectorField, getModel, getRunsInExperiment, getRunsAndExperimentsInProject, getProjectOverviews, getExperimentRunDetails, originalFeatures, storeTreeModel, storePipelineTransformEvent, computeModelAncestry, extractPipeline)
      override def withStoreProjectEvent(
        storeProjectEvent : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.StoreProjectEvent.Args], _root_.com.twitter.scrooge.Response[self.StoreProjectEvent.SuccessType]]
      ): ReqRepServicePerEndpoint =
        new ReqRepServicePerEndpointImpl(testConnection, storeDataFrame, pathForTransformer, storeFitEvent, storeMetricEvent, getFilePath, storeTransformEvent, storeRandomSplitEvent, storePipelineEvent, storeCrossValidationEvent, storeGridSearchCrossValidationEvent, storeAnnotationEvent, storeProjectEvent, storeExperimentEvent, storeExperimentRunEvent, storeLinearModel, getDataFrameAncestry, getCommonAncestor, getCommonAncestorForModels, getTrainingRowsCount, getTrainingRowsCounts, compareHyperparameters, compareFeatures, groupByProblemType, similarModels, linearModelFeatureImportances, compareLinearModelFeatureImportances, iterationsUntilConvergence, rankModels, confidenceIntervals, modelsWithFeatures, modelsDerivedFromDataFrame, getProjectIds, getModelIds, updateProject, createOrUpdateScalarField, createVectorField, updateVectorField, appendToVectorField, getModel, getRunsInExperiment, getRunsAndExperimentsInProject, getProjectOverviews, getExperimentRunDetails, originalFeatures, storeTreeModel, storePipelineTransformEvent, computeModelAncestry, extractPipeline)
      override def withStoreExperimentEvent(
        storeExperimentEvent : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.StoreExperimentEvent.Args], _root_.com.twitter.scrooge.Response[self.StoreExperimentEvent.SuccessType]]
      ): ReqRepServicePerEndpoint =
        new ReqRepServicePerEndpointImpl(testConnection, storeDataFrame, pathForTransformer, storeFitEvent, storeMetricEvent, getFilePath, storeTransformEvent, storeRandomSplitEvent, storePipelineEvent, storeCrossValidationEvent, storeGridSearchCrossValidationEvent, storeAnnotationEvent, storeProjectEvent, storeExperimentEvent, storeExperimentRunEvent, storeLinearModel, getDataFrameAncestry, getCommonAncestor, getCommonAncestorForModels, getTrainingRowsCount, getTrainingRowsCounts, compareHyperparameters, compareFeatures, groupByProblemType, similarModels, linearModelFeatureImportances, compareLinearModelFeatureImportances, iterationsUntilConvergence, rankModels, confidenceIntervals, modelsWithFeatures, modelsDerivedFromDataFrame, getProjectIds, getModelIds, updateProject, createOrUpdateScalarField, createVectorField, updateVectorField, appendToVectorField, getModel, getRunsInExperiment, getRunsAndExperimentsInProject, getProjectOverviews, getExperimentRunDetails, originalFeatures, storeTreeModel, storePipelineTransformEvent, computeModelAncestry, extractPipeline)
      override def withStoreExperimentRunEvent(
        storeExperimentRunEvent : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.StoreExperimentRunEvent.Args], _root_.com.twitter.scrooge.Response[self.StoreExperimentRunEvent.SuccessType]]
      ): ReqRepServicePerEndpoint =
        new ReqRepServicePerEndpointImpl(testConnection, storeDataFrame, pathForTransformer, storeFitEvent, storeMetricEvent, getFilePath, storeTransformEvent, storeRandomSplitEvent, storePipelineEvent, storeCrossValidationEvent, storeGridSearchCrossValidationEvent, storeAnnotationEvent, storeProjectEvent, storeExperimentEvent, storeExperimentRunEvent, storeLinearModel, getDataFrameAncestry, getCommonAncestor, getCommonAncestorForModels, getTrainingRowsCount, getTrainingRowsCounts, compareHyperparameters, compareFeatures, groupByProblemType, similarModels, linearModelFeatureImportances, compareLinearModelFeatureImportances, iterationsUntilConvergence, rankModels, confidenceIntervals, modelsWithFeatures, modelsDerivedFromDataFrame, getProjectIds, getModelIds, updateProject, createOrUpdateScalarField, createVectorField, updateVectorField, appendToVectorField, getModel, getRunsInExperiment, getRunsAndExperimentsInProject, getProjectOverviews, getExperimentRunDetails, originalFeatures, storeTreeModel, storePipelineTransformEvent, computeModelAncestry, extractPipeline)
      override def withStoreLinearModel(
        storeLinearModel : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.StoreLinearModel.Args], _root_.com.twitter.scrooge.Response[self.StoreLinearModel.SuccessType]]
      ): ReqRepServicePerEndpoint =
        new ReqRepServicePerEndpointImpl(testConnection, storeDataFrame, pathForTransformer, storeFitEvent, storeMetricEvent, getFilePath, storeTransformEvent, storeRandomSplitEvent, storePipelineEvent, storeCrossValidationEvent, storeGridSearchCrossValidationEvent, storeAnnotationEvent, storeProjectEvent, storeExperimentEvent, storeExperimentRunEvent, storeLinearModel, getDataFrameAncestry, getCommonAncestor, getCommonAncestorForModels, getTrainingRowsCount, getTrainingRowsCounts, compareHyperparameters, compareFeatures, groupByProblemType, similarModels, linearModelFeatureImportances, compareLinearModelFeatureImportances, iterationsUntilConvergence, rankModels, confidenceIntervals, modelsWithFeatures, modelsDerivedFromDataFrame, getProjectIds, getModelIds, updateProject, createOrUpdateScalarField, createVectorField, updateVectorField, appendToVectorField, getModel, getRunsInExperiment, getRunsAndExperimentsInProject, getProjectOverviews, getExperimentRunDetails, originalFeatures, storeTreeModel, storePipelineTransformEvent, computeModelAncestry, extractPipeline)
      override def withGetDataFrameAncestry(
        getDataFrameAncestry : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.GetDataFrameAncestry.Args], _root_.com.twitter.scrooge.Response[self.GetDataFrameAncestry.SuccessType]]
      ): ReqRepServicePerEndpoint =
        new ReqRepServicePerEndpointImpl(testConnection, storeDataFrame, pathForTransformer, storeFitEvent, storeMetricEvent, getFilePath, storeTransformEvent, storeRandomSplitEvent, storePipelineEvent, storeCrossValidationEvent, storeGridSearchCrossValidationEvent, storeAnnotationEvent, storeProjectEvent, storeExperimentEvent, storeExperimentRunEvent, storeLinearModel, getDataFrameAncestry, getCommonAncestor, getCommonAncestorForModels, getTrainingRowsCount, getTrainingRowsCounts, compareHyperparameters, compareFeatures, groupByProblemType, similarModels, linearModelFeatureImportances, compareLinearModelFeatureImportances, iterationsUntilConvergence, rankModels, confidenceIntervals, modelsWithFeatures, modelsDerivedFromDataFrame, getProjectIds, getModelIds, updateProject, createOrUpdateScalarField, createVectorField, updateVectorField, appendToVectorField, getModel, getRunsInExperiment, getRunsAndExperimentsInProject, getProjectOverviews, getExperimentRunDetails, originalFeatures, storeTreeModel, storePipelineTransformEvent, computeModelAncestry, extractPipeline)
      override def withGetCommonAncestor(
        getCommonAncestor : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.GetCommonAncestor.Args], _root_.com.twitter.scrooge.Response[self.GetCommonAncestor.SuccessType]]
      ): ReqRepServicePerEndpoint =
        new ReqRepServicePerEndpointImpl(testConnection, storeDataFrame, pathForTransformer, storeFitEvent, storeMetricEvent, getFilePath, storeTransformEvent, storeRandomSplitEvent, storePipelineEvent, storeCrossValidationEvent, storeGridSearchCrossValidationEvent, storeAnnotationEvent, storeProjectEvent, storeExperimentEvent, storeExperimentRunEvent, storeLinearModel, getDataFrameAncestry, getCommonAncestor, getCommonAncestorForModels, getTrainingRowsCount, getTrainingRowsCounts, compareHyperparameters, compareFeatures, groupByProblemType, similarModels, linearModelFeatureImportances, compareLinearModelFeatureImportances, iterationsUntilConvergence, rankModels, confidenceIntervals, modelsWithFeatures, modelsDerivedFromDataFrame, getProjectIds, getModelIds, updateProject, createOrUpdateScalarField, createVectorField, updateVectorField, appendToVectorField, getModel, getRunsInExperiment, getRunsAndExperimentsInProject, getProjectOverviews, getExperimentRunDetails, originalFeatures, storeTreeModel, storePipelineTransformEvent, computeModelAncestry, extractPipeline)
      override def withGetCommonAncestorForModels(
        getCommonAncestorForModels : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.GetCommonAncestorForModels.Args], _root_.com.twitter.scrooge.Response[self.GetCommonAncestorForModels.SuccessType]]
      ): ReqRepServicePerEndpoint =
        new ReqRepServicePerEndpointImpl(testConnection, storeDataFrame, pathForTransformer, storeFitEvent, storeMetricEvent, getFilePath, storeTransformEvent, storeRandomSplitEvent, storePipelineEvent, storeCrossValidationEvent, storeGridSearchCrossValidationEvent, storeAnnotationEvent, storeProjectEvent, storeExperimentEvent, storeExperimentRunEvent, storeLinearModel, getDataFrameAncestry, getCommonAncestor, getCommonAncestorForModels, getTrainingRowsCount, getTrainingRowsCounts, compareHyperparameters, compareFeatures, groupByProblemType, similarModels, linearModelFeatureImportances, compareLinearModelFeatureImportances, iterationsUntilConvergence, rankModels, confidenceIntervals, modelsWithFeatures, modelsDerivedFromDataFrame, getProjectIds, getModelIds, updateProject, createOrUpdateScalarField, createVectorField, updateVectorField, appendToVectorField, getModel, getRunsInExperiment, getRunsAndExperimentsInProject, getProjectOverviews, getExperimentRunDetails, originalFeatures, storeTreeModel, storePipelineTransformEvent, computeModelAncestry, extractPipeline)
      override def withGetTrainingRowsCount(
        getTrainingRowsCount : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.GetTrainingRowsCount.Args], _root_.com.twitter.scrooge.Response[self.GetTrainingRowsCount.SuccessType]]
      ): ReqRepServicePerEndpoint =
        new ReqRepServicePerEndpointImpl(testConnection, storeDataFrame, pathForTransformer, storeFitEvent, storeMetricEvent, getFilePath, storeTransformEvent, storeRandomSplitEvent, storePipelineEvent, storeCrossValidationEvent, storeGridSearchCrossValidationEvent, storeAnnotationEvent, storeProjectEvent, storeExperimentEvent, storeExperimentRunEvent, storeLinearModel, getDataFrameAncestry, getCommonAncestor, getCommonAncestorForModels, getTrainingRowsCount, getTrainingRowsCounts, compareHyperparameters, compareFeatures, groupByProblemType, similarModels, linearModelFeatureImportances, compareLinearModelFeatureImportances, iterationsUntilConvergence, rankModels, confidenceIntervals, modelsWithFeatures, modelsDerivedFromDataFrame, getProjectIds, getModelIds, updateProject, createOrUpdateScalarField, createVectorField, updateVectorField, appendToVectorField, getModel, getRunsInExperiment, getRunsAndExperimentsInProject, getProjectOverviews, getExperimentRunDetails, originalFeatures, storeTreeModel, storePipelineTransformEvent, computeModelAncestry, extractPipeline)
      override def withGetTrainingRowsCounts(
        getTrainingRowsCounts : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.GetTrainingRowsCounts.Args], _root_.com.twitter.scrooge.Response[self.GetTrainingRowsCounts.SuccessType]]
      ): ReqRepServicePerEndpoint =
        new ReqRepServicePerEndpointImpl(testConnection, storeDataFrame, pathForTransformer, storeFitEvent, storeMetricEvent, getFilePath, storeTransformEvent, storeRandomSplitEvent, storePipelineEvent, storeCrossValidationEvent, storeGridSearchCrossValidationEvent, storeAnnotationEvent, storeProjectEvent, storeExperimentEvent, storeExperimentRunEvent, storeLinearModel, getDataFrameAncestry, getCommonAncestor, getCommonAncestorForModels, getTrainingRowsCount, getTrainingRowsCounts, compareHyperparameters, compareFeatures, groupByProblemType, similarModels, linearModelFeatureImportances, compareLinearModelFeatureImportances, iterationsUntilConvergence, rankModels, confidenceIntervals, modelsWithFeatures, modelsDerivedFromDataFrame, getProjectIds, getModelIds, updateProject, createOrUpdateScalarField, createVectorField, updateVectorField, appendToVectorField, getModel, getRunsInExperiment, getRunsAndExperimentsInProject, getProjectOverviews, getExperimentRunDetails, originalFeatures, storeTreeModel, storePipelineTransformEvent, computeModelAncestry, extractPipeline)
      override def withCompareHyperparameters(
        compareHyperparameters : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.CompareHyperparameters.Args], _root_.com.twitter.scrooge.Response[self.CompareHyperparameters.SuccessType]]
      ): ReqRepServicePerEndpoint =
        new ReqRepServicePerEndpointImpl(testConnection, storeDataFrame, pathForTransformer, storeFitEvent, storeMetricEvent, getFilePath, storeTransformEvent, storeRandomSplitEvent, storePipelineEvent, storeCrossValidationEvent, storeGridSearchCrossValidationEvent, storeAnnotationEvent, storeProjectEvent, storeExperimentEvent, storeExperimentRunEvent, storeLinearModel, getDataFrameAncestry, getCommonAncestor, getCommonAncestorForModels, getTrainingRowsCount, getTrainingRowsCounts, compareHyperparameters, compareFeatures, groupByProblemType, similarModels, linearModelFeatureImportances, compareLinearModelFeatureImportances, iterationsUntilConvergence, rankModels, confidenceIntervals, modelsWithFeatures, modelsDerivedFromDataFrame, getProjectIds, getModelIds, updateProject, createOrUpdateScalarField, createVectorField, updateVectorField, appendToVectorField, getModel, getRunsInExperiment, getRunsAndExperimentsInProject, getProjectOverviews, getExperimentRunDetails, originalFeatures, storeTreeModel, storePipelineTransformEvent, computeModelAncestry, extractPipeline)
      override def withCompareFeatures(
        compareFeatures : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.CompareFeatures.Args], _root_.com.twitter.scrooge.Response[self.CompareFeatures.SuccessType]]
      ): ReqRepServicePerEndpoint =
        new ReqRepServicePerEndpointImpl(testConnection, storeDataFrame, pathForTransformer, storeFitEvent, storeMetricEvent, getFilePath, storeTransformEvent, storeRandomSplitEvent, storePipelineEvent, storeCrossValidationEvent, storeGridSearchCrossValidationEvent, storeAnnotationEvent, storeProjectEvent, storeExperimentEvent, storeExperimentRunEvent, storeLinearModel, getDataFrameAncestry, getCommonAncestor, getCommonAncestorForModels, getTrainingRowsCount, getTrainingRowsCounts, compareHyperparameters, compareFeatures, groupByProblemType, similarModels, linearModelFeatureImportances, compareLinearModelFeatureImportances, iterationsUntilConvergence, rankModels, confidenceIntervals, modelsWithFeatures, modelsDerivedFromDataFrame, getProjectIds, getModelIds, updateProject, createOrUpdateScalarField, createVectorField, updateVectorField, appendToVectorField, getModel, getRunsInExperiment, getRunsAndExperimentsInProject, getProjectOverviews, getExperimentRunDetails, originalFeatures, storeTreeModel, storePipelineTransformEvent, computeModelAncestry, extractPipeline)
      override def withGroupByProblemType(
        groupByProblemType : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.GroupByProblemType.Args], _root_.com.twitter.scrooge.Response[self.GroupByProblemType.SuccessType]]
      ): ReqRepServicePerEndpoint =
        new ReqRepServicePerEndpointImpl(testConnection, storeDataFrame, pathForTransformer, storeFitEvent, storeMetricEvent, getFilePath, storeTransformEvent, storeRandomSplitEvent, storePipelineEvent, storeCrossValidationEvent, storeGridSearchCrossValidationEvent, storeAnnotationEvent, storeProjectEvent, storeExperimentEvent, storeExperimentRunEvent, storeLinearModel, getDataFrameAncestry, getCommonAncestor, getCommonAncestorForModels, getTrainingRowsCount, getTrainingRowsCounts, compareHyperparameters, compareFeatures, groupByProblemType, similarModels, linearModelFeatureImportances, compareLinearModelFeatureImportances, iterationsUntilConvergence, rankModels, confidenceIntervals, modelsWithFeatures, modelsDerivedFromDataFrame, getProjectIds, getModelIds, updateProject, createOrUpdateScalarField, createVectorField, updateVectorField, appendToVectorField, getModel, getRunsInExperiment, getRunsAndExperimentsInProject, getProjectOverviews, getExperimentRunDetails, originalFeatures, storeTreeModel, storePipelineTransformEvent, computeModelAncestry, extractPipeline)
      override def withSimilarModels(
        similarModels : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.SimilarModels.Args], _root_.com.twitter.scrooge.Response[self.SimilarModels.SuccessType]]
      ): ReqRepServicePerEndpoint =
        new ReqRepServicePerEndpointImpl(testConnection, storeDataFrame, pathForTransformer, storeFitEvent, storeMetricEvent, getFilePath, storeTransformEvent, storeRandomSplitEvent, storePipelineEvent, storeCrossValidationEvent, storeGridSearchCrossValidationEvent, storeAnnotationEvent, storeProjectEvent, storeExperimentEvent, storeExperimentRunEvent, storeLinearModel, getDataFrameAncestry, getCommonAncestor, getCommonAncestorForModels, getTrainingRowsCount, getTrainingRowsCounts, compareHyperparameters, compareFeatures, groupByProblemType, similarModels, linearModelFeatureImportances, compareLinearModelFeatureImportances, iterationsUntilConvergence, rankModels, confidenceIntervals, modelsWithFeatures, modelsDerivedFromDataFrame, getProjectIds, getModelIds, updateProject, createOrUpdateScalarField, createVectorField, updateVectorField, appendToVectorField, getModel, getRunsInExperiment, getRunsAndExperimentsInProject, getProjectOverviews, getExperimentRunDetails, originalFeatures, storeTreeModel, storePipelineTransformEvent, computeModelAncestry, extractPipeline)
      override def withLinearModelFeatureImportances(
        linearModelFeatureImportances : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.LinearModelFeatureImportances.Args], _root_.com.twitter.scrooge.Response[self.LinearModelFeatureImportances.SuccessType]]
      ): ReqRepServicePerEndpoint =
        new ReqRepServicePerEndpointImpl(testConnection, storeDataFrame, pathForTransformer, storeFitEvent, storeMetricEvent, getFilePath, storeTransformEvent, storeRandomSplitEvent, storePipelineEvent, storeCrossValidationEvent, storeGridSearchCrossValidationEvent, storeAnnotationEvent, storeProjectEvent, storeExperimentEvent, storeExperimentRunEvent, storeLinearModel, getDataFrameAncestry, getCommonAncestor, getCommonAncestorForModels, getTrainingRowsCount, getTrainingRowsCounts, compareHyperparameters, compareFeatures, groupByProblemType, similarModels, linearModelFeatureImportances, compareLinearModelFeatureImportances, iterationsUntilConvergence, rankModels, confidenceIntervals, modelsWithFeatures, modelsDerivedFromDataFrame, getProjectIds, getModelIds, updateProject, createOrUpdateScalarField, createVectorField, updateVectorField, appendToVectorField, getModel, getRunsInExperiment, getRunsAndExperimentsInProject, getProjectOverviews, getExperimentRunDetails, originalFeatures, storeTreeModel, storePipelineTransformEvent, computeModelAncestry, extractPipeline)
      override def withCompareLinearModelFeatureImportances(
        compareLinearModelFeatureImportances : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.CompareLinearModelFeatureImportances.Args], _root_.com.twitter.scrooge.Response[self.CompareLinearModelFeatureImportances.SuccessType]]
      ): ReqRepServicePerEndpoint =
        new ReqRepServicePerEndpointImpl(testConnection, storeDataFrame, pathForTransformer, storeFitEvent, storeMetricEvent, getFilePath, storeTransformEvent, storeRandomSplitEvent, storePipelineEvent, storeCrossValidationEvent, storeGridSearchCrossValidationEvent, storeAnnotationEvent, storeProjectEvent, storeExperimentEvent, storeExperimentRunEvent, storeLinearModel, getDataFrameAncestry, getCommonAncestor, getCommonAncestorForModels, getTrainingRowsCount, getTrainingRowsCounts, compareHyperparameters, compareFeatures, groupByProblemType, similarModels, linearModelFeatureImportances, compareLinearModelFeatureImportances, iterationsUntilConvergence, rankModels, confidenceIntervals, modelsWithFeatures, modelsDerivedFromDataFrame, getProjectIds, getModelIds, updateProject, createOrUpdateScalarField, createVectorField, updateVectorField, appendToVectorField, getModel, getRunsInExperiment, getRunsAndExperimentsInProject, getProjectOverviews, getExperimentRunDetails, originalFeatures, storeTreeModel, storePipelineTransformEvent, computeModelAncestry, extractPipeline)
      override def withIterationsUntilConvergence(
        iterationsUntilConvergence : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.IterationsUntilConvergence.Args], _root_.com.twitter.scrooge.Response[self.IterationsUntilConvergence.SuccessType]]
      ): ReqRepServicePerEndpoint =
        new ReqRepServicePerEndpointImpl(testConnection, storeDataFrame, pathForTransformer, storeFitEvent, storeMetricEvent, getFilePath, storeTransformEvent, storeRandomSplitEvent, storePipelineEvent, storeCrossValidationEvent, storeGridSearchCrossValidationEvent, storeAnnotationEvent, storeProjectEvent, storeExperimentEvent, storeExperimentRunEvent, storeLinearModel, getDataFrameAncestry, getCommonAncestor, getCommonAncestorForModels, getTrainingRowsCount, getTrainingRowsCounts, compareHyperparameters, compareFeatures, groupByProblemType, similarModels, linearModelFeatureImportances, compareLinearModelFeatureImportances, iterationsUntilConvergence, rankModels, confidenceIntervals, modelsWithFeatures, modelsDerivedFromDataFrame, getProjectIds, getModelIds, updateProject, createOrUpdateScalarField, createVectorField, updateVectorField, appendToVectorField, getModel, getRunsInExperiment, getRunsAndExperimentsInProject, getProjectOverviews, getExperimentRunDetails, originalFeatures, storeTreeModel, storePipelineTransformEvent, computeModelAncestry, extractPipeline)
      override def withRankModels(
        rankModels : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.RankModels.Args], _root_.com.twitter.scrooge.Response[self.RankModels.SuccessType]]
      ): ReqRepServicePerEndpoint =
        new ReqRepServicePerEndpointImpl(testConnection, storeDataFrame, pathForTransformer, storeFitEvent, storeMetricEvent, getFilePath, storeTransformEvent, storeRandomSplitEvent, storePipelineEvent, storeCrossValidationEvent, storeGridSearchCrossValidationEvent, storeAnnotationEvent, storeProjectEvent, storeExperimentEvent, storeExperimentRunEvent, storeLinearModel, getDataFrameAncestry, getCommonAncestor, getCommonAncestorForModels, getTrainingRowsCount, getTrainingRowsCounts, compareHyperparameters, compareFeatures, groupByProblemType, similarModels, linearModelFeatureImportances, compareLinearModelFeatureImportances, iterationsUntilConvergence, rankModels, confidenceIntervals, modelsWithFeatures, modelsDerivedFromDataFrame, getProjectIds, getModelIds, updateProject, createOrUpdateScalarField, createVectorField, updateVectorField, appendToVectorField, getModel, getRunsInExperiment, getRunsAndExperimentsInProject, getProjectOverviews, getExperimentRunDetails, originalFeatures, storeTreeModel, storePipelineTransformEvent, computeModelAncestry, extractPipeline)
      override def withConfidenceIntervals(
        confidenceIntervals : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.ConfidenceIntervals.Args], _root_.com.twitter.scrooge.Response[self.ConfidenceIntervals.SuccessType]]
      ): ReqRepServicePerEndpoint =
        new ReqRepServicePerEndpointImpl(testConnection, storeDataFrame, pathForTransformer, storeFitEvent, storeMetricEvent, getFilePath, storeTransformEvent, storeRandomSplitEvent, storePipelineEvent, storeCrossValidationEvent, storeGridSearchCrossValidationEvent, storeAnnotationEvent, storeProjectEvent, storeExperimentEvent, storeExperimentRunEvent, storeLinearModel, getDataFrameAncestry, getCommonAncestor, getCommonAncestorForModels, getTrainingRowsCount, getTrainingRowsCounts, compareHyperparameters, compareFeatures, groupByProblemType, similarModels, linearModelFeatureImportances, compareLinearModelFeatureImportances, iterationsUntilConvergence, rankModels, confidenceIntervals, modelsWithFeatures, modelsDerivedFromDataFrame, getProjectIds, getModelIds, updateProject, createOrUpdateScalarField, createVectorField, updateVectorField, appendToVectorField, getModel, getRunsInExperiment, getRunsAndExperimentsInProject, getProjectOverviews, getExperimentRunDetails, originalFeatures, storeTreeModel, storePipelineTransformEvent, computeModelAncestry, extractPipeline)
      override def withModelsWithFeatures(
        modelsWithFeatures : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.ModelsWithFeatures.Args], _root_.com.twitter.scrooge.Response[self.ModelsWithFeatures.SuccessType]]
      ): ReqRepServicePerEndpoint =
        new ReqRepServicePerEndpointImpl(testConnection, storeDataFrame, pathForTransformer, storeFitEvent, storeMetricEvent, getFilePath, storeTransformEvent, storeRandomSplitEvent, storePipelineEvent, storeCrossValidationEvent, storeGridSearchCrossValidationEvent, storeAnnotationEvent, storeProjectEvent, storeExperimentEvent, storeExperimentRunEvent, storeLinearModel, getDataFrameAncestry, getCommonAncestor, getCommonAncestorForModels, getTrainingRowsCount, getTrainingRowsCounts, compareHyperparameters, compareFeatures, groupByProblemType, similarModels, linearModelFeatureImportances, compareLinearModelFeatureImportances, iterationsUntilConvergence, rankModels, confidenceIntervals, modelsWithFeatures, modelsDerivedFromDataFrame, getProjectIds, getModelIds, updateProject, createOrUpdateScalarField, createVectorField, updateVectorField, appendToVectorField, getModel, getRunsInExperiment, getRunsAndExperimentsInProject, getProjectOverviews, getExperimentRunDetails, originalFeatures, storeTreeModel, storePipelineTransformEvent, computeModelAncestry, extractPipeline)
      override def withModelsDerivedFromDataFrame(
        modelsDerivedFromDataFrame : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.ModelsDerivedFromDataFrame.Args], _root_.com.twitter.scrooge.Response[self.ModelsDerivedFromDataFrame.SuccessType]]
      ): ReqRepServicePerEndpoint =
        new ReqRepServicePerEndpointImpl(testConnection, storeDataFrame, pathForTransformer, storeFitEvent, storeMetricEvent, getFilePath, storeTransformEvent, storeRandomSplitEvent, storePipelineEvent, storeCrossValidationEvent, storeGridSearchCrossValidationEvent, storeAnnotationEvent, storeProjectEvent, storeExperimentEvent, storeExperimentRunEvent, storeLinearModel, getDataFrameAncestry, getCommonAncestor, getCommonAncestorForModels, getTrainingRowsCount, getTrainingRowsCounts, compareHyperparameters, compareFeatures, groupByProblemType, similarModels, linearModelFeatureImportances, compareLinearModelFeatureImportances, iterationsUntilConvergence, rankModels, confidenceIntervals, modelsWithFeatures, modelsDerivedFromDataFrame, getProjectIds, getModelIds, updateProject, createOrUpdateScalarField, createVectorField, updateVectorField, appendToVectorField, getModel, getRunsInExperiment, getRunsAndExperimentsInProject, getProjectOverviews, getExperimentRunDetails, originalFeatures, storeTreeModel, storePipelineTransformEvent, computeModelAncestry, extractPipeline)
      override def withGetProjectIds(
        getProjectIds : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.GetProjectIds.Args], _root_.com.twitter.scrooge.Response[self.GetProjectIds.SuccessType]]
      ): ReqRepServicePerEndpoint =
        new ReqRepServicePerEndpointImpl(testConnection, storeDataFrame, pathForTransformer, storeFitEvent, storeMetricEvent, getFilePath, storeTransformEvent, storeRandomSplitEvent, storePipelineEvent, storeCrossValidationEvent, storeGridSearchCrossValidationEvent, storeAnnotationEvent, storeProjectEvent, storeExperimentEvent, storeExperimentRunEvent, storeLinearModel, getDataFrameAncestry, getCommonAncestor, getCommonAncestorForModels, getTrainingRowsCount, getTrainingRowsCounts, compareHyperparameters, compareFeatures, groupByProblemType, similarModels, linearModelFeatureImportances, compareLinearModelFeatureImportances, iterationsUntilConvergence, rankModels, confidenceIntervals, modelsWithFeatures, modelsDerivedFromDataFrame, getProjectIds, getModelIds, updateProject, createOrUpdateScalarField, createVectorField, updateVectorField, appendToVectorField, getModel, getRunsInExperiment, getRunsAndExperimentsInProject, getProjectOverviews, getExperimentRunDetails, originalFeatures, storeTreeModel, storePipelineTransformEvent, computeModelAncestry, extractPipeline)
      override def withGetModelIds(
        getModelIds : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.GetModelIds.Args], _root_.com.twitter.scrooge.Response[self.GetModelIds.SuccessType]]
      ): ReqRepServicePerEndpoint =
        new ReqRepServicePerEndpointImpl(testConnection, storeDataFrame, pathForTransformer, storeFitEvent, storeMetricEvent, getFilePath, storeTransformEvent, storeRandomSplitEvent, storePipelineEvent, storeCrossValidationEvent, storeGridSearchCrossValidationEvent, storeAnnotationEvent, storeProjectEvent, storeExperimentEvent, storeExperimentRunEvent, storeLinearModel, getDataFrameAncestry, getCommonAncestor, getCommonAncestorForModels, getTrainingRowsCount, getTrainingRowsCounts, compareHyperparameters, compareFeatures, groupByProblemType, similarModels, linearModelFeatureImportances, compareLinearModelFeatureImportances, iterationsUntilConvergence, rankModels, confidenceIntervals, modelsWithFeatures, modelsDerivedFromDataFrame, getProjectIds, getModelIds, updateProject, createOrUpdateScalarField, createVectorField, updateVectorField, appendToVectorField, getModel, getRunsInExperiment, getRunsAndExperimentsInProject, getProjectOverviews, getExperimentRunDetails, originalFeatures, storeTreeModel, storePipelineTransformEvent, computeModelAncestry, extractPipeline)
      override def withUpdateProject(
        updateProject : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.UpdateProject.Args], _root_.com.twitter.scrooge.Response[self.UpdateProject.SuccessType]]
      ): ReqRepServicePerEndpoint =
        new ReqRepServicePerEndpointImpl(testConnection, storeDataFrame, pathForTransformer, storeFitEvent, storeMetricEvent, getFilePath, storeTransformEvent, storeRandomSplitEvent, storePipelineEvent, storeCrossValidationEvent, storeGridSearchCrossValidationEvent, storeAnnotationEvent, storeProjectEvent, storeExperimentEvent, storeExperimentRunEvent, storeLinearModel, getDataFrameAncestry, getCommonAncestor, getCommonAncestorForModels, getTrainingRowsCount, getTrainingRowsCounts, compareHyperparameters, compareFeatures, groupByProblemType, similarModels, linearModelFeatureImportances, compareLinearModelFeatureImportances, iterationsUntilConvergence, rankModels, confidenceIntervals, modelsWithFeatures, modelsDerivedFromDataFrame, getProjectIds, getModelIds, updateProject, createOrUpdateScalarField, createVectorField, updateVectorField, appendToVectorField, getModel, getRunsInExperiment, getRunsAndExperimentsInProject, getProjectOverviews, getExperimentRunDetails, originalFeatures, storeTreeModel, storePipelineTransformEvent, computeModelAncestry, extractPipeline)
      override def withCreateOrUpdateScalarField(
        createOrUpdateScalarField : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.CreateOrUpdateScalarField.Args], _root_.com.twitter.scrooge.Response[self.CreateOrUpdateScalarField.SuccessType]]
      ): ReqRepServicePerEndpoint =
        new ReqRepServicePerEndpointImpl(testConnection, storeDataFrame, pathForTransformer, storeFitEvent, storeMetricEvent, getFilePath, storeTransformEvent, storeRandomSplitEvent, storePipelineEvent, storeCrossValidationEvent, storeGridSearchCrossValidationEvent, storeAnnotationEvent, storeProjectEvent, storeExperimentEvent, storeExperimentRunEvent, storeLinearModel, getDataFrameAncestry, getCommonAncestor, getCommonAncestorForModels, getTrainingRowsCount, getTrainingRowsCounts, compareHyperparameters, compareFeatures, groupByProblemType, similarModels, linearModelFeatureImportances, compareLinearModelFeatureImportances, iterationsUntilConvergence, rankModels, confidenceIntervals, modelsWithFeatures, modelsDerivedFromDataFrame, getProjectIds, getModelIds, updateProject, createOrUpdateScalarField, createVectorField, updateVectorField, appendToVectorField, getModel, getRunsInExperiment, getRunsAndExperimentsInProject, getProjectOverviews, getExperimentRunDetails, originalFeatures, storeTreeModel, storePipelineTransformEvent, computeModelAncestry, extractPipeline)
      override def withCreateVectorField(
        createVectorField : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.CreateVectorField.Args], _root_.com.twitter.scrooge.Response[self.CreateVectorField.SuccessType]]
      ): ReqRepServicePerEndpoint =
        new ReqRepServicePerEndpointImpl(testConnection, storeDataFrame, pathForTransformer, storeFitEvent, storeMetricEvent, getFilePath, storeTransformEvent, storeRandomSplitEvent, storePipelineEvent, storeCrossValidationEvent, storeGridSearchCrossValidationEvent, storeAnnotationEvent, storeProjectEvent, storeExperimentEvent, storeExperimentRunEvent, storeLinearModel, getDataFrameAncestry, getCommonAncestor, getCommonAncestorForModels, getTrainingRowsCount, getTrainingRowsCounts, compareHyperparameters, compareFeatures, groupByProblemType, similarModels, linearModelFeatureImportances, compareLinearModelFeatureImportances, iterationsUntilConvergence, rankModels, confidenceIntervals, modelsWithFeatures, modelsDerivedFromDataFrame, getProjectIds, getModelIds, updateProject, createOrUpdateScalarField, createVectorField, updateVectorField, appendToVectorField, getModel, getRunsInExperiment, getRunsAndExperimentsInProject, getProjectOverviews, getExperimentRunDetails, originalFeatures, storeTreeModel, storePipelineTransformEvent, computeModelAncestry, extractPipeline)
      override def withUpdateVectorField(
        updateVectorField : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.UpdateVectorField.Args], _root_.com.twitter.scrooge.Response[self.UpdateVectorField.SuccessType]]
      ): ReqRepServicePerEndpoint =
        new ReqRepServicePerEndpointImpl(testConnection, storeDataFrame, pathForTransformer, storeFitEvent, storeMetricEvent, getFilePath, storeTransformEvent, storeRandomSplitEvent, storePipelineEvent, storeCrossValidationEvent, storeGridSearchCrossValidationEvent, storeAnnotationEvent, storeProjectEvent, storeExperimentEvent, storeExperimentRunEvent, storeLinearModel, getDataFrameAncestry, getCommonAncestor, getCommonAncestorForModels, getTrainingRowsCount, getTrainingRowsCounts, compareHyperparameters, compareFeatures, groupByProblemType, similarModels, linearModelFeatureImportances, compareLinearModelFeatureImportances, iterationsUntilConvergence, rankModels, confidenceIntervals, modelsWithFeatures, modelsDerivedFromDataFrame, getProjectIds, getModelIds, updateProject, createOrUpdateScalarField, createVectorField, updateVectorField, appendToVectorField, getModel, getRunsInExperiment, getRunsAndExperimentsInProject, getProjectOverviews, getExperimentRunDetails, originalFeatures, storeTreeModel, storePipelineTransformEvent, computeModelAncestry, extractPipeline)
      override def withAppendToVectorField(
        appendToVectorField : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.AppendToVectorField.Args], _root_.com.twitter.scrooge.Response[self.AppendToVectorField.SuccessType]]
      ): ReqRepServicePerEndpoint =
        new ReqRepServicePerEndpointImpl(testConnection, storeDataFrame, pathForTransformer, storeFitEvent, storeMetricEvent, getFilePath, storeTransformEvent, storeRandomSplitEvent, storePipelineEvent, storeCrossValidationEvent, storeGridSearchCrossValidationEvent, storeAnnotationEvent, storeProjectEvent, storeExperimentEvent, storeExperimentRunEvent, storeLinearModel, getDataFrameAncestry, getCommonAncestor, getCommonAncestorForModels, getTrainingRowsCount, getTrainingRowsCounts, compareHyperparameters, compareFeatures, groupByProblemType, similarModels, linearModelFeatureImportances, compareLinearModelFeatureImportances, iterationsUntilConvergence, rankModels, confidenceIntervals, modelsWithFeatures, modelsDerivedFromDataFrame, getProjectIds, getModelIds, updateProject, createOrUpdateScalarField, createVectorField, updateVectorField, appendToVectorField, getModel, getRunsInExperiment, getRunsAndExperimentsInProject, getProjectOverviews, getExperimentRunDetails, originalFeatures, storeTreeModel, storePipelineTransformEvent, computeModelAncestry, extractPipeline)
      override def withGetModel(
        getModel : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.GetModel.Args], _root_.com.twitter.scrooge.Response[self.GetModel.SuccessType]]
      ): ReqRepServicePerEndpoint =
        new ReqRepServicePerEndpointImpl(testConnection, storeDataFrame, pathForTransformer, storeFitEvent, storeMetricEvent, getFilePath, storeTransformEvent, storeRandomSplitEvent, storePipelineEvent, storeCrossValidationEvent, storeGridSearchCrossValidationEvent, storeAnnotationEvent, storeProjectEvent, storeExperimentEvent, storeExperimentRunEvent, storeLinearModel, getDataFrameAncestry, getCommonAncestor, getCommonAncestorForModels, getTrainingRowsCount, getTrainingRowsCounts, compareHyperparameters, compareFeatures, groupByProblemType, similarModels, linearModelFeatureImportances, compareLinearModelFeatureImportances, iterationsUntilConvergence, rankModels, confidenceIntervals, modelsWithFeatures, modelsDerivedFromDataFrame, getProjectIds, getModelIds, updateProject, createOrUpdateScalarField, createVectorField, updateVectorField, appendToVectorField, getModel, getRunsInExperiment, getRunsAndExperimentsInProject, getProjectOverviews, getExperimentRunDetails, originalFeatures, storeTreeModel, storePipelineTransformEvent, computeModelAncestry, extractPipeline)
      override def withGetRunsInExperiment(
        getRunsInExperiment : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.GetRunsInExperiment.Args], _root_.com.twitter.scrooge.Response[self.GetRunsInExperiment.SuccessType]]
      ): ReqRepServicePerEndpoint =
        new ReqRepServicePerEndpointImpl(testConnection, storeDataFrame, pathForTransformer, storeFitEvent, storeMetricEvent, getFilePath, storeTransformEvent, storeRandomSplitEvent, storePipelineEvent, storeCrossValidationEvent, storeGridSearchCrossValidationEvent, storeAnnotationEvent, storeProjectEvent, storeExperimentEvent, storeExperimentRunEvent, storeLinearModel, getDataFrameAncestry, getCommonAncestor, getCommonAncestorForModels, getTrainingRowsCount, getTrainingRowsCounts, compareHyperparameters, compareFeatures, groupByProblemType, similarModels, linearModelFeatureImportances, compareLinearModelFeatureImportances, iterationsUntilConvergence, rankModels, confidenceIntervals, modelsWithFeatures, modelsDerivedFromDataFrame, getProjectIds, getModelIds, updateProject, createOrUpdateScalarField, createVectorField, updateVectorField, appendToVectorField, getModel, getRunsInExperiment, getRunsAndExperimentsInProject, getProjectOverviews, getExperimentRunDetails, originalFeatures, storeTreeModel, storePipelineTransformEvent, computeModelAncestry, extractPipeline)
      override def withGetRunsAndExperimentsInProject(
        getRunsAndExperimentsInProject : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.GetRunsAndExperimentsInProject.Args], _root_.com.twitter.scrooge.Response[self.GetRunsAndExperimentsInProject.SuccessType]]
      ): ReqRepServicePerEndpoint =
        new ReqRepServicePerEndpointImpl(testConnection, storeDataFrame, pathForTransformer, storeFitEvent, storeMetricEvent, getFilePath, storeTransformEvent, storeRandomSplitEvent, storePipelineEvent, storeCrossValidationEvent, storeGridSearchCrossValidationEvent, storeAnnotationEvent, storeProjectEvent, storeExperimentEvent, storeExperimentRunEvent, storeLinearModel, getDataFrameAncestry, getCommonAncestor, getCommonAncestorForModels, getTrainingRowsCount, getTrainingRowsCounts, compareHyperparameters, compareFeatures, groupByProblemType, similarModels, linearModelFeatureImportances, compareLinearModelFeatureImportances, iterationsUntilConvergence, rankModels, confidenceIntervals, modelsWithFeatures, modelsDerivedFromDataFrame, getProjectIds, getModelIds, updateProject, createOrUpdateScalarField, createVectorField, updateVectorField, appendToVectorField, getModel, getRunsInExperiment, getRunsAndExperimentsInProject, getProjectOverviews, getExperimentRunDetails, originalFeatures, storeTreeModel, storePipelineTransformEvent, computeModelAncestry, extractPipeline)
      override def withGetProjectOverviews(
        getProjectOverviews : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.GetProjectOverviews.Args], _root_.com.twitter.scrooge.Response[self.GetProjectOverviews.SuccessType]]
      ): ReqRepServicePerEndpoint =
        new ReqRepServicePerEndpointImpl(testConnection, storeDataFrame, pathForTransformer, storeFitEvent, storeMetricEvent, getFilePath, storeTransformEvent, storeRandomSplitEvent, storePipelineEvent, storeCrossValidationEvent, storeGridSearchCrossValidationEvent, storeAnnotationEvent, storeProjectEvent, storeExperimentEvent, storeExperimentRunEvent, storeLinearModel, getDataFrameAncestry, getCommonAncestor, getCommonAncestorForModels, getTrainingRowsCount, getTrainingRowsCounts, compareHyperparameters, compareFeatures, groupByProblemType, similarModels, linearModelFeatureImportances, compareLinearModelFeatureImportances, iterationsUntilConvergence, rankModels, confidenceIntervals, modelsWithFeatures, modelsDerivedFromDataFrame, getProjectIds, getModelIds, updateProject, createOrUpdateScalarField, createVectorField, updateVectorField, appendToVectorField, getModel, getRunsInExperiment, getRunsAndExperimentsInProject, getProjectOverviews, getExperimentRunDetails, originalFeatures, storeTreeModel, storePipelineTransformEvent, computeModelAncestry, extractPipeline)
      override def withGetExperimentRunDetails(
        getExperimentRunDetails : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.GetExperimentRunDetails.Args], _root_.com.twitter.scrooge.Response[self.GetExperimentRunDetails.SuccessType]]
      ): ReqRepServicePerEndpoint =
        new ReqRepServicePerEndpointImpl(testConnection, storeDataFrame, pathForTransformer, storeFitEvent, storeMetricEvent, getFilePath, storeTransformEvent, storeRandomSplitEvent, storePipelineEvent, storeCrossValidationEvent, storeGridSearchCrossValidationEvent, storeAnnotationEvent, storeProjectEvent, storeExperimentEvent, storeExperimentRunEvent, storeLinearModel, getDataFrameAncestry, getCommonAncestor, getCommonAncestorForModels, getTrainingRowsCount, getTrainingRowsCounts, compareHyperparameters, compareFeatures, groupByProblemType, similarModels, linearModelFeatureImportances, compareLinearModelFeatureImportances, iterationsUntilConvergence, rankModels, confidenceIntervals, modelsWithFeatures, modelsDerivedFromDataFrame, getProjectIds, getModelIds, updateProject, createOrUpdateScalarField, createVectorField, updateVectorField, appendToVectorField, getModel, getRunsInExperiment, getRunsAndExperimentsInProject, getProjectOverviews, getExperimentRunDetails, originalFeatures, storeTreeModel, storePipelineTransformEvent, computeModelAncestry, extractPipeline)
      override def withOriginalFeatures(
        originalFeatures : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.OriginalFeatures.Args], _root_.com.twitter.scrooge.Response[self.OriginalFeatures.SuccessType]]
      ): ReqRepServicePerEndpoint =
        new ReqRepServicePerEndpointImpl(testConnection, storeDataFrame, pathForTransformer, storeFitEvent, storeMetricEvent, getFilePath, storeTransformEvent, storeRandomSplitEvent, storePipelineEvent, storeCrossValidationEvent, storeGridSearchCrossValidationEvent, storeAnnotationEvent, storeProjectEvent, storeExperimentEvent, storeExperimentRunEvent, storeLinearModel, getDataFrameAncestry, getCommonAncestor, getCommonAncestorForModels, getTrainingRowsCount, getTrainingRowsCounts, compareHyperparameters, compareFeatures, groupByProblemType, similarModels, linearModelFeatureImportances, compareLinearModelFeatureImportances, iterationsUntilConvergence, rankModels, confidenceIntervals, modelsWithFeatures, modelsDerivedFromDataFrame, getProjectIds, getModelIds, updateProject, createOrUpdateScalarField, createVectorField, updateVectorField, appendToVectorField, getModel, getRunsInExperiment, getRunsAndExperimentsInProject, getProjectOverviews, getExperimentRunDetails, originalFeatures, storeTreeModel, storePipelineTransformEvent, computeModelAncestry, extractPipeline)
      override def withStoreTreeModel(
        storeTreeModel : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.StoreTreeModel.Args], _root_.com.twitter.scrooge.Response[self.StoreTreeModel.SuccessType]]
      ): ReqRepServicePerEndpoint =
        new ReqRepServicePerEndpointImpl(testConnection, storeDataFrame, pathForTransformer, storeFitEvent, storeMetricEvent, getFilePath, storeTransformEvent, storeRandomSplitEvent, storePipelineEvent, storeCrossValidationEvent, storeGridSearchCrossValidationEvent, storeAnnotationEvent, storeProjectEvent, storeExperimentEvent, storeExperimentRunEvent, storeLinearModel, getDataFrameAncestry, getCommonAncestor, getCommonAncestorForModels, getTrainingRowsCount, getTrainingRowsCounts, compareHyperparameters, compareFeatures, groupByProblemType, similarModels, linearModelFeatureImportances, compareLinearModelFeatureImportances, iterationsUntilConvergence, rankModels, confidenceIntervals, modelsWithFeatures, modelsDerivedFromDataFrame, getProjectIds, getModelIds, updateProject, createOrUpdateScalarField, createVectorField, updateVectorField, appendToVectorField, getModel, getRunsInExperiment, getRunsAndExperimentsInProject, getProjectOverviews, getExperimentRunDetails, originalFeatures, storeTreeModel, storePipelineTransformEvent, computeModelAncestry, extractPipeline)
      override def withStorePipelineTransformEvent(
        storePipelineTransformEvent : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.StorePipelineTransformEvent.Args], _root_.com.twitter.scrooge.Response[self.StorePipelineTransformEvent.SuccessType]]
      ): ReqRepServicePerEndpoint =
        new ReqRepServicePerEndpointImpl(testConnection, storeDataFrame, pathForTransformer, storeFitEvent, storeMetricEvent, getFilePath, storeTransformEvent, storeRandomSplitEvent, storePipelineEvent, storeCrossValidationEvent, storeGridSearchCrossValidationEvent, storeAnnotationEvent, storeProjectEvent, storeExperimentEvent, storeExperimentRunEvent, storeLinearModel, getDataFrameAncestry, getCommonAncestor, getCommonAncestorForModels, getTrainingRowsCount, getTrainingRowsCounts, compareHyperparameters, compareFeatures, groupByProblemType, similarModels, linearModelFeatureImportances, compareLinearModelFeatureImportances, iterationsUntilConvergence, rankModels, confidenceIntervals, modelsWithFeatures, modelsDerivedFromDataFrame, getProjectIds, getModelIds, updateProject, createOrUpdateScalarField, createVectorField, updateVectorField, appendToVectorField, getModel, getRunsInExperiment, getRunsAndExperimentsInProject, getProjectOverviews, getExperimentRunDetails, originalFeatures, storeTreeModel, storePipelineTransformEvent, computeModelAncestry, extractPipeline)
      override def withComputeModelAncestry(
        computeModelAncestry : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.ComputeModelAncestry.Args], _root_.com.twitter.scrooge.Response[self.ComputeModelAncestry.SuccessType]]
      ): ReqRepServicePerEndpoint =
        new ReqRepServicePerEndpointImpl(testConnection, storeDataFrame, pathForTransformer, storeFitEvent, storeMetricEvent, getFilePath, storeTransformEvent, storeRandomSplitEvent, storePipelineEvent, storeCrossValidationEvent, storeGridSearchCrossValidationEvent, storeAnnotationEvent, storeProjectEvent, storeExperimentEvent, storeExperimentRunEvent, storeLinearModel, getDataFrameAncestry, getCommonAncestor, getCommonAncestorForModels, getTrainingRowsCount, getTrainingRowsCounts, compareHyperparameters, compareFeatures, groupByProblemType, similarModels, linearModelFeatureImportances, compareLinearModelFeatureImportances, iterationsUntilConvergence, rankModels, confidenceIntervals, modelsWithFeatures, modelsDerivedFromDataFrame, getProjectIds, getModelIds, updateProject, createOrUpdateScalarField, createVectorField, updateVectorField, appendToVectorField, getModel, getRunsInExperiment, getRunsAndExperimentsInProject, getProjectOverviews, getExperimentRunDetails, originalFeatures, storeTreeModel, storePipelineTransformEvent, computeModelAncestry, extractPipeline)
      override def withExtractPipeline(
        extractPipeline : _root_.com.twitter.finagle.Service[com.twitter.scrooge.Request[self.ExtractPipeline.Args], _root_.com.twitter.scrooge.Response[self.ExtractPipeline.SuccessType]]
      ): ReqRepServicePerEndpoint =
        new ReqRepServicePerEndpointImpl(testConnection, storeDataFrame, pathForTransformer, storeFitEvent, storeMetricEvent, getFilePath, storeTransformEvent, storeRandomSplitEvent, storePipelineEvent, storeCrossValidationEvent, storeGridSearchCrossValidationEvent, storeAnnotationEvent, storeProjectEvent, storeExperimentEvent, storeExperimentRunEvent, storeLinearModel, getDataFrameAncestry, getCommonAncestor, getCommonAncestorForModels, getTrainingRowsCount, getTrainingRowsCounts, compareHyperparameters, compareFeatures, groupByProblemType, similarModels, linearModelFeatureImportances, compareLinearModelFeatureImportances, iterationsUntilConvergence, rankModels, confidenceIntervals, modelsWithFeatures, modelsDerivedFromDataFrame, getProjectIds, getModelIds, updateProject, createOrUpdateScalarField, createVectorField, updateVectorField, appendToVectorField, getModel, getRunsInExperiment, getRunsAndExperimentsInProject, getProjectOverviews, getExperimentRunDetails, originalFeatures, storeTreeModel, storePipelineTransformEvent, computeModelAncestry, extractPipeline)

      override def filtered(filter: com.twitter.finagle.Filter.TypeAgnostic): ReqRepServicePerEndpoint =
        new ReqRepServicePerEndpointImpl(
          testConnection = filter.toFilter.andThen(testConnection),
          storeDataFrame = filter.toFilter.andThen(storeDataFrame),
          pathForTransformer = filter.toFilter.andThen(pathForTransformer),
          storeFitEvent = filter.toFilter.andThen(storeFitEvent),
          storeMetricEvent = filter.toFilter.andThen(storeMetricEvent),
          getFilePath = filter.toFilter.andThen(getFilePath),
          storeTransformEvent = filter.toFilter.andThen(storeTransformEvent),
          storeRandomSplitEvent = filter.toFilter.andThen(storeRandomSplitEvent),
          storePipelineEvent = filter.toFilter.andThen(storePipelineEvent),
          storeCrossValidationEvent = filter.toFilter.andThen(storeCrossValidationEvent),
          storeGridSearchCrossValidationEvent = filter.toFilter.andThen(storeGridSearchCrossValidationEvent),
          storeAnnotationEvent = filter.toFilter.andThen(storeAnnotationEvent),
          storeProjectEvent = filter.toFilter.andThen(storeProjectEvent),
          storeExperimentEvent = filter.toFilter.andThen(storeExperimentEvent),
          storeExperimentRunEvent = filter.toFilter.andThen(storeExperimentRunEvent),
          storeLinearModel = filter.toFilter.andThen(storeLinearModel),
          getDataFrameAncestry = filter.toFilter.andThen(getDataFrameAncestry),
          getCommonAncestor = filter.toFilter.andThen(getCommonAncestor),
          getCommonAncestorForModels = filter.toFilter.andThen(getCommonAncestorForModels),
          getTrainingRowsCount = filter.toFilter.andThen(getTrainingRowsCount),
          getTrainingRowsCounts = filter.toFilter.andThen(getTrainingRowsCounts),
          compareHyperparameters = filter.toFilter.andThen(compareHyperparameters),
          compareFeatures = filter.toFilter.andThen(compareFeatures),
          groupByProblemType = filter.toFilter.andThen(groupByProblemType),
          similarModels = filter.toFilter.andThen(similarModels),
          linearModelFeatureImportances = filter.toFilter.andThen(linearModelFeatureImportances),
          compareLinearModelFeatureImportances = filter.toFilter.andThen(compareLinearModelFeatureImportances),
          iterationsUntilConvergence = filter.toFilter.andThen(iterationsUntilConvergence),
          rankModels = filter.toFilter.andThen(rankModels),
          confidenceIntervals = filter.toFilter.andThen(confidenceIntervals),
          modelsWithFeatures = filter.toFilter.andThen(modelsWithFeatures),
          modelsDerivedFromDataFrame = filter.toFilter.andThen(modelsDerivedFromDataFrame),
          getProjectIds = filter.toFilter.andThen(getProjectIds),
          getModelIds = filter.toFilter.andThen(getModelIds),
          updateProject = filter.toFilter.andThen(updateProject),
          createOrUpdateScalarField = filter.toFilter.andThen(createOrUpdateScalarField),
          createVectorField = filter.toFilter.andThen(createVectorField),
          updateVectorField = filter.toFilter.andThen(updateVectorField),
          appendToVectorField = filter.toFilter.andThen(appendToVectorField),
          getModel = filter.toFilter.andThen(getModel),
          getRunsInExperiment = filter.toFilter.andThen(getRunsInExperiment),
          getRunsAndExperimentsInProject = filter.toFilter.andThen(getRunsAndExperimentsInProject),
          getProjectOverviews = filter.toFilter.andThen(getProjectOverviews),
          getExperimentRunDetails = filter.toFilter.andThen(getExperimentRunDetails),
          originalFeatures = filter.toFilter.andThen(originalFeatures),
          storeTreeModel = filter.toFilter.andThen(storeTreeModel),
          storePipelineTransformEvent = filter.toFilter.andThen(storePipelineTransformEvent),
          computeModelAncestry = filter.toFilter.andThen(computeModelAncestry),
          extractPipeline = filter.toFilter.andThen(extractPipeline)
        )

      override def asClosable: _root_.com.twitter.util.Closable =
        _root_.com.twitter.util.Closable.all(
          this.testConnection,
          this.storeDataFrame,
          this.pathForTransformer,
          this.storeFitEvent,
          this.storeMetricEvent,
          this.getFilePath,
          this.storeTransformEvent,
          this.storeRandomSplitEvent,
          this.storePipelineEvent,
          this.storeCrossValidationEvent,
          this.storeGridSearchCrossValidationEvent,
          this.storeAnnotationEvent,
          this.storeProjectEvent,
          this.storeExperimentEvent,
          this.storeExperimentRunEvent,
          this.storeLinearModel,
          this.getDataFrameAncestry,
          this.getCommonAncestor,
          this.getCommonAncestorForModels,
          this.getTrainingRowsCount,
          this.getTrainingRowsCounts,
          this.compareHyperparameters,
          this.compareFeatures,
          this.groupByProblemType,
          this.similarModels,
          this.linearModelFeatureImportances,
          this.compareLinearModelFeatureImportances,
          this.iterationsUntilConvergence,
          this.rankModels,
          this.confidenceIntervals,
          this.modelsWithFeatures,
          this.modelsDerivedFromDataFrame,
          this.getProjectIds,
          this.getModelIds,
          this.updateProject,
          this.createOrUpdateScalarField,
          this.createVectorField,
          this.updateVectorField,
          this.appendToVectorField,
          this.getModel,
          this.getRunsInExperiment,
          this.getRunsAndExperimentsInProject,
          this.getProjectOverviews,
          this.getExperimentRunDetails,
          this.originalFeatures,
          this.storeTreeModel,
          this.storePipelineTransformEvent,
          this.computeModelAncestry,
          this.extractPipeline
        )
    }
  }

  def unsafeBuildFromMethods(methods: immutable$Map[ThriftMethod,  _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[_], _root_.com.twitter.scrooge.Response[_]]]): ReqRepServicePerEndpoint = {
    val testConnection = methods.get(self.TestConnection) match {
      case Some(impl) => impl.asInstanceOf[self.TestConnection.ReqRepServicePerEndpointServiceType]
      case _ => throw new IllegalArgumentException(s"No implementation found for method TestConnection in ${methods.keySet}")
    }
    val storeDataFrame = methods.get(self.StoreDataFrame) match {
      case Some(impl) => impl.asInstanceOf[self.StoreDataFrame.ReqRepServicePerEndpointServiceType]
      case _ => throw new IllegalArgumentException(s"No implementation found for method StoreDataFrame in ${methods.keySet}")
    }
    val pathForTransformer = methods.get(self.PathForTransformer) match {
      case Some(impl) => impl.asInstanceOf[self.PathForTransformer.ReqRepServicePerEndpointServiceType]
      case _ => throw new IllegalArgumentException(s"No implementation found for method PathForTransformer in ${methods.keySet}")
    }
    val storeFitEvent = methods.get(self.StoreFitEvent) match {
      case Some(impl) => impl.asInstanceOf[self.StoreFitEvent.ReqRepServicePerEndpointServiceType]
      case _ => throw new IllegalArgumentException(s"No implementation found for method StoreFitEvent in ${methods.keySet}")
    }
    val storeMetricEvent = methods.get(self.StoreMetricEvent) match {
      case Some(impl) => impl.asInstanceOf[self.StoreMetricEvent.ReqRepServicePerEndpointServiceType]
      case _ => throw new IllegalArgumentException(s"No implementation found for method StoreMetricEvent in ${methods.keySet}")
    }
    val getFilePath = methods.get(self.GetFilePath) match {
      case Some(impl) => impl.asInstanceOf[self.GetFilePath.ReqRepServicePerEndpointServiceType]
      case _ => throw new IllegalArgumentException(s"No implementation found for method GetFilePath in ${methods.keySet}")
    }
    val storeTransformEvent = methods.get(self.StoreTransformEvent) match {
      case Some(impl) => impl.asInstanceOf[self.StoreTransformEvent.ReqRepServicePerEndpointServiceType]
      case _ => throw new IllegalArgumentException(s"No implementation found for method StoreTransformEvent in ${methods.keySet}")
    }
    val storeRandomSplitEvent = methods.get(self.StoreRandomSplitEvent) match {
      case Some(impl) => impl.asInstanceOf[self.StoreRandomSplitEvent.ReqRepServicePerEndpointServiceType]
      case _ => throw new IllegalArgumentException(s"No implementation found for method StoreRandomSplitEvent in ${methods.keySet}")
    }
    val storePipelineEvent = methods.get(self.StorePipelineEvent) match {
      case Some(impl) => impl.asInstanceOf[self.StorePipelineEvent.ReqRepServicePerEndpointServiceType]
      case _ => throw new IllegalArgumentException(s"No implementation found for method StorePipelineEvent in ${methods.keySet}")
    }
    val storeCrossValidationEvent = methods.get(self.StoreCrossValidationEvent) match {
      case Some(impl) => impl.asInstanceOf[self.StoreCrossValidationEvent.ReqRepServicePerEndpointServiceType]
      case _ => throw new IllegalArgumentException(s"No implementation found for method StoreCrossValidationEvent in ${methods.keySet}")
    }
    val storeGridSearchCrossValidationEvent = methods.get(self.StoreGridSearchCrossValidationEvent) match {
      case Some(impl) => impl.asInstanceOf[self.StoreGridSearchCrossValidationEvent.ReqRepServicePerEndpointServiceType]
      case _ => throw new IllegalArgumentException(s"No implementation found for method StoreGridSearchCrossValidationEvent in ${methods.keySet}")
    }
    val storeAnnotationEvent = methods.get(self.StoreAnnotationEvent) match {
      case Some(impl) => impl.asInstanceOf[self.StoreAnnotationEvent.ReqRepServicePerEndpointServiceType]
      case _ => throw new IllegalArgumentException(s"No implementation found for method StoreAnnotationEvent in ${methods.keySet}")
    }
    val storeProjectEvent = methods.get(self.StoreProjectEvent) match {
      case Some(impl) => impl.asInstanceOf[self.StoreProjectEvent.ReqRepServicePerEndpointServiceType]
      case _ => throw new IllegalArgumentException(s"No implementation found for method StoreProjectEvent in ${methods.keySet}")
    }
    val storeExperimentEvent = methods.get(self.StoreExperimentEvent) match {
      case Some(impl) => impl.asInstanceOf[self.StoreExperimentEvent.ReqRepServicePerEndpointServiceType]
      case _ => throw new IllegalArgumentException(s"No implementation found for method StoreExperimentEvent in ${methods.keySet}")
    }
    val storeExperimentRunEvent = methods.get(self.StoreExperimentRunEvent) match {
      case Some(impl) => impl.asInstanceOf[self.StoreExperimentRunEvent.ReqRepServicePerEndpointServiceType]
      case _ => throw new IllegalArgumentException(s"No implementation found for method StoreExperimentRunEvent in ${methods.keySet}")
    }
    val storeLinearModel = methods.get(self.StoreLinearModel) match {
      case Some(impl) => impl.asInstanceOf[self.StoreLinearModel.ReqRepServicePerEndpointServiceType]
      case _ => throw new IllegalArgumentException(s"No implementation found for method StoreLinearModel in ${methods.keySet}")
    }
    val getDataFrameAncestry = methods.get(self.GetDataFrameAncestry) match {
      case Some(impl) => impl.asInstanceOf[self.GetDataFrameAncestry.ReqRepServicePerEndpointServiceType]
      case _ => throw new IllegalArgumentException(s"No implementation found for method GetDataFrameAncestry in ${methods.keySet}")
    }
    val getCommonAncestor = methods.get(self.GetCommonAncestor) match {
      case Some(impl) => impl.asInstanceOf[self.GetCommonAncestor.ReqRepServicePerEndpointServiceType]
      case _ => throw new IllegalArgumentException(s"No implementation found for method GetCommonAncestor in ${methods.keySet}")
    }
    val getCommonAncestorForModels = methods.get(self.GetCommonAncestorForModels) match {
      case Some(impl) => impl.asInstanceOf[self.GetCommonAncestorForModels.ReqRepServicePerEndpointServiceType]
      case _ => throw new IllegalArgumentException(s"No implementation found for method GetCommonAncestorForModels in ${methods.keySet}")
    }
    val getTrainingRowsCount = methods.get(self.GetTrainingRowsCount) match {
      case Some(impl) => impl.asInstanceOf[self.GetTrainingRowsCount.ReqRepServicePerEndpointServiceType]
      case _ => throw new IllegalArgumentException(s"No implementation found for method GetTrainingRowsCount in ${methods.keySet}")
    }
    val getTrainingRowsCounts = methods.get(self.GetTrainingRowsCounts) match {
      case Some(impl) => impl.asInstanceOf[self.GetTrainingRowsCounts.ReqRepServicePerEndpointServiceType]
      case _ => throw new IllegalArgumentException(s"No implementation found for method GetTrainingRowsCounts in ${methods.keySet}")
    }
    val compareHyperparameters = methods.get(self.CompareHyperparameters) match {
      case Some(impl) => impl.asInstanceOf[self.CompareHyperparameters.ReqRepServicePerEndpointServiceType]
      case _ => throw new IllegalArgumentException(s"No implementation found for method CompareHyperparameters in ${methods.keySet}")
    }
    val compareFeatures = methods.get(self.CompareFeatures) match {
      case Some(impl) => impl.asInstanceOf[self.CompareFeatures.ReqRepServicePerEndpointServiceType]
      case _ => throw new IllegalArgumentException(s"No implementation found for method CompareFeatures in ${methods.keySet}")
    }
    val groupByProblemType = methods.get(self.GroupByProblemType) match {
      case Some(impl) => impl.asInstanceOf[self.GroupByProblemType.ReqRepServicePerEndpointServiceType]
      case _ => throw new IllegalArgumentException(s"No implementation found for method GroupByProblemType in ${methods.keySet}")
    }
    val similarModels = methods.get(self.SimilarModels) match {
      case Some(impl) => impl.asInstanceOf[self.SimilarModels.ReqRepServicePerEndpointServiceType]
      case _ => throw new IllegalArgumentException(s"No implementation found for method SimilarModels in ${methods.keySet}")
    }
    val linearModelFeatureImportances = methods.get(self.LinearModelFeatureImportances) match {
      case Some(impl) => impl.asInstanceOf[self.LinearModelFeatureImportances.ReqRepServicePerEndpointServiceType]
      case _ => throw new IllegalArgumentException(s"No implementation found for method LinearModelFeatureImportances in ${methods.keySet}")
    }
    val compareLinearModelFeatureImportances = methods.get(self.CompareLinearModelFeatureImportances) match {
      case Some(impl) => impl.asInstanceOf[self.CompareLinearModelFeatureImportances.ReqRepServicePerEndpointServiceType]
      case _ => throw new IllegalArgumentException(s"No implementation found for method CompareLinearModelFeatureImportances in ${methods.keySet}")
    }
    val iterationsUntilConvergence = methods.get(self.IterationsUntilConvergence) match {
      case Some(impl) => impl.asInstanceOf[self.IterationsUntilConvergence.ReqRepServicePerEndpointServiceType]
      case _ => throw new IllegalArgumentException(s"No implementation found for method IterationsUntilConvergence in ${methods.keySet}")
    }
    val rankModels = methods.get(self.RankModels) match {
      case Some(impl) => impl.asInstanceOf[self.RankModels.ReqRepServicePerEndpointServiceType]
      case _ => throw new IllegalArgumentException(s"No implementation found for method RankModels in ${methods.keySet}")
    }
    val confidenceIntervals = methods.get(self.ConfidenceIntervals) match {
      case Some(impl) => impl.asInstanceOf[self.ConfidenceIntervals.ReqRepServicePerEndpointServiceType]
      case _ => throw new IllegalArgumentException(s"No implementation found for method ConfidenceIntervals in ${methods.keySet}")
    }
    val modelsWithFeatures = methods.get(self.ModelsWithFeatures) match {
      case Some(impl) => impl.asInstanceOf[self.ModelsWithFeatures.ReqRepServicePerEndpointServiceType]
      case _ => throw new IllegalArgumentException(s"No implementation found for method ModelsWithFeatures in ${methods.keySet}")
    }
    val modelsDerivedFromDataFrame = methods.get(self.ModelsDerivedFromDataFrame) match {
      case Some(impl) => impl.asInstanceOf[self.ModelsDerivedFromDataFrame.ReqRepServicePerEndpointServiceType]
      case _ => throw new IllegalArgumentException(s"No implementation found for method ModelsDerivedFromDataFrame in ${methods.keySet}")
    }
    val getProjectIds = methods.get(self.GetProjectIds) match {
      case Some(impl) => impl.asInstanceOf[self.GetProjectIds.ReqRepServicePerEndpointServiceType]
      case _ => throw new IllegalArgumentException(s"No implementation found for method GetProjectIds in ${methods.keySet}")
    }
    val getModelIds = methods.get(self.GetModelIds) match {
      case Some(impl) => impl.asInstanceOf[self.GetModelIds.ReqRepServicePerEndpointServiceType]
      case _ => throw new IllegalArgumentException(s"No implementation found for method GetModelIds in ${methods.keySet}")
    }
    val updateProject = methods.get(self.UpdateProject) match {
      case Some(impl) => impl.asInstanceOf[self.UpdateProject.ReqRepServicePerEndpointServiceType]
      case _ => throw new IllegalArgumentException(s"No implementation found for method UpdateProject in ${methods.keySet}")
    }
    val createOrUpdateScalarField = methods.get(self.CreateOrUpdateScalarField) match {
      case Some(impl) => impl.asInstanceOf[self.CreateOrUpdateScalarField.ReqRepServicePerEndpointServiceType]
      case _ => throw new IllegalArgumentException(s"No implementation found for method CreateOrUpdateScalarField in ${methods.keySet}")
    }
    val createVectorField = methods.get(self.CreateVectorField) match {
      case Some(impl) => impl.asInstanceOf[self.CreateVectorField.ReqRepServicePerEndpointServiceType]
      case _ => throw new IllegalArgumentException(s"No implementation found for method CreateVectorField in ${methods.keySet}")
    }
    val updateVectorField = methods.get(self.UpdateVectorField) match {
      case Some(impl) => impl.asInstanceOf[self.UpdateVectorField.ReqRepServicePerEndpointServiceType]
      case _ => throw new IllegalArgumentException(s"No implementation found for method UpdateVectorField in ${methods.keySet}")
    }
    val appendToVectorField = methods.get(self.AppendToVectorField) match {
      case Some(impl) => impl.asInstanceOf[self.AppendToVectorField.ReqRepServicePerEndpointServiceType]
      case _ => throw new IllegalArgumentException(s"No implementation found for method AppendToVectorField in ${methods.keySet}")
    }
    val getModel = methods.get(self.GetModel) match {
      case Some(impl) => impl.asInstanceOf[self.GetModel.ReqRepServicePerEndpointServiceType]
      case _ => throw new IllegalArgumentException(s"No implementation found for method GetModel in ${methods.keySet}")
    }
    val getRunsInExperiment = methods.get(self.GetRunsInExperiment) match {
      case Some(impl) => impl.asInstanceOf[self.GetRunsInExperiment.ReqRepServicePerEndpointServiceType]
      case _ => throw new IllegalArgumentException(s"No implementation found for method GetRunsInExperiment in ${methods.keySet}")
    }
    val getRunsAndExperimentsInProject = methods.get(self.GetRunsAndExperimentsInProject) match {
      case Some(impl) => impl.asInstanceOf[self.GetRunsAndExperimentsInProject.ReqRepServicePerEndpointServiceType]
      case _ => throw new IllegalArgumentException(s"No implementation found for method GetRunsAndExperimentsInProject in ${methods.keySet}")
    }
    val getProjectOverviews = methods.get(self.GetProjectOverviews) match {
      case Some(impl) => impl.asInstanceOf[self.GetProjectOverviews.ReqRepServicePerEndpointServiceType]
      case _ => throw new IllegalArgumentException(s"No implementation found for method GetProjectOverviews in ${methods.keySet}")
    }
    val getExperimentRunDetails = methods.get(self.GetExperimentRunDetails) match {
      case Some(impl) => impl.asInstanceOf[self.GetExperimentRunDetails.ReqRepServicePerEndpointServiceType]
      case _ => throw new IllegalArgumentException(s"No implementation found for method GetExperimentRunDetails in ${methods.keySet}")
    }
    val originalFeatures = methods.get(self.OriginalFeatures) match {
      case Some(impl) => impl.asInstanceOf[self.OriginalFeatures.ReqRepServicePerEndpointServiceType]
      case _ => throw new IllegalArgumentException(s"No implementation found for method OriginalFeatures in ${methods.keySet}")
    }
    val storeTreeModel = methods.get(self.StoreTreeModel) match {
      case Some(impl) => impl.asInstanceOf[self.StoreTreeModel.ReqRepServicePerEndpointServiceType]
      case _ => throw new IllegalArgumentException(s"No implementation found for method StoreTreeModel in ${methods.keySet}")
    }
    val storePipelineTransformEvent = methods.get(self.StorePipelineTransformEvent) match {
      case Some(impl) => impl.asInstanceOf[self.StorePipelineTransformEvent.ReqRepServicePerEndpointServiceType]
      case _ => throw new IllegalArgumentException(s"No implementation found for method StorePipelineTransformEvent in ${methods.keySet}")
    }
    val computeModelAncestry = methods.get(self.ComputeModelAncestry) match {
      case Some(impl) => impl.asInstanceOf[self.ComputeModelAncestry.ReqRepServicePerEndpointServiceType]
      case _ => throw new IllegalArgumentException(s"No implementation found for method ComputeModelAncestry in ${methods.keySet}")
    }
    val extractPipeline = methods.get(self.ExtractPipeline) match {
      case Some(impl) => impl.asInstanceOf[self.ExtractPipeline.ReqRepServicePerEndpointServiceType]
      case _ => throw new IllegalArgumentException(s"No implementation found for method ExtractPipeline in ${methods.keySet}")
    }

    ReqRepServicePerEndpoint(testConnection, storeDataFrame, pathForTransformer, storeFitEvent, storeMetricEvent, getFilePath, storeTransformEvent, storeRandomSplitEvent, storePipelineEvent, storeCrossValidationEvent, storeGridSearchCrossValidationEvent, storeAnnotationEvent, storeProjectEvent, storeExperimentEvent, storeExperimentRunEvent, storeLinearModel, getDataFrameAncestry, getCommonAncestor, getCommonAncestorForModels, getTrainingRowsCount, getTrainingRowsCounts, compareHyperparameters, compareFeatures, groupByProblemType, similarModels, linearModelFeatureImportances, compareLinearModelFeatureImportances, iterationsUntilConvergence, rankModels, confidenceIntervals, modelsWithFeatures, modelsDerivedFromDataFrame, getProjectIds, getModelIds, updateProject, createOrUpdateScalarField, createVectorField, updateVectorField, appendToVectorField, getModel, getRunsInExperiment, getRunsAndExperimentsInProject, getProjectOverviews, getExperimentRunDetails, originalFeatures, storeTreeModel, storePipelineTransformEvent, computeModelAncestry, extractPipeline)
  }

  @deprecated("Use ServicePerEndpoint", "2017-11-07")
  case class ServiceIface(
    testConnection : com.twitter.finagle.Service[self.TestConnection.Args, self.TestConnection.SuccessType],
    storeDataFrame : com.twitter.finagle.Service[self.StoreDataFrame.Args, self.StoreDataFrame.SuccessType],
    pathForTransformer : com.twitter.finagle.Service[self.PathForTransformer.Args, self.PathForTransformer.SuccessType],
    storeFitEvent : com.twitter.finagle.Service[self.StoreFitEvent.Args, self.StoreFitEvent.SuccessType],
    storeMetricEvent : com.twitter.finagle.Service[self.StoreMetricEvent.Args, self.StoreMetricEvent.SuccessType],
    getFilePath : com.twitter.finagle.Service[self.GetFilePath.Args, self.GetFilePath.SuccessType],
    storeTransformEvent : com.twitter.finagle.Service[self.StoreTransformEvent.Args, self.StoreTransformEvent.SuccessType],
    storeRandomSplitEvent : com.twitter.finagle.Service[self.StoreRandomSplitEvent.Args, self.StoreRandomSplitEvent.SuccessType],
    storePipelineEvent : com.twitter.finagle.Service[self.StorePipelineEvent.Args, self.StorePipelineEvent.SuccessType],
    storeCrossValidationEvent : com.twitter.finagle.Service[self.StoreCrossValidationEvent.Args, self.StoreCrossValidationEvent.SuccessType],
    storeGridSearchCrossValidationEvent : com.twitter.finagle.Service[self.StoreGridSearchCrossValidationEvent.Args, self.StoreGridSearchCrossValidationEvent.SuccessType],
    storeAnnotationEvent : com.twitter.finagle.Service[self.StoreAnnotationEvent.Args, self.StoreAnnotationEvent.SuccessType],
    storeProjectEvent : com.twitter.finagle.Service[self.StoreProjectEvent.Args, self.StoreProjectEvent.SuccessType],
    storeExperimentEvent : com.twitter.finagle.Service[self.StoreExperimentEvent.Args, self.StoreExperimentEvent.SuccessType],
    storeExperimentRunEvent : com.twitter.finagle.Service[self.StoreExperimentRunEvent.Args, self.StoreExperimentRunEvent.SuccessType],
    storeLinearModel : com.twitter.finagle.Service[self.StoreLinearModel.Args, self.StoreLinearModel.SuccessType],
    getDataFrameAncestry : com.twitter.finagle.Service[self.GetDataFrameAncestry.Args, self.GetDataFrameAncestry.SuccessType],
    getCommonAncestor : com.twitter.finagle.Service[self.GetCommonAncestor.Args, self.GetCommonAncestor.SuccessType],
    getCommonAncestorForModels : com.twitter.finagle.Service[self.GetCommonAncestorForModels.Args, self.GetCommonAncestorForModels.SuccessType],
    getTrainingRowsCount : com.twitter.finagle.Service[self.GetTrainingRowsCount.Args, self.GetTrainingRowsCount.SuccessType],
    getTrainingRowsCounts : com.twitter.finagle.Service[self.GetTrainingRowsCounts.Args, self.GetTrainingRowsCounts.SuccessType],
    compareHyperparameters : com.twitter.finagle.Service[self.CompareHyperparameters.Args, self.CompareHyperparameters.SuccessType],
    compareFeatures : com.twitter.finagle.Service[self.CompareFeatures.Args, self.CompareFeatures.SuccessType],
    groupByProblemType : com.twitter.finagle.Service[self.GroupByProblemType.Args, self.GroupByProblemType.SuccessType],
    similarModels : com.twitter.finagle.Service[self.SimilarModels.Args, self.SimilarModels.SuccessType],
    linearModelFeatureImportances : com.twitter.finagle.Service[self.LinearModelFeatureImportances.Args, self.LinearModelFeatureImportances.SuccessType],
    compareLinearModelFeatureImportances : com.twitter.finagle.Service[self.CompareLinearModelFeatureImportances.Args, self.CompareLinearModelFeatureImportances.SuccessType],
    iterationsUntilConvergence : com.twitter.finagle.Service[self.IterationsUntilConvergence.Args, self.IterationsUntilConvergence.SuccessType],
    rankModels : com.twitter.finagle.Service[self.RankModels.Args, self.RankModels.SuccessType],
    confidenceIntervals : com.twitter.finagle.Service[self.ConfidenceIntervals.Args, self.ConfidenceIntervals.SuccessType],
    modelsWithFeatures : com.twitter.finagle.Service[self.ModelsWithFeatures.Args, self.ModelsWithFeatures.SuccessType],
    modelsDerivedFromDataFrame : com.twitter.finagle.Service[self.ModelsDerivedFromDataFrame.Args, self.ModelsDerivedFromDataFrame.SuccessType],
    getProjectIds : com.twitter.finagle.Service[self.GetProjectIds.Args, self.GetProjectIds.SuccessType],
    getModelIds : com.twitter.finagle.Service[self.GetModelIds.Args, self.GetModelIds.SuccessType],
    updateProject : com.twitter.finagle.Service[self.UpdateProject.Args, self.UpdateProject.SuccessType],
    createOrUpdateScalarField : com.twitter.finagle.Service[self.CreateOrUpdateScalarField.Args, self.CreateOrUpdateScalarField.SuccessType],
    createVectorField : com.twitter.finagle.Service[self.CreateVectorField.Args, self.CreateVectorField.SuccessType],
    updateVectorField : com.twitter.finagle.Service[self.UpdateVectorField.Args, self.UpdateVectorField.SuccessType],
    appendToVectorField : com.twitter.finagle.Service[self.AppendToVectorField.Args, self.AppendToVectorField.SuccessType],
    getModel : com.twitter.finagle.Service[self.GetModel.Args, self.GetModel.SuccessType],
    getRunsInExperiment : com.twitter.finagle.Service[self.GetRunsInExperiment.Args, self.GetRunsInExperiment.SuccessType],
    getRunsAndExperimentsInProject : com.twitter.finagle.Service[self.GetRunsAndExperimentsInProject.Args, self.GetRunsAndExperimentsInProject.SuccessType],
    getProjectOverviews : com.twitter.finagle.Service[self.GetProjectOverviews.Args, self.GetProjectOverviews.SuccessType],
    getExperimentRunDetails : com.twitter.finagle.Service[self.GetExperimentRunDetails.Args, self.GetExperimentRunDetails.SuccessType],
    originalFeatures : com.twitter.finagle.Service[self.OriginalFeatures.Args, self.OriginalFeatures.SuccessType],
    storeTreeModel : com.twitter.finagle.Service[self.StoreTreeModel.Args, self.StoreTreeModel.SuccessType],
    storePipelineTransformEvent : com.twitter.finagle.Service[self.StorePipelineTransformEvent.Args, self.StorePipelineTransformEvent.SuccessType],
    computeModelAncestry : com.twitter.finagle.Service[self.ComputeModelAncestry.Args, self.ComputeModelAncestry.SuccessType],
    extractPipeline : com.twitter.finagle.Service[self.ExtractPipeline.Args, self.ExtractPipeline.SuccessType]
  ) extends BaseServiceIface
    with com.twitter.finagle.thrift.ThriftServiceIface.Filterable[ServiceIface] {

    /**
     * Prepends the given type-agnostic `Filter` to all of the `Services`
     * and returns a copy of the `ServiceIface` now including the filter.
     */
    def filtered(filter: com.twitter.finagle.Filter.TypeAgnostic): ServiceIface =
      copy(
        testConnection = filter.toFilter.andThen(testConnection),
        storeDataFrame = filter.toFilter.andThen(storeDataFrame),
        pathForTransformer = filter.toFilter.andThen(pathForTransformer),
        storeFitEvent = filter.toFilter.andThen(storeFitEvent),
        storeMetricEvent = filter.toFilter.andThen(storeMetricEvent),
        getFilePath = filter.toFilter.andThen(getFilePath),
        storeTransformEvent = filter.toFilter.andThen(storeTransformEvent),
        storeRandomSplitEvent = filter.toFilter.andThen(storeRandomSplitEvent),
        storePipelineEvent = filter.toFilter.andThen(storePipelineEvent),
        storeCrossValidationEvent = filter.toFilter.andThen(storeCrossValidationEvent),
        storeGridSearchCrossValidationEvent = filter.toFilter.andThen(storeGridSearchCrossValidationEvent),
        storeAnnotationEvent = filter.toFilter.andThen(storeAnnotationEvent),
        storeProjectEvent = filter.toFilter.andThen(storeProjectEvent),
        storeExperimentEvent = filter.toFilter.andThen(storeExperimentEvent),
        storeExperimentRunEvent = filter.toFilter.andThen(storeExperimentRunEvent),
        storeLinearModel = filter.toFilter.andThen(storeLinearModel),
        getDataFrameAncestry = filter.toFilter.andThen(getDataFrameAncestry),
        getCommonAncestor = filter.toFilter.andThen(getCommonAncestor),
        getCommonAncestorForModels = filter.toFilter.andThen(getCommonAncestorForModels),
        getTrainingRowsCount = filter.toFilter.andThen(getTrainingRowsCount),
        getTrainingRowsCounts = filter.toFilter.andThen(getTrainingRowsCounts),
        compareHyperparameters = filter.toFilter.andThen(compareHyperparameters),
        compareFeatures = filter.toFilter.andThen(compareFeatures),
        groupByProblemType = filter.toFilter.andThen(groupByProblemType),
        similarModels = filter.toFilter.andThen(similarModels),
        linearModelFeatureImportances = filter.toFilter.andThen(linearModelFeatureImportances),
        compareLinearModelFeatureImportances = filter.toFilter.andThen(compareLinearModelFeatureImportances),
        iterationsUntilConvergence = filter.toFilter.andThen(iterationsUntilConvergence),
        rankModels = filter.toFilter.andThen(rankModels),
        confidenceIntervals = filter.toFilter.andThen(confidenceIntervals),
        modelsWithFeatures = filter.toFilter.andThen(modelsWithFeatures),
        modelsDerivedFromDataFrame = filter.toFilter.andThen(modelsDerivedFromDataFrame),
        getProjectIds = filter.toFilter.andThen(getProjectIds),
        getModelIds = filter.toFilter.andThen(getModelIds),
        updateProject = filter.toFilter.andThen(updateProject),
        createOrUpdateScalarField = filter.toFilter.andThen(createOrUpdateScalarField),
        createVectorField = filter.toFilter.andThen(createVectorField),
        updateVectorField = filter.toFilter.andThen(updateVectorField),
        appendToVectorField = filter.toFilter.andThen(appendToVectorField),
        getModel = filter.toFilter.andThen(getModel),
        getRunsInExperiment = filter.toFilter.andThen(getRunsInExperiment),
        getRunsAndExperimentsInProject = filter.toFilter.andThen(getRunsAndExperimentsInProject),
        getProjectOverviews = filter.toFilter.andThen(getProjectOverviews),
        getExperimentRunDetails = filter.toFilter.andThen(getExperimentRunDetails),
        originalFeatures = filter.toFilter.andThen(originalFeatures),
        storeTreeModel = filter.toFilter.andThen(storeTreeModel),
        storePipelineTransformEvent = filter.toFilter.andThen(storePipelineTransformEvent),
        computeModelAncestry = filter.toFilter.andThen(computeModelAncestry),
        extractPipeline = filter.toFilter.andThen(extractPipeline)
      )
  }

  implicit object ServicePerEndpointBuilder
    extends _root_.com.twitter.finagle.thrift.service.ServicePerEndpointBuilder[ServicePerEndpoint] {
      def servicePerEndpoint(
        thriftService: _root_.com.twitter.finagle.Service[ThriftClientRequest, Array[Byte]],
        clientParam: RichClientParam
      ): ServicePerEndpoint =
        ServicePerEndpoint(
          testConnection = ThriftServiceIface(self.TestConnection, thriftService, clientParam),
          storeDataFrame = ThriftServiceIface(self.StoreDataFrame, thriftService, clientParam),
          pathForTransformer = ThriftServiceIface(self.PathForTransformer, thriftService, clientParam),
          storeFitEvent = ThriftServiceIface(self.StoreFitEvent, thriftService, clientParam),
          storeMetricEvent = ThriftServiceIface(self.StoreMetricEvent, thriftService, clientParam),
          getFilePath = ThriftServiceIface(self.GetFilePath, thriftService, clientParam),
          storeTransformEvent = ThriftServiceIface(self.StoreTransformEvent, thriftService, clientParam),
          storeRandomSplitEvent = ThriftServiceIface(self.StoreRandomSplitEvent, thriftService, clientParam),
          storePipelineEvent = ThriftServiceIface(self.StorePipelineEvent, thriftService, clientParam),
          storeCrossValidationEvent = ThriftServiceIface(self.StoreCrossValidationEvent, thriftService, clientParam),
          storeGridSearchCrossValidationEvent = ThriftServiceIface(self.StoreGridSearchCrossValidationEvent, thriftService, clientParam),
          storeAnnotationEvent = ThriftServiceIface(self.StoreAnnotationEvent, thriftService, clientParam),
          storeProjectEvent = ThriftServiceIface(self.StoreProjectEvent, thriftService, clientParam),
          storeExperimentEvent = ThriftServiceIface(self.StoreExperimentEvent, thriftService, clientParam),
          storeExperimentRunEvent = ThriftServiceIface(self.StoreExperimentRunEvent, thriftService, clientParam),
          storeLinearModel = ThriftServiceIface(self.StoreLinearModel, thriftService, clientParam),
          getDataFrameAncestry = ThriftServiceIface(self.GetDataFrameAncestry, thriftService, clientParam),
          getCommonAncestor = ThriftServiceIface(self.GetCommonAncestor, thriftService, clientParam),
          getCommonAncestorForModels = ThriftServiceIface(self.GetCommonAncestorForModels, thriftService, clientParam),
          getTrainingRowsCount = ThriftServiceIface(self.GetTrainingRowsCount, thriftService, clientParam),
          getTrainingRowsCounts = ThriftServiceIface(self.GetTrainingRowsCounts, thriftService, clientParam),
          compareHyperparameters = ThriftServiceIface(self.CompareHyperparameters, thriftService, clientParam),
          compareFeatures = ThriftServiceIface(self.CompareFeatures, thriftService, clientParam),
          groupByProblemType = ThriftServiceIface(self.GroupByProblemType, thriftService, clientParam),
          similarModels = ThriftServiceIface(self.SimilarModels, thriftService, clientParam),
          linearModelFeatureImportances = ThriftServiceIface(self.LinearModelFeatureImportances, thriftService, clientParam),
          compareLinearModelFeatureImportances = ThriftServiceIface(self.CompareLinearModelFeatureImportances, thriftService, clientParam),
          iterationsUntilConvergence = ThriftServiceIface(self.IterationsUntilConvergence, thriftService, clientParam),
          rankModels = ThriftServiceIface(self.RankModels, thriftService, clientParam),
          confidenceIntervals = ThriftServiceIface(self.ConfidenceIntervals, thriftService, clientParam),
          modelsWithFeatures = ThriftServiceIface(self.ModelsWithFeatures, thriftService, clientParam),
          modelsDerivedFromDataFrame = ThriftServiceIface(self.ModelsDerivedFromDataFrame, thriftService, clientParam),
          getProjectIds = ThriftServiceIface(self.GetProjectIds, thriftService, clientParam),
          getModelIds = ThriftServiceIface(self.GetModelIds, thriftService, clientParam),
          updateProject = ThriftServiceIface(self.UpdateProject, thriftService, clientParam),
          createOrUpdateScalarField = ThriftServiceIface(self.CreateOrUpdateScalarField, thriftService, clientParam),
          createVectorField = ThriftServiceIface(self.CreateVectorField, thriftService, clientParam),
          updateVectorField = ThriftServiceIface(self.UpdateVectorField, thriftService, clientParam),
          appendToVectorField = ThriftServiceIface(self.AppendToVectorField, thriftService, clientParam),
          getModel = ThriftServiceIface(self.GetModel, thriftService, clientParam),
          getRunsInExperiment = ThriftServiceIface(self.GetRunsInExperiment, thriftService, clientParam),
          getRunsAndExperimentsInProject = ThriftServiceIface(self.GetRunsAndExperimentsInProject, thriftService, clientParam),
          getProjectOverviews = ThriftServiceIface(self.GetProjectOverviews, thriftService, clientParam),
          getExperimentRunDetails = ThriftServiceIface(self.GetExperimentRunDetails, thriftService, clientParam),
          originalFeatures = ThriftServiceIface(self.OriginalFeatures, thriftService, clientParam),
          storeTreeModel = ThriftServiceIface(self.StoreTreeModel, thriftService, clientParam),
          storePipelineTransformEvent = ThriftServiceIface(self.StorePipelineTransformEvent, thriftService, clientParam),
          computeModelAncestry = ThriftServiceIface(self.ComputeModelAncestry, thriftService, clientParam),
          extractPipeline = ThriftServiceIface(self.ExtractPipeline, thriftService, clientParam)
        )
  }

  implicit object ReqRepServicePerEndpointBuilder
    extends _root_.com.twitter.finagle.thrift.service.ReqRepServicePerEndpointBuilder[ReqRepServicePerEndpoint] {
      def servicePerEndpoint(
        thriftService: _root_.com.twitter.finagle.Service[ThriftClientRequest, Array[Byte]],
        clientParam: RichClientParam
      ): ReqRepServicePerEndpoint =
        ReqRepServicePerEndpoint(
          testConnection = _root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint(self.TestConnection, thriftService, clientParam),
          storeDataFrame = _root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint(self.StoreDataFrame, thriftService, clientParam),
          pathForTransformer = _root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint(self.PathForTransformer, thriftService, clientParam),
          storeFitEvent = _root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint(self.StoreFitEvent, thriftService, clientParam),
          storeMetricEvent = _root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint(self.StoreMetricEvent, thriftService, clientParam),
          getFilePath = _root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint(self.GetFilePath, thriftService, clientParam),
          storeTransformEvent = _root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint(self.StoreTransformEvent, thriftService, clientParam),
          storeRandomSplitEvent = _root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint(self.StoreRandomSplitEvent, thriftService, clientParam),
          storePipelineEvent = _root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint(self.StorePipelineEvent, thriftService, clientParam),
          storeCrossValidationEvent = _root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint(self.StoreCrossValidationEvent, thriftService, clientParam),
          storeGridSearchCrossValidationEvent = _root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint(self.StoreGridSearchCrossValidationEvent, thriftService, clientParam),
          storeAnnotationEvent = _root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint(self.StoreAnnotationEvent, thriftService, clientParam),
          storeProjectEvent = _root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint(self.StoreProjectEvent, thriftService, clientParam),
          storeExperimentEvent = _root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint(self.StoreExperimentEvent, thriftService, clientParam),
          storeExperimentRunEvent = _root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint(self.StoreExperimentRunEvent, thriftService, clientParam),
          storeLinearModel = _root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint(self.StoreLinearModel, thriftService, clientParam),
          getDataFrameAncestry = _root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint(self.GetDataFrameAncestry, thriftService, clientParam),
          getCommonAncestor = _root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint(self.GetCommonAncestor, thriftService, clientParam),
          getCommonAncestorForModels = _root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint(self.GetCommonAncestorForModels, thriftService, clientParam),
          getTrainingRowsCount = _root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint(self.GetTrainingRowsCount, thriftService, clientParam),
          getTrainingRowsCounts = _root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint(self.GetTrainingRowsCounts, thriftService, clientParam),
          compareHyperparameters = _root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint(self.CompareHyperparameters, thriftService, clientParam),
          compareFeatures = _root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint(self.CompareFeatures, thriftService, clientParam),
          groupByProblemType = _root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint(self.GroupByProblemType, thriftService, clientParam),
          similarModels = _root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint(self.SimilarModels, thriftService, clientParam),
          linearModelFeatureImportances = _root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint(self.LinearModelFeatureImportances, thriftService, clientParam),
          compareLinearModelFeatureImportances = _root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint(self.CompareLinearModelFeatureImportances, thriftService, clientParam),
          iterationsUntilConvergence = _root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint(self.IterationsUntilConvergence, thriftService, clientParam),
          rankModels = _root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint(self.RankModels, thriftService, clientParam),
          confidenceIntervals = _root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint(self.ConfidenceIntervals, thriftService, clientParam),
          modelsWithFeatures = _root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint(self.ModelsWithFeatures, thriftService, clientParam),
          modelsDerivedFromDataFrame = _root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint(self.ModelsDerivedFromDataFrame, thriftService, clientParam),
          getProjectIds = _root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint(self.GetProjectIds, thriftService, clientParam),
          getModelIds = _root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint(self.GetModelIds, thriftService, clientParam),
          updateProject = _root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint(self.UpdateProject, thriftService, clientParam),
          createOrUpdateScalarField = _root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint(self.CreateOrUpdateScalarField, thriftService, clientParam),
          createVectorField = _root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint(self.CreateVectorField, thriftService, clientParam),
          updateVectorField = _root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint(self.UpdateVectorField, thriftService, clientParam),
          appendToVectorField = _root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint(self.AppendToVectorField, thriftService, clientParam),
          getModel = _root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint(self.GetModel, thriftService, clientParam),
          getRunsInExperiment = _root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint(self.GetRunsInExperiment, thriftService, clientParam),
          getRunsAndExperimentsInProject = _root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint(self.GetRunsAndExperimentsInProject, thriftService, clientParam),
          getProjectOverviews = _root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint(self.GetProjectOverviews, thriftService, clientParam),
          getExperimentRunDetails = _root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint(self.GetExperimentRunDetails, thriftService, clientParam),
          originalFeatures = _root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint(self.OriginalFeatures, thriftService, clientParam),
          storeTreeModel = _root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint(self.StoreTreeModel, thriftService, clientParam),
          storePipelineTransformEvent = _root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint(self.StorePipelineTransformEvent, thriftService, clientParam),
          computeModelAncestry = _root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint(self.ComputeModelAncestry, thriftService, clientParam),
          extractPipeline = _root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint(self.ExtractPipeline, thriftService, clientParam)
        )
  }

  @deprecated("Use ServicePerEndpointBuilder", "2017-11-07")
  implicit object ServiceIfaceBuilder
    extends com.twitter.finagle.thrift.ServiceIfaceBuilder[ServiceIface] {
      def newServiceIface(
        binaryService: com.twitter.finagle.Service[ThriftClientRequest, Array[Byte]],
        clientParam: RichClientParam
      ): ServiceIface =
        ServiceIface(
          testConnection = ThriftServiceIface(self.TestConnection, binaryService, clientParam),
          storeDataFrame = ThriftServiceIface(self.StoreDataFrame, binaryService, clientParam),
          pathForTransformer = ThriftServiceIface(self.PathForTransformer, binaryService, clientParam),
          storeFitEvent = ThriftServiceIface(self.StoreFitEvent, binaryService, clientParam),
          storeMetricEvent = ThriftServiceIface(self.StoreMetricEvent, binaryService, clientParam),
          getFilePath = ThriftServiceIface(self.GetFilePath, binaryService, clientParam),
          storeTransformEvent = ThriftServiceIface(self.StoreTransformEvent, binaryService, clientParam),
          storeRandomSplitEvent = ThriftServiceIface(self.StoreRandomSplitEvent, binaryService, clientParam),
          storePipelineEvent = ThriftServiceIface(self.StorePipelineEvent, binaryService, clientParam),
          storeCrossValidationEvent = ThriftServiceIface(self.StoreCrossValidationEvent, binaryService, clientParam),
          storeGridSearchCrossValidationEvent = ThriftServiceIface(self.StoreGridSearchCrossValidationEvent, binaryService, clientParam),
          storeAnnotationEvent = ThriftServiceIface(self.StoreAnnotationEvent, binaryService, clientParam),
          storeProjectEvent = ThriftServiceIface(self.StoreProjectEvent, binaryService, clientParam),
          storeExperimentEvent = ThriftServiceIface(self.StoreExperimentEvent, binaryService, clientParam),
          storeExperimentRunEvent = ThriftServiceIface(self.StoreExperimentRunEvent, binaryService, clientParam),
          storeLinearModel = ThriftServiceIface(self.StoreLinearModel, binaryService, clientParam),
          getDataFrameAncestry = ThriftServiceIface(self.GetDataFrameAncestry, binaryService, clientParam),
          getCommonAncestor = ThriftServiceIface(self.GetCommonAncestor, binaryService, clientParam),
          getCommonAncestorForModels = ThriftServiceIface(self.GetCommonAncestorForModels, binaryService, clientParam),
          getTrainingRowsCount = ThriftServiceIface(self.GetTrainingRowsCount, binaryService, clientParam),
          getTrainingRowsCounts = ThriftServiceIface(self.GetTrainingRowsCounts, binaryService, clientParam),
          compareHyperparameters = ThriftServiceIface(self.CompareHyperparameters, binaryService, clientParam),
          compareFeatures = ThriftServiceIface(self.CompareFeatures, binaryService, clientParam),
          groupByProblemType = ThriftServiceIface(self.GroupByProblemType, binaryService, clientParam),
          similarModels = ThriftServiceIface(self.SimilarModels, binaryService, clientParam),
          linearModelFeatureImportances = ThriftServiceIface(self.LinearModelFeatureImportances, binaryService, clientParam),
          compareLinearModelFeatureImportances = ThriftServiceIface(self.CompareLinearModelFeatureImportances, binaryService, clientParam),
          iterationsUntilConvergence = ThriftServiceIface(self.IterationsUntilConvergence, binaryService, clientParam),
          rankModels = ThriftServiceIface(self.RankModels, binaryService, clientParam),
          confidenceIntervals = ThriftServiceIface(self.ConfidenceIntervals, binaryService, clientParam),
          modelsWithFeatures = ThriftServiceIface(self.ModelsWithFeatures, binaryService, clientParam),
          modelsDerivedFromDataFrame = ThriftServiceIface(self.ModelsDerivedFromDataFrame, binaryService, clientParam),
          getProjectIds = ThriftServiceIface(self.GetProjectIds, binaryService, clientParam),
          getModelIds = ThriftServiceIface(self.GetModelIds, binaryService, clientParam),
          updateProject = ThriftServiceIface(self.UpdateProject, binaryService, clientParam),
          createOrUpdateScalarField = ThriftServiceIface(self.CreateOrUpdateScalarField, binaryService, clientParam),
          createVectorField = ThriftServiceIface(self.CreateVectorField, binaryService, clientParam),
          updateVectorField = ThriftServiceIface(self.UpdateVectorField, binaryService, clientParam),
          appendToVectorField = ThriftServiceIface(self.AppendToVectorField, binaryService, clientParam),
          getModel = ThriftServiceIface(self.GetModel, binaryService, clientParam),
          getRunsInExperiment = ThriftServiceIface(self.GetRunsInExperiment, binaryService, clientParam),
          getRunsAndExperimentsInProject = ThriftServiceIface(self.GetRunsAndExperimentsInProject, binaryService, clientParam),
          getProjectOverviews = ThriftServiceIface(self.GetProjectOverviews, binaryService, clientParam),
          getExperimentRunDetails = ThriftServiceIface(self.GetExperimentRunDetails, binaryService, clientParam),
          originalFeatures = ThriftServiceIface(self.OriginalFeatures, binaryService, clientParam),
          storeTreeModel = ThriftServiceIface(self.StoreTreeModel, binaryService, clientParam),
          storePipelineTransformEvent = ThriftServiceIface(self.StorePipelineTransformEvent, binaryService, clientParam),
          computeModelAncestry = ThriftServiceIface(self.ComputeModelAncestry, binaryService, clientParam),
          extractPipeline = ThriftServiceIface(self.ExtractPipeline, binaryService, clientParam)
        )
  }

  object TestConnection extends ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("testConnection_args")
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
        )
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Args(
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
      ): Args =
        new Args(
        )
    
      def unapply(_item: Args): Boolean = true
    
    
    
    }
    
    class Args(
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
    
      def this(
      ) = this(
        Map.empty
      )
    
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 0
    
      override def productElement(n: Int): Any = n match {
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    }

    type SuccessType = Int
    
    object Result extends ValidatingThriftStructCodec3[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("testConnection_result")
      val SuccessField: TField = new TField("success", TType.I32, 0)
      val SuccessFieldManifest: Manifest[Int] = implicitly[Manifest[Int]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                field
              }
            }
        )
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[Int] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.I32 =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.I32
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[Int] = _root_.scala.None
      ): Result =
        new Result(
          success
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Option[Int]] = _root_.scala.Some(_item.success)
    
    
      @inline private[modeldb] def readSuccessValue(_iprot: TProtocol): Int = {
        _iprot.readI32()
      }
    
      @inline private def writeSuccessField(success_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeI32(success_item)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[Int],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[Int] with ThriftStruct
      with _root_.scala.Product1[Option[Int]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
    
      def this(
        success: _root_.scala.Option[Int] = _root_.scala.None
      ) = this(
        success,
        Map.empty
      )
    
      def _1: _root_.scala.Option[Int] = success
    
      def successField: Option[Int] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Seq()
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[Int] = this.success,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Function1[Args,Future[Int]]
    type ReqRepFunctionType = Function1[_root_.com.twitter.scrooge.Request[Args],Future[_root_.com.twitter.scrooge.Response[Int]]]

    type ServiceIfaceServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ReqRepServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]]

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]] { request: _root_.com.twitter.scrooge.Request[Args] =>
        f(request)
      }

    private[this] val toResult = (res: SuccessType) => Result(Some(res))

    val name: String = "testConnection"
    val serviceName: String = "ModelDBService"
    val argsCodec = Args
    val responseCodec = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val testConnection$args = TestConnection.Args
  type testConnection$args = TestConnection.Args

  val testConnection$result = TestConnection.Result
  type testConnection$result = TestConnection.Result

  object StoreDataFrame extends ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("storeDataFrame_args")
      val DfField: TField = new TField("df", TType.STRUCT, 1)
      val DfFieldManifest: Manifest[modeldb.DataFrame] = implicitly[Manifest[modeldb.DataFrame]]
      val ExperimentRunIdField: TField = new TField("experimentRunId", TType.I32, 2)
      val ExperimentRunIdFieldManifest: Manifest[Int] = implicitly[Manifest[Int]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          DfField,
          false,
          false,
          DfFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          ExperimentRunIdField,
          false,
          false,
          ExperimentRunIdFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.df)
        buf ++= validateField(item.experimentRunId)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          df =
            {
              val field = original.df
              modeldb.DataFrame.withoutPassthroughFields(field)
            },
          experimentRunId =
            {
              val field = original.experimentRunId
              field
            }
        )
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var df: modeldb.DataFrame = null
        var experimentRunId: Int = 0
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    df = readDfValue(_iprot)
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'df' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 2 =>
                _field.`type` match {
                  case TType.I32 =>
                    experimentRunId = readExperimentRunIdValue(_iprot)
                  case _actualType =>
                    val _expectedType = TType.I32
                    throw new TProtocolException(
                      "Received wrong type for field 'experimentRunId' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Args(
          df,
          experimentRunId,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        df: modeldb.DataFrame,
        experimentRunId: Int
      ): Args =
        new Args(
          df,
          experimentRunId
        )
    
      def unapply(_item: Args): _root_.scala.Option[_root_.scala.Tuple2[modeldb.DataFrame, Int]] = _root_.scala.Some(_item.toTuple)
    
    
      @inline private[modeldb] def readDfValue(_iprot: TProtocol): modeldb.DataFrame = {
        modeldb.DataFrame.decode(_iprot)
      }
    
      @inline private def writeDfField(df_item: modeldb.DataFrame, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(DfField)
        writeDfValue(df_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeDfValue(df_item: modeldb.DataFrame, _oprot: TProtocol): Unit = {
        df_item.write(_oprot)
      }
    
      @inline private[modeldb] def readExperimentRunIdValue(_iprot: TProtocol): Int = {
        _iprot.readI32()
      }
    
      @inline private def writeExperimentRunIdField(experimentRunId_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(ExperimentRunIdField)
        writeExperimentRunIdValue(experimentRunId_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeExperimentRunIdValue(experimentRunId_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeI32(experimentRunId_item)
      }
    
    
    }
    
    class Args(
        val df: modeldb.DataFrame,
        val experimentRunId: Int,
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product2[modeldb.DataFrame, Int]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
    
      def this(
        df: modeldb.DataFrame,
        experimentRunId: Int
      ) = this(
        df,
        experimentRunId,
        Map.empty
      )
    
      def _1: modeldb.DataFrame = df
      def _2: Int = experimentRunId
    
      def toTuple: _root_.scala.Tuple2[modeldb.DataFrame, Int] = {
        (
          df,
          experimentRunId
        )
      }
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        if (df ne null) writeDfField(df, _oprot)
        writeExperimentRunIdField(experimentRunId, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        df: modeldb.DataFrame = this.df,
        experimentRunId: Int = this.experimentRunId,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          df,
          experimentRunId,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 2
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.df
        case 1 => this.experimentRunId
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    }

    type SuccessType = Int
    
    object Result extends ValidatingThriftStructCodec3[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("storeDataFrame_result")
      val SuccessField: TField = new TField("success", TType.I32, 0)
      val SuccessFieldManifest: Manifest[Int] = implicitly[Manifest[Int]]
      val IerExField: TField = new TField("ierEx", TType.STRUCT, 1)
      val IerExFieldManifest: Manifest[modeldb.InvalidExperimentRunException] = implicitly[Manifest[modeldb.InvalidExperimentRunException]]
      val SvExField: TField = new TField("svEx", TType.STRUCT, 2)
      val SvExFieldManifest: Manifest[modeldb.ServerLogicException] = implicitly[Manifest[modeldb.ServerLogicException]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          IerExField,
          true,
          false,
          IerExFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          SvExField,
          true,
          false,
          SvExFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf ++= validateField(item.ierEx)
        buf ++= validateField(item.svEx)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                field
              }
            },
          ierEx =
            {
              val field = original.ierEx
              field.map { field =>
                modeldb.InvalidExperimentRunException.withoutPassthroughFields(field)
              }
            },
          svEx =
            {
              val field = original.svEx
              field.map { field =>
                modeldb.ServerLogicException.withoutPassthroughFields(field)
              }
            }
        )
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[Int] = _root_.scala.None
        var ierEx: _root_.scala.Option[modeldb.InvalidExperimentRunException] = _root_.scala.None
        var svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.I32 =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.I32
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 1 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    ierEx = _root_.scala.Some(readIerExValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'ierEx' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 2 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    svEx = _root_.scala.Some(readSvExValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'svEx' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          ierEx,
          svEx,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[Int] = _root_.scala.None,
        ierEx: _root_.scala.Option[modeldb.InvalidExperimentRunException] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ): Result =
        new Result(
          success,
          ierEx,
          svEx
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Tuple3[Option[Int], Option[modeldb.InvalidExperimentRunException], Option[modeldb.ServerLogicException]]] = _root_.scala.Some(_item.toTuple)
    
    
      @inline private[modeldb] def readSuccessValue(_iprot: TProtocol): Int = {
        _iprot.readI32()
      }
    
      @inline private def writeSuccessField(success_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeI32(success_item)
      }
    
      @inline private[modeldb] def readIerExValue(_iprot: TProtocol): modeldb.InvalidExperimentRunException = {
        modeldb.InvalidExperimentRunException.decode(_iprot)
      }
    
      @inline private def writeIerExField(ierEx_item: modeldb.InvalidExperimentRunException, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(IerExField)
        writeIerExValue(ierEx_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeIerExValue(ierEx_item: modeldb.InvalidExperimentRunException, _oprot: TProtocol): Unit = {
        ierEx_item.write(_oprot)
      }
    
      @inline private[modeldb] def readSvExValue(_iprot: TProtocol): modeldb.ServerLogicException = {
        modeldb.ServerLogicException.decode(_iprot)
      }
    
      @inline private def writeSvExField(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SvExField)
        writeSvExValue(svEx_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSvExValue(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        svEx_item.write(_oprot)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[Int],
        val ierEx: _root_.scala.Option[modeldb.InvalidExperimentRunException],
        val svEx: _root_.scala.Option[modeldb.ServerLogicException],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[Int] with ThriftStruct
      with _root_.scala.Product3[Option[Int], Option[modeldb.InvalidExperimentRunException], Option[modeldb.ServerLogicException]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
    
      def this(
        success: _root_.scala.Option[Int] = _root_.scala.None,
        ierEx: _root_.scala.Option[modeldb.InvalidExperimentRunException] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ) = this(
        success,
        ierEx,
        svEx,
        Map.empty
      )
    
      def _1: _root_.scala.Option[Int] = success
      def _2: _root_.scala.Option[modeldb.InvalidExperimentRunException] = ierEx
      def _3: _root_.scala.Option[modeldb.ServerLogicException] = svEx
    
      def toTuple: _root_.scala.Tuple3[Option[Int], Option[modeldb.InvalidExperimentRunException], Option[modeldb.ServerLogicException]] = {
        (
          success,
          ierEx,
          svEx
        )
      }
    
      def successField: Option[Int] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Seq(ierEx, svEx)
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (ierEx.isDefined) writeIerExField(ierEx.get, _oprot)
        if (svEx.isDefined) writeSvExField(svEx.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[Int] = this.success,
        ierEx: _root_.scala.Option[modeldb.InvalidExperimentRunException] = this.ierEx,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = this.svEx,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          ierEx,
          svEx,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 3
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case 1 => this.ierEx
        case 2 => this.svEx
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Function1[Args,Future[Int]]
    type ReqRepFunctionType = Function1[_root_.com.twitter.scrooge.Request[Args],Future[_root_.com.twitter.scrooge.Response[Int]]]

    type ServiceIfaceServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ReqRepServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]]

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]] { request: _root_.com.twitter.scrooge.Request[Args] =>
        f(request)
      }

    private[this] val toResult = (res: SuccessType) => Result(Some(res))

    val name: String = "storeDataFrame"
    val serviceName: String = "ModelDBService"
    val argsCodec = Args
    val responseCodec = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val storeDataFrame$args = StoreDataFrame.Args
  type storeDataFrame$args = StoreDataFrame.Args

  val storeDataFrame$result = StoreDataFrame.Result
  type storeDataFrame$result = StoreDataFrame.Result

  object PathForTransformer extends ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("pathForTransformer_args")
      val TransformerIdField: TField = new TField("transformerId", TType.I32, 1)
      val TransformerIdFieldManifest: Manifest[Int] = implicitly[Manifest[Int]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          TransformerIdField,
          false,
          false,
          TransformerIdFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.transformerId)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          transformerId =
            {
              val field = original.transformerId
              field
            }
        )
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var transformerId: Int = 0
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.I32 =>
                    transformerId = readTransformerIdValue(_iprot)
                  case _actualType =>
                    val _expectedType = TType.I32
                    throw new TProtocolException(
                      "Received wrong type for field 'transformerId' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Args(
          transformerId,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        transformerId: Int
      ): Args =
        new Args(
          transformerId
        )
    
      def unapply(_item: Args): _root_.scala.Option[Int] = _root_.scala.Some(_item.transformerId)
    
    
      @inline private[modeldb] def readTransformerIdValue(_iprot: TProtocol): Int = {
        _iprot.readI32()
      }
    
      @inline private def writeTransformerIdField(transformerId_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(TransformerIdField)
        writeTransformerIdValue(transformerId_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeTransformerIdValue(transformerId_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeI32(transformerId_item)
      }
    
    
    }
    
    class Args(
        val transformerId: Int,
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product1[Int]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
    
      def this(
        transformerId: Int
      ) = this(
        transformerId,
        Map.empty
      )
    
      def _1: Int = transformerId
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        writeTransformerIdField(transformerId, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        transformerId: Int = this.transformerId,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          transformerId,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.transformerId
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    }

    type SuccessType = String
    
    object Result extends ValidatingThriftStructCodec3[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("pathForTransformer_result")
      val SuccessField: TField = new TField("success", TType.STRING, 0)
      val SuccessFieldManifest: Manifest[String] = implicitly[Manifest[String]]
      val RnfExField: TField = new TField("rnfEx", TType.STRUCT, 1)
      val RnfExFieldManifest: Manifest[modeldb.ResourceNotFoundException] = implicitly[Manifest[modeldb.ResourceNotFoundException]]
      val EfExField: TField = new TField("efEx", TType.STRUCT, 2)
      val EfExFieldManifest: Manifest[modeldb.InvalidFieldException] = implicitly[Manifest[modeldb.InvalidFieldException]]
      val SvExField: TField = new TField("svEx", TType.STRUCT, 3)
      val SvExFieldManifest: Manifest[modeldb.ServerLogicException] = implicitly[Manifest[modeldb.ServerLogicException]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          RnfExField,
          true,
          false,
          RnfExFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          EfExField,
          true,
          false,
          EfExFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          SvExField,
          true,
          false,
          SvExFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf ++= validateField(item.rnfEx)
        buf ++= validateField(item.efEx)
        buf ++= validateField(item.svEx)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                field
              }
            },
          rnfEx =
            {
              val field = original.rnfEx
              field.map { field =>
                modeldb.ResourceNotFoundException.withoutPassthroughFields(field)
              }
            },
          efEx =
            {
              val field = original.efEx
              field.map { field =>
                modeldb.InvalidFieldException.withoutPassthroughFields(field)
              }
            },
          svEx =
            {
              val field = original.svEx
              field.map { field =>
                modeldb.ServerLogicException.withoutPassthroughFields(field)
              }
            }
        )
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[String] = _root_.scala.None
        var rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException] = _root_.scala.None
        var efEx: _root_.scala.Option[modeldb.InvalidFieldException] = _root_.scala.None
        var svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.STRING =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRING
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 1 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    rnfEx = _root_.scala.Some(readRnfExValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'rnfEx' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 2 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    efEx = _root_.scala.Some(readEfExValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'efEx' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 3 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    svEx = _root_.scala.Some(readSvExValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'svEx' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          rnfEx,
          efEx,
          svEx,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[String] = _root_.scala.None,
        rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException] = _root_.scala.None,
        efEx: _root_.scala.Option[modeldb.InvalidFieldException] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ): Result =
        new Result(
          success,
          rnfEx,
          efEx,
          svEx
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Tuple4[Option[String], Option[modeldb.ResourceNotFoundException], Option[modeldb.InvalidFieldException], Option[modeldb.ServerLogicException]]] = _root_.scala.Some(_item.toTuple)
    
    
      @inline private[modeldb] def readSuccessValue(_iprot: TProtocol): String = {
        _iprot.readString()
      }
    
      @inline private def writeSuccessField(success_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeString(success_item)
      }
    
      @inline private[modeldb] def readRnfExValue(_iprot: TProtocol): modeldb.ResourceNotFoundException = {
        modeldb.ResourceNotFoundException.decode(_iprot)
      }
    
      @inline private def writeRnfExField(rnfEx_item: modeldb.ResourceNotFoundException, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(RnfExField)
        writeRnfExValue(rnfEx_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeRnfExValue(rnfEx_item: modeldb.ResourceNotFoundException, _oprot: TProtocol): Unit = {
        rnfEx_item.write(_oprot)
      }
    
      @inline private[modeldb] def readEfExValue(_iprot: TProtocol): modeldb.InvalidFieldException = {
        modeldb.InvalidFieldException.decode(_iprot)
      }
    
      @inline private def writeEfExField(efEx_item: modeldb.InvalidFieldException, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(EfExField)
        writeEfExValue(efEx_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeEfExValue(efEx_item: modeldb.InvalidFieldException, _oprot: TProtocol): Unit = {
        efEx_item.write(_oprot)
      }
    
      @inline private[modeldb] def readSvExValue(_iprot: TProtocol): modeldb.ServerLogicException = {
        modeldb.ServerLogicException.decode(_iprot)
      }
    
      @inline private def writeSvExField(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SvExField)
        writeSvExValue(svEx_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSvExValue(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        svEx_item.write(_oprot)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[String],
        val rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException],
        val efEx: _root_.scala.Option[modeldb.InvalidFieldException],
        val svEx: _root_.scala.Option[modeldb.ServerLogicException],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[String] with ThriftStruct
      with _root_.scala.Product4[Option[String], Option[modeldb.ResourceNotFoundException], Option[modeldb.InvalidFieldException], Option[modeldb.ServerLogicException]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
    
      def this(
        success: _root_.scala.Option[String] = _root_.scala.None,
        rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException] = _root_.scala.None,
        efEx: _root_.scala.Option[modeldb.InvalidFieldException] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ) = this(
        success,
        rnfEx,
        efEx,
        svEx,
        Map.empty
      )
    
      def _1: _root_.scala.Option[String] = success
      def _2: _root_.scala.Option[modeldb.ResourceNotFoundException] = rnfEx
      def _3: _root_.scala.Option[modeldb.InvalidFieldException] = efEx
      def _4: _root_.scala.Option[modeldb.ServerLogicException] = svEx
    
      def toTuple: _root_.scala.Tuple4[Option[String], Option[modeldb.ResourceNotFoundException], Option[modeldb.InvalidFieldException], Option[modeldb.ServerLogicException]] = {
        (
          success,
          rnfEx,
          efEx,
          svEx
        )
      }
    
      def successField: Option[String] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Seq(rnfEx, efEx, svEx)
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (rnfEx.isDefined) writeRnfExField(rnfEx.get, _oprot)
        if (efEx.isDefined) writeEfExField(efEx.get, _oprot)
        if (svEx.isDefined) writeSvExField(svEx.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[String] = this.success,
        rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException] = this.rnfEx,
        efEx: _root_.scala.Option[modeldb.InvalidFieldException] = this.efEx,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = this.svEx,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          rnfEx,
          efEx,
          svEx,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 4
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case 1 => this.rnfEx
        case 2 => this.efEx
        case 3 => this.svEx
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Function1[Args,Future[String]]
    type ReqRepFunctionType = Function1[_root_.com.twitter.scrooge.Request[Args],Future[_root_.com.twitter.scrooge.Response[String]]]

    type ServiceIfaceServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ReqRepServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]]

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]] { request: _root_.com.twitter.scrooge.Request[Args] =>
        f(request)
      }

    private[this] val toResult = (res: SuccessType) => Result(Some(res))

    val name: String = "pathForTransformer"
    val serviceName: String = "ModelDBService"
    val argsCodec = Args
    val responseCodec = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val pathForTransformer$args = PathForTransformer.Args
  type pathForTransformer$args = PathForTransformer.Args

  val pathForTransformer$result = PathForTransformer.Result
  type pathForTransformer$result = PathForTransformer.Result

  object StoreFitEvent extends ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("storeFitEvent_args")
      val FeField: TField = new TField("fe", TType.STRUCT, 1)
      val FeFieldManifest: Manifest[modeldb.FitEvent] = implicitly[Manifest[modeldb.FitEvent]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          FeField,
          false,
          false,
          FeFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.fe)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          fe =
            {
              val field = original.fe
              modeldb.FitEvent.withoutPassthroughFields(field)
            }
        )
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var fe: modeldb.FitEvent = null
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    fe = readFeValue(_iprot)
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'fe' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Args(
          fe,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        fe: modeldb.FitEvent
      ): Args =
        new Args(
          fe
        )
    
      def unapply(_item: Args): _root_.scala.Option[modeldb.FitEvent] = _root_.scala.Some(_item.fe)
    
    
      @inline private[modeldb] def readFeValue(_iprot: TProtocol): modeldb.FitEvent = {
        modeldb.FitEvent.decode(_iprot)
      }
    
      @inline private def writeFeField(fe_item: modeldb.FitEvent, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(FeField)
        writeFeValue(fe_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeFeValue(fe_item: modeldb.FitEvent, _oprot: TProtocol): Unit = {
        fe_item.write(_oprot)
      }
    
    
    }
    
    class Args(
        val fe: modeldb.FitEvent,
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product1[modeldb.FitEvent]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
    
      def this(
        fe: modeldb.FitEvent
      ) = this(
        fe,
        Map.empty
      )
    
      def _1: modeldb.FitEvent = fe
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        if (fe ne null) writeFeField(fe, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        fe: modeldb.FitEvent = this.fe,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          fe,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.fe
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    }

    type SuccessType = modeldb.FitEventResponse
    
    object Result extends ValidatingThriftStructCodec3[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("storeFitEvent_result")
      val SuccessField: TField = new TField("success", TType.STRUCT, 0)
      val SuccessFieldManifest: Manifest[modeldb.FitEventResponse] = implicitly[Manifest[modeldb.FitEventResponse]]
      val IerExField: TField = new TField("ierEx", TType.STRUCT, 1)
      val IerExFieldManifest: Manifest[modeldb.InvalidExperimentRunException] = implicitly[Manifest[modeldb.InvalidExperimentRunException]]
      val SvExField: TField = new TField("svEx", TType.STRUCT, 2)
      val SvExFieldManifest: Manifest[modeldb.ServerLogicException] = implicitly[Manifest[modeldb.ServerLogicException]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          IerExField,
          true,
          false,
          IerExFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          SvExField,
          true,
          false,
          SvExFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf ++= validateField(item.ierEx)
        buf ++= validateField(item.svEx)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                modeldb.FitEventResponse.withoutPassthroughFields(field)
              }
            },
          ierEx =
            {
              val field = original.ierEx
              field.map { field =>
                modeldb.InvalidExperimentRunException.withoutPassthroughFields(field)
              }
            },
          svEx =
            {
              val field = original.svEx
              field.map { field =>
                modeldb.ServerLogicException.withoutPassthroughFields(field)
              }
            }
        )
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[modeldb.FitEventResponse] = _root_.scala.None
        var ierEx: _root_.scala.Option[modeldb.InvalidExperimentRunException] = _root_.scala.None
        var svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 1 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    ierEx = _root_.scala.Some(readIerExValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'ierEx' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 2 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    svEx = _root_.scala.Some(readSvExValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'svEx' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          ierEx,
          svEx,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[modeldb.FitEventResponse] = _root_.scala.None,
        ierEx: _root_.scala.Option[modeldb.InvalidExperimentRunException] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ): Result =
        new Result(
          success,
          ierEx,
          svEx
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Tuple3[Option[modeldb.FitEventResponse], Option[modeldb.InvalidExperimentRunException], Option[modeldb.ServerLogicException]]] = _root_.scala.Some(_item.toTuple)
    
    
      @inline private[modeldb] def readSuccessValue(_iprot: TProtocol): modeldb.FitEventResponse = {
        modeldb.FitEventResponse.decode(_iprot)
      }
    
      @inline private def writeSuccessField(success_item: modeldb.FitEventResponse, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: modeldb.FitEventResponse, _oprot: TProtocol): Unit = {
        success_item.write(_oprot)
      }
    
      @inline private[modeldb] def readIerExValue(_iprot: TProtocol): modeldb.InvalidExperimentRunException = {
        modeldb.InvalidExperimentRunException.decode(_iprot)
      }
    
      @inline private def writeIerExField(ierEx_item: modeldb.InvalidExperimentRunException, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(IerExField)
        writeIerExValue(ierEx_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeIerExValue(ierEx_item: modeldb.InvalidExperimentRunException, _oprot: TProtocol): Unit = {
        ierEx_item.write(_oprot)
      }
    
      @inline private[modeldb] def readSvExValue(_iprot: TProtocol): modeldb.ServerLogicException = {
        modeldb.ServerLogicException.decode(_iprot)
      }
    
      @inline private def writeSvExField(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SvExField)
        writeSvExValue(svEx_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSvExValue(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        svEx_item.write(_oprot)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[modeldb.FitEventResponse],
        val ierEx: _root_.scala.Option[modeldb.InvalidExperimentRunException],
        val svEx: _root_.scala.Option[modeldb.ServerLogicException],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[modeldb.FitEventResponse] with ThriftStruct
      with _root_.scala.Product3[Option[modeldb.FitEventResponse], Option[modeldb.InvalidExperimentRunException], Option[modeldb.ServerLogicException]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
    
      def this(
        success: _root_.scala.Option[modeldb.FitEventResponse] = _root_.scala.None,
        ierEx: _root_.scala.Option[modeldb.InvalidExperimentRunException] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ) = this(
        success,
        ierEx,
        svEx,
        Map.empty
      )
    
      def _1: _root_.scala.Option[modeldb.FitEventResponse] = success
      def _2: _root_.scala.Option[modeldb.InvalidExperimentRunException] = ierEx
      def _3: _root_.scala.Option[modeldb.ServerLogicException] = svEx
    
      def toTuple: _root_.scala.Tuple3[Option[modeldb.FitEventResponse], Option[modeldb.InvalidExperimentRunException], Option[modeldb.ServerLogicException]] = {
        (
          success,
          ierEx,
          svEx
        )
      }
    
      def successField: Option[modeldb.FitEventResponse] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Seq(ierEx, svEx)
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (ierEx.isDefined) writeIerExField(ierEx.get, _oprot)
        if (svEx.isDefined) writeSvExField(svEx.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[modeldb.FitEventResponse] = this.success,
        ierEx: _root_.scala.Option[modeldb.InvalidExperimentRunException] = this.ierEx,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = this.svEx,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          ierEx,
          svEx,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 3
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case 1 => this.ierEx
        case 2 => this.svEx
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Function1[Args,Future[modeldb.FitEventResponse]]
    type ReqRepFunctionType = Function1[_root_.com.twitter.scrooge.Request[Args],Future[_root_.com.twitter.scrooge.Response[modeldb.FitEventResponse]]]

    type ServiceIfaceServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ReqRepServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]]

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]] { request: _root_.com.twitter.scrooge.Request[Args] =>
        f(request)
      }

    private[this] val toResult = (res: SuccessType) => Result(Some(res))

    val name: String = "storeFitEvent"
    val serviceName: String = "ModelDBService"
    val argsCodec = Args
    val responseCodec = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val storeFitEvent$args = StoreFitEvent.Args
  type storeFitEvent$args = StoreFitEvent.Args

  val storeFitEvent$result = StoreFitEvent.Result
  type storeFitEvent$result = StoreFitEvent.Result

  object StoreMetricEvent extends ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("storeMetricEvent_args")
      val MeField: TField = new TField("me", TType.STRUCT, 1)
      val MeFieldManifest: Manifest[modeldb.MetricEvent] = implicitly[Manifest[modeldb.MetricEvent]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          MeField,
          false,
          false,
          MeFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.me)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          me =
            {
              val field = original.me
              modeldb.MetricEvent.withoutPassthroughFields(field)
            }
        )
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var me: modeldb.MetricEvent = null
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    me = readMeValue(_iprot)
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'me' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Args(
          me,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        me: modeldb.MetricEvent
      ): Args =
        new Args(
          me
        )
    
      def unapply(_item: Args): _root_.scala.Option[modeldb.MetricEvent] = _root_.scala.Some(_item.me)
    
    
      @inline private[modeldb] def readMeValue(_iprot: TProtocol): modeldb.MetricEvent = {
        modeldb.MetricEvent.decode(_iprot)
      }
    
      @inline private def writeMeField(me_item: modeldb.MetricEvent, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(MeField)
        writeMeValue(me_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeMeValue(me_item: modeldb.MetricEvent, _oprot: TProtocol): Unit = {
        me_item.write(_oprot)
      }
    
    
    }
    
    class Args(
        val me: modeldb.MetricEvent,
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product1[modeldb.MetricEvent]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
    
      def this(
        me: modeldb.MetricEvent
      ) = this(
        me,
        Map.empty
      )
    
      def _1: modeldb.MetricEvent = me
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        if (me ne null) writeMeField(me, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        me: modeldb.MetricEvent = this.me,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          me,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.me
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    }

    type SuccessType = modeldb.MetricEventResponse
    
    object Result extends ValidatingThriftStructCodec3[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("storeMetricEvent_result")
      val SuccessField: TField = new TField("success", TType.STRUCT, 0)
      val SuccessFieldManifest: Manifest[modeldb.MetricEventResponse] = implicitly[Manifest[modeldb.MetricEventResponse]]
      val IerExField: TField = new TField("ierEx", TType.STRUCT, 1)
      val IerExFieldManifest: Manifest[modeldb.InvalidExperimentRunException] = implicitly[Manifest[modeldb.InvalidExperimentRunException]]
      val SvExField: TField = new TField("svEx", TType.STRUCT, 2)
      val SvExFieldManifest: Manifest[modeldb.ServerLogicException] = implicitly[Manifest[modeldb.ServerLogicException]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          IerExField,
          true,
          false,
          IerExFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          SvExField,
          true,
          false,
          SvExFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf ++= validateField(item.ierEx)
        buf ++= validateField(item.svEx)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                modeldb.MetricEventResponse.withoutPassthroughFields(field)
              }
            },
          ierEx =
            {
              val field = original.ierEx
              field.map { field =>
                modeldb.InvalidExperimentRunException.withoutPassthroughFields(field)
              }
            },
          svEx =
            {
              val field = original.svEx
              field.map { field =>
                modeldb.ServerLogicException.withoutPassthroughFields(field)
              }
            }
        )
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[modeldb.MetricEventResponse] = _root_.scala.None
        var ierEx: _root_.scala.Option[modeldb.InvalidExperimentRunException] = _root_.scala.None
        var svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 1 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    ierEx = _root_.scala.Some(readIerExValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'ierEx' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 2 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    svEx = _root_.scala.Some(readSvExValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'svEx' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          ierEx,
          svEx,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[modeldb.MetricEventResponse] = _root_.scala.None,
        ierEx: _root_.scala.Option[modeldb.InvalidExperimentRunException] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ): Result =
        new Result(
          success,
          ierEx,
          svEx
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Tuple3[Option[modeldb.MetricEventResponse], Option[modeldb.InvalidExperimentRunException], Option[modeldb.ServerLogicException]]] = _root_.scala.Some(_item.toTuple)
    
    
      @inline private[modeldb] def readSuccessValue(_iprot: TProtocol): modeldb.MetricEventResponse = {
        modeldb.MetricEventResponse.decode(_iprot)
      }
    
      @inline private def writeSuccessField(success_item: modeldb.MetricEventResponse, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: modeldb.MetricEventResponse, _oprot: TProtocol): Unit = {
        success_item.write(_oprot)
      }
    
      @inline private[modeldb] def readIerExValue(_iprot: TProtocol): modeldb.InvalidExperimentRunException = {
        modeldb.InvalidExperimentRunException.decode(_iprot)
      }
    
      @inline private def writeIerExField(ierEx_item: modeldb.InvalidExperimentRunException, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(IerExField)
        writeIerExValue(ierEx_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeIerExValue(ierEx_item: modeldb.InvalidExperimentRunException, _oprot: TProtocol): Unit = {
        ierEx_item.write(_oprot)
      }
    
      @inline private[modeldb] def readSvExValue(_iprot: TProtocol): modeldb.ServerLogicException = {
        modeldb.ServerLogicException.decode(_iprot)
      }
    
      @inline private def writeSvExField(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SvExField)
        writeSvExValue(svEx_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSvExValue(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        svEx_item.write(_oprot)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[modeldb.MetricEventResponse],
        val ierEx: _root_.scala.Option[modeldb.InvalidExperimentRunException],
        val svEx: _root_.scala.Option[modeldb.ServerLogicException],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[modeldb.MetricEventResponse] with ThriftStruct
      with _root_.scala.Product3[Option[modeldb.MetricEventResponse], Option[modeldb.InvalidExperimentRunException], Option[modeldb.ServerLogicException]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
    
      def this(
        success: _root_.scala.Option[modeldb.MetricEventResponse] = _root_.scala.None,
        ierEx: _root_.scala.Option[modeldb.InvalidExperimentRunException] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ) = this(
        success,
        ierEx,
        svEx,
        Map.empty
      )
    
      def _1: _root_.scala.Option[modeldb.MetricEventResponse] = success
      def _2: _root_.scala.Option[modeldb.InvalidExperimentRunException] = ierEx
      def _3: _root_.scala.Option[modeldb.ServerLogicException] = svEx
    
      def toTuple: _root_.scala.Tuple3[Option[modeldb.MetricEventResponse], Option[modeldb.InvalidExperimentRunException], Option[modeldb.ServerLogicException]] = {
        (
          success,
          ierEx,
          svEx
        )
      }
    
      def successField: Option[modeldb.MetricEventResponse] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Seq(ierEx, svEx)
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (ierEx.isDefined) writeIerExField(ierEx.get, _oprot)
        if (svEx.isDefined) writeSvExField(svEx.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[modeldb.MetricEventResponse] = this.success,
        ierEx: _root_.scala.Option[modeldb.InvalidExperimentRunException] = this.ierEx,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = this.svEx,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          ierEx,
          svEx,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 3
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case 1 => this.ierEx
        case 2 => this.svEx
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Function1[Args,Future[modeldb.MetricEventResponse]]
    type ReqRepFunctionType = Function1[_root_.com.twitter.scrooge.Request[Args],Future[_root_.com.twitter.scrooge.Response[modeldb.MetricEventResponse]]]

    type ServiceIfaceServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ReqRepServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]]

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]] { request: _root_.com.twitter.scrooge.Request[Args] =>
        f(request)
      }

    private[this] val toResult = (res: SuccessType) => Result(Some(res))

    val name: String = "storeMetricEvent"
    val serviceName: String = "ModelDBService"
    val argsCodec = Args
    val responseCodec = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val storeMetricEvent$args = StoreMetricEvent.Args
  type storeMetricEvent$args = StoreMetricEvent.Args

  val storeMetricEvent$result = StoreMetricEvent.Result
  type storeMetricEvent$result = StoreMetricEvent.Result

  object GetFilePath extends ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("getFilePath_args")
      val TField: TField = new TField("t", TType.STRUCT, 1)
      val TFieldManifest: Manifest[modeldb.Transformer] = implicitly[Manifest[modeldb.Transformer]]
      val ExperimentRunIdField: TField = new TField("experimentRunId", TType.I32, 2)
      val ExperimentRunIdFieldManifest: Manifest[Int] = implicitly[Manifest[Int]]
      val FilenameField: TField = new TField("filename", TType.STRING, 3)
      val FilenameFieldManifest: Manifest[String] = implicitly[Manifest[String]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          TField,
          false,
          false,
          TFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          ExperimentRunIdField,
          false,
          false,
          ExperimentRunIdFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          FilenameField,
          false,
          false,
          FilenameFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.t)
        buf ++= validateField(item.experimentRunId)
        buf ++= validateField(item.filename)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          t =
            {
              val field = original.t
              modeldb.Transformer.withoutPassthroughFields(field)
            },
          experimentRunId =
            {
              val field = original.experimentRunId
              field
            },
          filename =
            {
              val field = original.filename
              field
            }
        )
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var t: modeldb.Transformer = null
        var experimentRunId: Int = 0
        var filename: String = null
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    t = readTValue(_iprot)
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 't' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 2 =>
                _field.`type` match {
                  case TType.I32 =>
                    experimentRunId = readExperimentRunIdValue(_iprot)
                  case _actualType =>
                    val _expectedType = TType.I32
                    throw new TProtocolException(
                      "Received wrong type for field 'experimentRunId' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 3 =>
                _field.`type` match {
                  case TType.STRING =>
                    filename = readFilenameValue(_iprot)
                  case _actualType =>
                    val _expectedType = TType.STRING
                    throw new TProtocolException(
                      "Received wrong type for field 'filename' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Args(
          t,
          experimentRunId,
          filename,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        t: modeldb.Transformer,
        experimentRunId: Int,
        filename: String
      ): Args =
        new Args(
          t,
          experimentRunId,
          filename
        )
    
      def unapply(_item: Args): _root_.scala.Option[_root_.scala.Tuple3[modeldb.Transformer, Int, String]] = _root_.scala.Some(_item.toTuple)
    
    
      @inline private[modeldb] def readTValue(_iprot: TProtocol): modeldb.Transformer = {
        modeldb.Transformer.decode(_iprot)
      }
    
      @inline private def writeTField(t_item: modeldb.Transformer, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(TField)
        writeTValue(t_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeTValue(t_item: modeldb.Transformer, _oprot: TProtocol): Unit = {
        t_item.write(_oprot)
      }
    
      @inline private[modeldb] def readExperimentRunIdValue(_iprot: TProtocol): Int = {
        _iprot.readI32()
      }
    
      @inline private def writeExperimentRunIdField(experimentRunId_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(ExperimentRunIdField)
        writeExperimentRunIdValue(experimentRunId_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeExperimentRunIdValue(experimentRunId_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeI32(experimentRunId_item)
      }
    
      @inline private[modeldb] def readFilenameValue(_iprot: TProtocol): String = {
        _iprot.readString()
      }
    
      @inline private def writeFilenameField(filename_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(FilenameField)
        writeFilenameValue(filename_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeFilenameValue(filename_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeString(filename_item)
      }
    
    
    }
    
    class Args(
        val t: modeldb.Transformer,
        val experimentRunId: Int,
        val filename: String,
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product3[modeldb.Transformer, Int, String]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
    
      def this(
        t: modeldb.Transformer,
        experimentRunId: Int,
        filename: String
      ) = this(
        t,
        experimentRunId,
        filename,
        Map.empty
      )
    
      def _1: modeldb.Transformer = t
      def _2: Int = experimentRunId
      def _3: String = filename
    
      def toTuple: _root_.scala.Tuple3[modeldb.Transformer, Int, String] = {
        (
          t,
          experimentRunId,
          filename
        )
      }
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        if (t ne null) writeTField(t, _oprot)
        writeExperimentRunIdField(experimentRunId, _oprot)
        if (filename ne null) writeFilenameField(filename, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        t: modeldb.Transformer = this.t,
        experimentRunId: Int = this.experimentRunId,
        filename: String = this.filename,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          t,
          experimentRunId,
          filename,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 3
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.t
        case 1 => this.experimentRunId
        case 2 => this.filename
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    }

    type SuccessType = String
    
    object Result extends ValidatingThriftStructCodec3[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("getFilePath_result")
      val SuccessField: TField = new TField("success", TType.STRING, 0)
      val SuccessFieldManifest: Manifest[String] = implicitly[Manifest[String]]
      val RnfExField: TField = new TField("rnfEx", TType.STRUCT, 1)
      val RnfExFieldManifest: Manifest[modeldb.ResourceNotFoundException] = implicitly[Manifest[modeldb.ResourceNotFoundException]]
      val SvExField: TField = new TField("svEx", TType.STRUCT, 2)
      val SvExFieldManifest: Manifest[modeldb.ServerLogicException] = implicitly[Manifest[modeldb.ServerLogicException]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          RnfExField,
          true,
          false,
          RnfExFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          SvExField,
          true,
          false,
          SvExFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf ++= validateField(item.rnfEx)
        buf ++= validateField(item.svEx)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                field
              }
            },
          rnfEx =
            {
              val field = original.rnfEx
              field.map { field =>
                modeldb.ResourceNotFoundException.withoutPassthroughFields(field)
              }
            },
          svEx =
            {
              val field = original.svEx
              field.map { field =>
                modeldb.ServerLogicException.withoutPassthroughFields(field)
              }
            }
        )
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[String] = _root_.scala.None
        var rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException] = _root_.scala.None
        var svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.STRING =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRING
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 1 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    rnfEx = _root_.scala.Some(readRnfExValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'rnfEx' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 2 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    svEx = _root_.scala.Some(readSvExValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'svEx' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          rnfEx,
          svEx,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[String] = _root_.scala.None,
        rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ): Result =
        new Result(
          success,
          rnfEx,
          svEx
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Tuple3[Option[String], Option[modeldb.ResourceNotFoundException], Option[modeldb.ServerLogicException]]] = _root_.scala.Some(_item.toTuple)
    
    
      @inline private[modeldb] def readSuccessValue(_iprot: TProtocol): String = {
        _iprot.readString()
      }
    
      @inline private def writeSuccessField(success_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeString(success_item)
      }
    
      @inline private[modeldb] def readRnfExValue(_iprot: TProtocol): modeldb.ResourceNotFoundException = {
        modeldb.ResourceNotFoundException.decode(_iprot)
      }
    
      @inline private def writeRnfExField(rnfEx_item: modeldb.ResourceNotFoundException, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(RnfExField)
        writeRnfExValue(rnfEx_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeRnfExValue(rnfEx_item: modeldb.ResourceNotFoundException, _oprot: TProtocol): Unit = {
        rnfEx_item.write(_oprot)
      }
    
      @inline private[modeldb] def readSvExValue(_iprot: TProtocol): modeldb.ServerLogicException = {
        modeldb.ServerLogicException.decode(_iprot)
      }
    
      @inline private def writeSvExField(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SvExField)
        writeSvExValue(svEx_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSvExValue(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        svEx_item.write(_oprot)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[String],
        val rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException],
        val svEx: _root_.scala.Option[modeldb.ServerLogicException],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[String] with ThriftStruct
      with _root_.scala.Product3[Option[String], Option[modeldb.ResourceNotFoundException], Option[modeldb.ServerLogicException]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
    
      def this(
        success: _root_.scala.Option[String] = _root_.scala.None,
        rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ) = this(
        success,
        rnfEx,
        svEx,
        Map.empty
      )
    
      def _1: _root_.scala.Option[String] = success
      def _2: _root_.scala.Option[modeldb.ResourceNotFoundException] = rnfEx
      def _3: _root_.scala.Option[modeldb.ServerLogicException] = svEx
    
      def toTuple: _root_.scala.Tuple3[Option[String], Option[modeldb.ResourceNotFoundException], Option[modeldb.ServerLogicException]] = {
        (
          success,
          rnfEx,
          svEx
        )
      }
    
      def successField: Option[String] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Seq(rnfEx, svEx)
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (rnfEx.isDefined) writeRnfExField(rnfEx.get, _oprot)
        if (svEx.isDefined) writeSvExField(svEx.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[String] = this.success,
        rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException] = this.rnfEx,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = this.svEx,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          rnfEx,
          svEx,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 3
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case 1 => this.rnfEx
        case 2 => this.svEx
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Function1[Args,Future[String]]
    type ReqRepFunctionType = Function1[_root_.com.twitter.scrooge.Request[Args],Future[_root_.com.twitter.scrooge.Response[String]]]

    type ServiceIfaceServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ReqRepServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]]

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]] { request: _root_.com.twitter.scrooge.Request[Args] =>
        f(request)
      }

    private[this] val toResult = (res: SuccessType) => Result(Some(res))

    val name: String = "getFilePath"
    val serviceName: String = "ModelDBService"
    val argsCodec = Args
    val responseCodec = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val getFilePath$args = GetFilePath.Args
  type getFilePath$args = GetFilePath.Args

  val getFilePath$result = GetFilePath.Result
  type getFilePath$result = GetFilePath.Result

  object StoreTransformEvent extends ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("storeTransformEvent_args")
      val TeField: TField = new TField("te", TType.STRUCT, 1)
      val TeFieldManifest: Manifest[modeldb.TransformEvent] = implicitly[Manifest[modeldb.TransformEvent]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          TeField,
          false,
          false,
          TeFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.te)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          te =
            {
              val field = original.te
              modeldb.TransformEvent.withoutPassthroughFields(field)
            }
        )
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var te: modeldb.TransformEvent = null
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    te = readTeValue(_iprot)
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'te' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Args(
          te,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        te: modeldb.TransformEvent
      ): Args =
        new Args(
          te
        )
    
      def unapply(_item: Args): _root_.scala.Option[modeldb.TransformEvent] = _root_.scala.Some(_item.te)
    
    
      @inline private[modeldb] def readTeValue(_iprot: TProtocol): modeldb.TransformEvent = {
        modeldb.TransformEvent.decode(_iprot)
      }
    
      @inline private def writeTeField(te_item: modeldb.TransformEvent, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(TeField)
        writeTeValue(te_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeTeValue(te_item: modeldb.TransformEvent, _oprot: TProtocol): Unit = {
        te_item.write(_oprot)
      }
    
    
    }
    
    class Args(
        val te: modeldb.TransformEvent,
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product1[modeldb.TransformEvent]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
    
      def this(
        te: modeldb.TransformEvent
      ) = this(
        te,
        Map.empty
      )
    
      def _1: modeldb.TransformEvent = te
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        if (te ne null) writeTeField(te, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        te: modeldb.TransformEvent = this.te,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          te,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.te
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    }

    type SuccessType = modeldb.TransformEventResponse
    
    object Result extends ValidatingThriftStructCodec3[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("storeTransformEvent_result")
      val SuccessField: TField = new TField("success", TType.STRUCT, 0)
      val SuccessFieldManifest: Manifest[modeldb.TransformEventResponse] = implicitly[Manifest[modeldb.TransformEventResponse]]
      val IerExField: TField = new TField("ierEx", TType.STRUCT, 1)
      val IerExFieldManifest: Manifest[modeldb.InvalidExperimentRunException] = implicitly[Manifest[modeldb.InvalidExperimentRunException]]
      val SvExField: TField = new TField("svEx", TType.STRUCT, 2)
      val SvExFieldManifest: Manifest[modeldb.ServerLogicException] = implicitly[Manifest[modeldb.ServerLogicException]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          IerExField,
          true,
          false,
          IerExFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          SvExField,
          true,
          false,
          SvExFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf ++= validateField(item.ierEx)
        buf ++= validateField(item.svEx)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                modeldb.TransformEventResponse.withoutPassthroughFields(field)
              }
            },
          ierEx =
            {
              val field = original.ierEx
              field.map { field =>
                modeldb.InvalidExperimentRunException.withoutPassthroughFields(field)
              }
            },
          svEx =
            {
              val field = original.svEx
              field.map { field =>
                modeldb.ServerLogicException.withoutPassthroughFields(field)
              }
            }
        )
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[modeldb.TransformEventResponse] = _root_.scala.None
        var ierEx: _root_.scala.Option[modeldb.InvalidExperimentRunException] = _root_.scala.None
        var svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 1 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    ierEx = _root_.scala.Some(readIerExValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'ierEx' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 2 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    svEx = _root_.scala.Some(readSvExValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'svEx' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          ierEx,
          svEx,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[modeldb.TransformEventResponse] = _root_.scala.None,
        ierEx: _root_.scala.Option[modeldb.InvalidExperimentRunException] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ): Result =
        new Result(
          success,
          ierEx,
          svEx
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Tuple3[Option[modeldb.TransformEventResponse], Option[modeldb.InvalidExperimentRunException], Option[modeldb.ServerLogicException]]] = _root_.scala.Some(_item.toTuple)
    
    
      @inline private[modeldb] def readSuccessValue(_iprot: TProtocol): modeldb.TransformEventResponse = {
        modeldb.TransformEventResponse.decode(_iprot)
      }
    
      @inline private def writeSuccessField(success_item: modeldb.TransformEventResponse, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: modeldb.TransformEventResponse, _oprot: TProtocol): Unit = {
        success_item.write(_oprot)
      }
    
      @inline private[modeldb] def readIerExValue(_iprot: TProtocol): modeldb.InvalidExperimentRunException = {
        modeldb.InvalidExperimentRunException.decode(_iprot)
      }
    
      @inline private def writeIerExField(ierEx_item: modeldb.InvalidExperimentRunException, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(IerExField)
        writeIerExValue(ierEx_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeIerExValue(ierEx_item: modeldb.InvalidExperimentRunException, _oprot: TProtocol): Unit = {
        ierEx_item.write(_oprot)
      }
    
      @inline private[modeldb] def readSvExValue(_iprot: TProtocol): modeldb.ServerLogicException = {
        modeldb.ServerLogicException.decode(_iprot)
      }
    
      @inline private def writeSvExField(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SvExField)
        writeSvExValue(svEx_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSvExValue(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        svEx_item.write(_oprot)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[modeldb.TransformEventResponse],
        val ierEx: _root_.scala.Option[modeldb.InvalidExperimentRunException],
        val svEx: _root_.scala.Option[modeldb.ServerLogicException],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[modeldb.TransformEventResponse] with ThriftStruct
      with _root_.scala.Product3[Option[modeldb.TransformEventResponse], Option[modeldb.InvalidExperimentRunException], Option[modeldb.ServerLogicException]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
    
      def this(
        success: _root_.scala.Option[modeldb.TransformEventResponse] = _root_.scala.None,
        ierEx: _root_.scala.Option[modeldb.InvalidExperimentRunException] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ) = this(
        success,
        ierEx,
        svEx,
        Map.empty
      )
    
      def _1: _root_.scala.Option[modeldb.TransformEventResponse] = success
      def _2: _root_.scala.Option[modeldb.InvalidExperimentRunException] = ierEx
      def _3: _root_.scala.Option[modeldb.ServerLogicException] = svEx
    
      def toTuple: _root_.scala.Tuple3[Option[modeldb.TransformEventResponse], Option[modeldb.InvalidExperimentRunException], Option[modeldb.ServerLogicException]] = {
        (
          success,
          ierEx,
          svEx
        )
      }
    
      def successField: Option[modeldb.TransformEventResponse] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Seq(ierEx, svEx)
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (ierEx.isDefined) writeIerExField(ierEx.get, _oprot)
        if (svEx.isDefined) writeSvExField(svEx.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[modeldb.TransformEventResponse] = this.success,
        ierEx: _root_.scala.Option[modeldb.InvalidExperimentRunException] = this.ierEx,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = this.svEx,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          ierEx,
          svEx,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 3
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case 1 => this.ierEx
        case 2 => this.svEx
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Function1[Args,Future[modeldb.TransformEventResponse]]
    type ReqRepFunctionType = Function1[_root_.com.twitter.scrooge.Request[Args],Future[_root_.com.twitter.scrooge.Response[modeldb.TransformEventResponse]]]

    type ServiceIfaceServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ReqRepServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]]

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]] { request: _root_.com.twitter.scrooge.Request[Args] =>
        f(request)
      }

    private[this] val toResult = (res: SuccessType) => Result(Some(res))

    val name: String = "storeTransformEvent"
    val serviceName: String = "ModelDBService"
    val argsCodec = Args
    val responseCodec = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val storeTransformEvent$args = StoreTransformEvent.Args
  type storeTransformEvent$args = StoreTransformEvent.Args

  val storeTransformEvent$result = StoreTransformEvent.Result
  type storeTransformEvent$result = StoreTransformEvent.Result

  object StoreRandomSplitEvent extends ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("storeRandomSplitEvent_args")
      val RseField: TField = new TField("rse", TType.STRUCT, 1)
      val RseFieldManifest: Manifest[modeldb.RandomSplitEvent] = implicitly[Manifest[modeldb.RandomSplitEvent]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          RseField,
          false,
          false,
          RseFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.rse)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          rse =
            {
              val field = original.rse
              modeldb.RandomSplitEvent.withoutPassthroughFields(field)
            }
        )
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var rse: modeldb.RandomSplitEvent = null
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    rse = readRseValue(_iprot)
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'rse' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Args(
          rse,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        rse: modeldb.RandomSplitEvent
      ): Args =
        new Args(
          rse
        )
    
      def unapply(_item: Args): _root_.scala.Option[modeldb.RandomSplitEvent] = _root_.scala.Some(_item.rse)
    
    
      @inline private[modeldb] def readRseValue(_iprot: TProtocol): modeldb.RandomSplitEvent = {
        modeldb.RandomSplitEvent.decode(_iprot)
      }
    
      @inline private def writeRseField(rse_item: modeldb.RandomSplitEvent, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(RseField)
        writeRseValue(rse_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeRseValue(rse_item: modeldb.RandomSplitEvent, _oprot: TProtocol): Unit = {
        rse_item.write(_oprot)
      }
    
    
    }
    
    class Args(
        val rse: modeldb.RandomSplitEvent,
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product1[modeldb.RandomSplitEvent]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
    
      def this(
        rse: modeldb.RandomSplitEvent
      ) = this(
        rse,
        Map.empty
      )
    
      def _1: modeldb.RandomSplitEvent = rse
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        if (rse ne null) writeRseField(rse, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        rse: modeldb.RandomSplitEvent = this.rse,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          rse,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.rse
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    }

    type SuccessType = modeldb.RandomSplitEventResponse
    
    object Result extends ValidatingThriftStructCodec3[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("storeRandomSplitEvent_result")
      val SuccessField: TField = new TField("success", TType.STRUCT, 0)
      val SuccessFieldManifest: Manifest[modeldb.RandomSplitEventResponse] = implicitly[Manifest[modeldb.RandomSplitEventResponse]]
      val SvExField: TField = new TField("svEx", TType.STRUCT, 1)
      val SvExFieldManifest: Manifest[modeldb.ServerLogicException] = implicitly[Manifest[modeldb.ServerLogicException]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          SvExField,
          true,
          false,
          SvExFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf ++= validateField(item.svEx)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                modeldb.RandomSplitEventResponse.withoutPassthroughFields(field)
              }
            },
          svEx =
            {
              val field = original.svEx
              field.map { field =>
                modeldb.ServerLogicException.withoutPassthroughFields(field)
              }
            }
        )
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[modeldb.RandomSplitEventResponse] = _root_.scala.None
        var svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 1 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    svEx = _root_.scala.Some(readSvExValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'svEx' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          svEx,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[modeldb.RandomSplitEventResponse] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ): Result =
        new Result(
          success,
          svEx
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Tuple2[Option[modeldb.RandomSplitEventResponse], Option[modeldb.ServerLogicException]]] = _root_.scala.Some(_item.toTuple)
    
    
      @inline private[modeldb] def readSuccessValue(_iprot: TProtocol): modeldb.RandomSplitEventResponse = {
        modeldb.RandomSplitEventResponse.decode(_iprot)
      }
    
      @inline private def writeSuccessField(success_item: modeldb.RandomSplitEventResponse, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: modeldb.RandomSplitEventResponse, _oprot: TProtocol): Unit = {
        success_item.write(_oprot)
      }
    
      @inline private[modeldb] def readSvExValue(_iprot: TProtocol): modeldb.ServerLogicException = {
        modeldb.ServerLogicException.decode(_iprot)
      }
    
      @inline private def writeSvExField(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SvExField)
        writeSvExValue(svEx_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSvExValue(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        svEx_item.write(_oprot)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[modeldb.RandomSplitEventResponse],
        val svEx: _root_.scala.Option[modeldb.ServerLogicException],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[modeldb.RandomSplitEventResponse] with ThriftStruct
      with _root_.scala.Product2[Option[modeldb.RandomSplitEventResponse], Option[modeldb.ServerLogicException]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
    
      def this(
        success: _root_.scala.Option[modeldb.RandomSplitEventResponse] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ) = this(
        success,
        svEx,
        Map.empty
      )
    
      def _1: _root_.scala.Option[modeldb.RandomSplitEventResponse] = success
      def _2: _root_.scala.Option[modeldb.ServerLogicException] = svEx
    
      def toTuple: _root_.scala.Tuple2[Option[modeldb.RandomSplitEventResponse], Option[modeldb.ServerLogicException]] = {
        (
          success,
          svEx
        )
      }
    
      def successField: Option[modeldb.RandomSplitEventResponse] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Seq(svEx)
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (svEx.isDefined) writeSvExField(svEx.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[modeldb.RandomSplitEventResponse] = this.success,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = this.svEx,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          svEx,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 2
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case 1 => this.svEx
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Function1[Args,Future[modeldb.RandomSplitEventResponse]]
    type ReqRepFunctionType = Function1[_root_.com.twitter.scrooge.Request[Args],Future[_root_.com.twitter.scrooge.Response[modeldb.RandomSplitEventResponse]]]

    type ServiceIfaceServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ReqRepServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]]

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]] { request: _root_.com.twitter.scrooge.Request[Args] =>
        f(request)
      }

    private[this] val toResult = (res: SuccessType) => Result(Some(res))

    val name: String = "storeRandomSplitEvent"
    val serviceName: String = "ModelDBService"
    val argsCodec = Args
    val responseCodec = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val storeRandomSplitEvent$args = StoreRandomSplitEvent.Args
  type storeRandomSplitEvent$args = StoreRandomSplitEvent.Args

  val storeRandomSplitEvent$result = StoreRandomSplitEvent.Result
  type storeRandomSplitEvent$result = StoreRandomSplitEvent.Result

  object StorePipelineEvent extends ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("storePipelineEvent_args")
      val PipelineEventField: TField = new TField("pipelineEvent", TType.STRUCT, 1)
      val PipelineEventFieldManifest: Manifest[modeldb.PipelineEvent] = implicitly[Manifest[modeldb.PipelineEvent]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          PipelineEventField,
          false,
          false,
          PipelineEventFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.pipelineEvent)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          pipelineEvent =
            {
              val field = original.pipelineEvent
              modeldb.PipelineEvent.withoutPassthroughFields(field)
            }
        )
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var pipelineEvent: modeldb.PipelineEvent = null
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    pipelineEvent = readPipelineEventValue(_iprot)
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'pipelineEvent' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Args(
          pipelineEvent,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        pipelineEvent: modeldb.PipelineEvent
      ): Args =
        new Args(
          pipelineEvent
        )
    
      def unapply(_item: Args): _root_.scala.Option[modeldb.PipelineEvent] = _root_.scala.Some(_item.pipelineEvent)
    
    
      @inline private[modeldb] def readPipelineEventValue(_iprot: TProtocol): modeldb.PipelineEvent = {
        modeldb.PipelineEvent.decode(_iprot)
      }
    
      @inline private def writePipelineEventField(pipelineEvent_item: modeldb.PipelineEvent, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(PipelineEventField)
        writePipelineEventValue(pipelineEvent_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writePipelineEventValue(pipelineEvent_item: modeldb.PipelineEvent, _oprot: TProtocol): Unit = {
        pipelineEvent_item.write(_oprot)
      }
    
    
    }
    
    class Args(
        val pipelineEvent: modeldb.PipelineEvent,
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product1[modeldb.PipelineEvent]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
    
      def this(
        pipelineEvent: modeldb.PipelineEvent
      ) = this(
        pipelineEvent,
        Map.empty
      )
    
      def _1: modeldb.PipelineEvent = pipelineEvent
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        if (pipelineEvent ne null) writePipelineEventField(pipelineEvent, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        pipelineEvent: modeldb.PipelineEvent = this.pipelineEvent,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          pipelineEvent,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.pipelineEvent
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    }

    type SuccessType = modeldb.PipelineEventResponse
    
    object Result extends ValidatingThriftStructCodec3[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("storePipelineEvent_result")
      val SuccessField: TField = new TField("success", TType.STRUCT, 0)
      val SuccessFieldManifest: Manifest[modeldb.PipelineEventResponse] = implicitly[Manifest[modeldb.PipelineEventResponse]]
      val SvExField: TField = new TField("svEx", TType.STRUCT, 1)
      val SvExFieldManifest: Manifest[modeldb.ServerLogicException] = implicitly[Manifest[modeldb.ServerLogicException]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          SvExField,
          true,
          false,
          SvExFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf ++= validateField(item.svEx)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                modeldb.PipelineEventResponse.withoutPassthroughFields(field)
              }
            },
          svEx =
            {
              val field = original.svEx
              field.map { field =>
                modeldb.ServerLogicException.withoutPassthroughFields(field)
              }
            }
        )
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[modeldb.PipelineEventResponse] = _root_.scala.None
        var svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 1 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    svEx = _root_.scala.Some(readSvExValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'svEx' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          svEx,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[modeldb.PipelineEventResponse] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ): Result =
        new Result(
          success,
          svEx
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Tuple2[Option[modeldb.PipelineEventResponse], Option[modeldb.ServerLogicException]]] = _root_.scala.Some(_item.toTuple)
    
    
      @inline private[modeldb] def readSuccessValue(_iprot: TProtocol): modeldb.PipelineEventResponse = {
        modeldb.PipelineEventResponse.decode(_iprot)
      }
    
      @inline private def writeSuccessField(success_item: modeldb.PipelineEventResponse, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: modeldb.PipelineEventResponse, _oprot: TProtocol): Unit = {
        success_item.write(_oprot)
      }
    
      @inline private[modeldb] def readSvExValue(_iprot: TProtocol): modeldb.ServerLogicException = {
        modeldb.ServerLogicException.decode(_iprot)
      }
    
      @inline private def writeSvExField(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SvExField)
        writeSvExValue(svEx_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSvExValue(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        svEx_item.write(_oprot)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[modeldb.PipelineEventResponse],
        val svEx: _root_.scala.Option[modeldb.ServerLogicException],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[modeldb.PipelineEventResponse] with ThriftStruct
      with _root_.scala.Product2[Option[modeldb.PipelineEventResponse], Option[modeldb.ServerLogicException]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
    
      def this(
        success: _root_.scala.Option[modeldb.PipelineEventResponse] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ) = this(
        success,
        svEx,
        Map.empty
      )
    
      def _1: _root_.scala.Option[modeldb.PipelineEventResponse] = success
      def _2: _root_.scala.Option[modeldb.ServerLogicException] = svEx
    
      def toTuple: _root_.scala.Tuple2[Option[modeldb.PipelineEventResponse], Option[modeldb.ServerLogicException]] = {
        (
          success,
          svEx
        )
      }
    
      def successField: Option[modeldb.PipelineEventResponse] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Seq(svEx)
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (svEx.isDefined) writeSvExField(svEx.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[modeldb.PipelineEventResponse] = this.success,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = this.svEx,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          svEx,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 2
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case 1 => this.svEx
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Function1[Args,Future[modeldb.PipelineEventResponse]]
    type ReqRepFunctionType = Function1[_root_.com.twitter.scrooge.Request[Args],Future[_root_.com.twitter.scrooge.Response[modeldb.PipelineEventResponse]]]

    type ServiceIfaceServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ReqRepServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]]

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]] { request: _root_.com.twitter.scrooge.Request[Args] =>
        f(request)
      }

    private[this] val toResult = (res: SuccessType) => Result(Some(res))

    val name: String = "storePipelineEvent"
    val serviceName: String = "ModelDBService"
    val argsCodec = Args
    val responseCodec = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val storePipelineEvent$args = StorePipelineEvent.Args
  type storePipelineEvent$args = StorePipelineEvent.Args

  val storePipelineEvent$result = StorePipelineEvent.Result
  type storePipelineEvent$result = StorePipelineEvent.Result

  object StoreCrossValidationEvent extends ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("storeCrossValidationEvent_args")
      val CveField: TField = new TField("cve", TType.STRUCT, 1)
      val CveFieldManifest: Manifest[modeldb.CrossValidationEvent] = implicitly[Manifest[modeldb.CrossValidationEvent]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          CveField,
          false,
          false,
          CveFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.cve)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          cve =
            {
              val field = original.cve
              modeldb.CrossValidationEvent.withoutPassthroughFields(field)
            }
        )
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var cve: modeldb.CrossValidationEvent = null
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    cve = readCveValue(_iprot)
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'cve' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Args(
          cve,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        cve: modeldb.CrossValidationEvent
      ): Args =
        new Args(
          cve
        )
    
      def unapply(_item: Args): _root_.scala.Option[modeldb.CrossValidationEvent] = _root_.scala.Some(_item.cve)
    
    
      @inline private[modeldb] def readCveValue(_iprot: TProtocol): modeldb.CrossValidationEvent = {
        modeldb.CrossValidationEvent.decode(_iprot)
      }
    
      @inline private def writeCveField(cve_item: modeldb.CrossValidationEvent, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(CveField)
        writeCveValue(cve_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeCveValue(cve_item: modeldb.CrossValidationEvent, _oprot: TProtocol): Unit = {
        cve_item.write(_oprot)
      }
    
    
    }
    
    class Args(
        val cve: modeldb.CrossValidationEvent,
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product1[modeldb.CrossValidationEvent]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
    
      def this(
        cve: modeldb.CrossValidationEvent
      ) = this(
        cve,
        Map.empty
      )
    
      def _1: modeldb.CrossValidationEvent = cve
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        if (cve ne null) writeCveField(cve, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        cve: modeldb.CrossValidationEvent = this.cve,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          cve,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.cve
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    }

    type SuccessType = modeldb.CrossValidationEventResponse
    
    object Result extends ValidatingThriftStructCodec3[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("storeCrossValidationEvent_result")
      val SuccessField: TField = new TField("success", TType.STRUCT, 0)
      val SuccessFieldManifest: Manifest[modeldb.CrossValidationEventResponse] = implicitly[Manifest[modeldb.CrossValidationEventResponse]]
      val SvExField: TField = new TField("svEx", TType.STRUCT, 1)
      val SvExFieldManifest: Manifest[modeldb.ServerLogicException] = implicitly[Manifest[modeldb.ServerLogicException]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          SvExField,
          true,
          false,
          SvExFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf ++= validateField(item.svEx)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                modeldb.CrossValidationEventResponse.withoutPassthroughFields(field)
              }
            },
          svEx =
            {
              val field = original.svEx
              field.map { field =>
                modeldb.ServerLogicException.withoutPassthroughFields(field)
              }
            }
        )
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[modeldb.CrossValidationEventResponse] = _root_.scala.None
        var svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 1 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    svEx = _root_.scala.Some(readSvExValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'svEx' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          svEx,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[modeldb.CrossValidationEventResponse] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ): Result =
        new Result(
          success,
          svEx
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Tuple2[Option[modeldb.CrossValidationEventResponse], Option[modeldb.ServerLogicException]]] = _root_.scala.Some(_item.toTuple)
    
    
      @inline private[modeldb] def readSuccessValue(_iprot: TProtocol): modeldb.CrossValidationEventResponse = {
        modeldb.CrossValidationEventResponse.decode(_iprot)
      }
    
      @inline private def writeSuccessField(success_item: modeldb.CrossValidationEventResponse, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: modeldb.CrossValidationEventResponse, _oprot: TProtocol): Unit = {
        success_item.write(_oprot)
      }
    
      @inline private[modeldb] def readSvExValue(_iprot: TProtocol): modeldb.ServerLogicException = {
        modeldb.ServerLogicException.decode(_iprot)
      }
    
      @inline private def writeSvExField(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SvExField)
        writeSvExValue(svEx_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSvExValue(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        svEx_item.write(_oprot)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[modeldb.CrossValidationEventResponse],
        val svEx: _root_.scala.Option[modeldb.ServerLogicException],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[modeldb.CrossValidationEventResponse] with ThriftStruct
      with _root_.scala.Product2[Option[modeldb.CrossValidationEventResponse], Option[modeldb.ServerLogicException]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
    
      def this(
        success: _root_.scala.Option[modeldb.CrossValidationEventResponse] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ) = this(
        success,
        svEx,
        Map.empty
      )
    
      def _1: _root_.scala.Option[modeldb.CrossValidationEventResponse] = success
      def _2: _root_.scala.Option[modeldb.ServerLogicException] = svEx
    
      def toTuple: _root_.scala.Tuple2[Option[modeldb.CrossValidationEventResponse], Option[modeldb.ServerLogicException]] = {
        (
          success,
          svEx
        )
      }
    
      def successField: Option[modeldb.CrossValidationEventResponse] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Seq(svEx)
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (svEx.isDefined) writeSvExField(svEx.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[modeldb.CrossValidationEventResponse] = this.success,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = this.svEx,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          svEx,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 2
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case 1 => this.svEx
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Function1[Args,Future[modeldb.CrossValidationEventResponse]]
    type ReqRepFunctionType = Function1[_root_.com.twitter.scrooge.Request[Args],Future[_root_.com.twitter.scrooge.Response[modeldb.CrossValidationEventResponse]]]

    type ServiceIfaceServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ReqRepServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]]

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]] { request: _root_.com.twitter.scrooge.Request[Args] =>
        f(request)
      }

    private[this] val toResult = (res: SuccessType) => Result(Some(res))

    val name: String = "storeCrossValidationEvent"
    val serviceName: String = "ModelDBService"
    val argsCodec = Args
    val responseCodec = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val storeCrossValidationEvent$args = StoreCrossValidationEvent.Args
  type storeCrossValidationEvent$args = StoreCrossValidationEvent.Args

  val storeCrossValidationEvent$result = StoreCrossValidationEvent.Result
  type storeCrossValidationEvent$result = StoreCrossValidationEvent.Result

  object StoreGridSearchCrossValidationEvent extends ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("storeGridSearchCrossValidationEvent_args")
      val GscveField: TField = new TField("gscve", TType.STRUCT, 1)
      val GscveFieldManifest: Manifest[modeldb.GridSearchCrossValidationEvent] = implicitly[Manifest[modeldb.GridSearchCrossValidationEvent]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          GscveField,
          false,
          false,
          GscveFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.gscve)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          gscve =
            {
              val field = original.gscve
              modeldb.GridSearchCrossValidationEvent.withoutPassthroughFields(field)
            }
        )
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var gscve: modeldb.GridSearchCrossValidationEvent = null
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    gscve = readGscveValue(_iprot)
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'gscve' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Args(
          gscve,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        gscve: modeldb.GridSearchCrossValidationEvent
      ): Args =
        new Args(
          gscve
        )
    
      def unapply(_item: Args): _root_.scala.Option[modeldb.GridSearchCrossValidationEvent] = _root_.scala.Some(_item.gscve)
    
    
      @inline private[modeldb] def readGscveValue(_iprot: TProtocol): modeldb.GridSearchCrossValidationEvent = {
        modeldb.GridSearchCrossValidationEvent.decode(_iprot)
      }
    
      @inline private def writeGscveField(gscve_item: modeldb.GridSearchCrossValidationEvent, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(GscveField)
        writeGscveValue(gscve_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeGscveValue(gscve_item: modeldb.GridSearchCrossValidationEvent, _oprot: TProtocol): Unit = {
        gscve_item.write(_oprot)
      }
    
    
    }
    
    class Args(
        val gscve: modeldb.GridSearchCrossValidationEvent,
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product1[modeldb.GridSearchCrossValidationEvent]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
    
      def this(
        gscve: modeldb.GridSearchCrossValidationEvent
      ) = this(
        gscve,
        Map.empty
      )
    
      def _1: modeldb.GridSearchCrossValidationEvent = gscve
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        if (gscve ne null) writeGscveField(gscve, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        gscve: modeldb.GridSearchCrossValidationEvent = this.gscve,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          gscve,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.gscve
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    }

    type SuccessType = modeldb.GridSearchCrossValidationEventResponse
    
    object Result extends ValidatingThriftStructCodec3[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("storeGridSearchCrossValidationEvent_result")
      val SuccessField: TField = new TField("success", TType.STRUCT, 0)
      val SuccessFieldManifest: Manifest[modeldb.GridSearchCrossValidationEventResponse] = implicitly[Manifest[modeldb.GridSearchCrossValidationEventResponse]]
      val SvExField: TField = new TField("svEx", TType.STRUCT, 1)
      val SvExFieldManifest: Manifest[modeldb.ServerLogicException] = implicitly[Manifest[modeldb.ServerLogicException]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          SvExField,
          true,
          false,
          SvExFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf ++= validateField(item.svEx)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                modeldb.GridSearchCrossValidationEventResponse.withoutPassthroughFields(field)
              }
            },
          svEx =
            {
              val field = original.svEx
              field.map { field =>
                modeldb.ServerLogicException.withoutPassthroughFields(field)
              }
            }
        )
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[modeldb.GridSearchCrossValidationEventResponse] = _root_.scala.None
        var svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 1 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    svEx = _root_.scala.Some(readSvExValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'svEx' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          svEx,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[modeldb.GridSearchCrossValidationEventResponse] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ): Result =
        new Result(
          success,
          svEx
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Tuple2[Option[modeldb.GridSearchCrossValidationEventResponse], Option[modeldb.ServerLogicException]]] = _root_.scala.Some(_item.toTuple)
    
    
      @inline private[modeldb] def readSuccessValue(_iprot: TProtocol): modeldb.GridSearchCrossValidationEventResponse = {
        modeldb.GridSearchCrossValidationEventResponse.decode(_iprot)
      }
    
      @inline private def writeSuccessField(success_item: modeldb.GridSearchCrossValidationEventResponse, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: modeldb.GridSearchCrossValidationEventResponse, _oprot: TProtocol): Unit = {
        success_item.write(_oprot)
      }
    
      @inline private[modeldb] def readSvExValue(_iprot: TProtocol): modeldb.ServerLogicException = {
        modeldb.ServerLogicException.decode(_iprot)
      }
    
      @inline private def writeSvExField(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SvExField)
        writeSvExValue(svEx_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSvExValue(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        svEx_item.write(_oprot)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[modeldb.GridSearchCrossValidationEventResponse],
        val svEx: _root_.scala.Option[modeldb.ServerLogicException],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[modeldb.GridSearchCrossValidationEventResponse] with ThriftStruct
      with _root_.scala.Product2[Option[modeldb.GridSearchCrossValidationEventResponse], Option[modeldb.ServerLogicException]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
    
      def this(
        success: _root_.scala.Option[modeldb.GridSearchCrossValidationEventResponse] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ) = this(
        success,
        svEx,
        Map.empty
      )
    
      def _1: _root_.scala.Option[modeldb.GridSearchCrossValidationEventResponse] = success
      def _2: _root_.scala.Option[modeldb.ServerLogicException] = svEx
    
      def toTuple: _root_.scala.Tuple2[Option[modeldb.GridSearchCrossValidationEventResponse], Option[modeldb.ServerLogicException]] = {
        (
          success,
          svEx
        )
      }
    
      def successField: Option[modeldb.GridSearchCrossValidationEventResponse] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Seq(svEx)
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (svEx.isDefined) writeSvExField(svEx.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[modeldb.GridSearchCrossValidationEventResponse] = this.success,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = this.svEx,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          svEx,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 2
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case 1 => this.svEx
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Function1[Args,Future[modeldb.GridSearchCrossValidationEventResponse]]
    type ReqRepFunctionType = Function1[_root_.com.twitter.scrooge.Request[Args],Future[_root_.com.twitter.scrooge.Response[modeldb.GridSearchCrossValidationEventResponse]]]

    type ServiceIfaceServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ReqRepServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]]

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]] { request: _root_.com.twitter.scrooge.Request[Args] =>
        f(request)
      }

    private[this] val toResult = (res: SuccessType) => Result(Some(res))

    val name: String = "storeGridSearchCrossValidationEvent"
    val serviceName: String = "ModelDBService"
    val argsCodec = Args
    val responseCodec = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val storeGridSearchCrossValidationEvent$args = StoreGridSearchCrossValidationEvent.Args
  type storeGridSearchCrossValidationEvent$args = StoreGridSearchCrossValidationEvent.Args

  val storeGridSearchCrossValidationEvent$result = StoreGridSearchCrossValidationEvent.Result
  type storeGridSearchCrossValidationEvent$result = StoreGridSearchCrossValidationEvent.Result

  object StoreAnnotationEvent extends ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("storeAnnotationEvent_args")
      val AeField: TField = new TField("ae", TType.STRUCT, 1)
      val AeFieldManifest: Manifest[modeldb.AnnotationEvent] = implicitly[Manifest[modeldb.AnnotationEvent]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          AeField,
          false,
          false,
          AeFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.ae)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          ae =
            {
              val field = original.ae
              modeldb.AnnotationEvent.withoutPassthroughFields(field)
            }
        )
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var ae: modeldb.AnnotationEvent = null
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    ae = readAeValue(_iprot)
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'ae' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Args(
          ae,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        ae: modeldb.AnnotationEvent
      ): Args =
        new Args(
          ae
        )
    
      def unapply(_item: Args): _root_.scala.Option[modeldb.AnnotationEvent] = _root_.scala.Some(_item.ae)
    
    
      @inline private[modeldb] def readAeValue(_iprot: TProtocol): modeldb.AnnotationEvent = {
        modeldb.AnnotationEvent.decode(_iprot)
      }
    
      @inline private def writeAeField(ae_item: modeldb.AnnotationEvent, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(AeField)
        writeAeValue(ae_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeAeValue(ae_item: modeldb.AnnotationEvent, _oprot: TProtocol): Unit = {
        ae_item.write(_oprot)
      }
    
    
    }
    
    class Args(
        val ae: modeldb.AnnotationEvent,
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product1[modeldb.AnnotationEvent]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
    
      def this(
        ae: modeldb.AnnotationEvent
      ) = this(
        ae,
        Map.empty
      )
    
      def _1: modeldb.AnnotationEvent = ae
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        if (ae ne null) writeAeField(ae, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        ae: modeldb.AnnotationEvent = this.ae,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          ae,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.ae
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    }

    type SuccessType = modeldb.AnnotationEventResponse
    
    object Result extends ValidatingThriftStructCodec3[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("storeAnnotationEvent_result")
      val SuccessField: TField = new TField("success", TType.STRUCT, 0)
      val SuccessFieldManifest: Manifest[modeldb.AnnotationEventResponse] = implicitly[Manifest[modeldb.AnnotationEventResponse]]
      val SvExField: TField = new TField("svEx", TType.STRUCT, 1)
      val SvExFieldManifest: Manifest[modeldb.ServerLogicException] = implicitly[Manifest[modeldb.ServerLogicException]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          SvExField,
          true,
          false,
          SvExFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf ++= validateField(item.svEx)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                modeldb.AnnotationEventResponse.withoutPassthroughFields(field)
              }
            },
          svEx =
            {
              val field = original.svEx
              field.map { field =>
                modeldb.ServerLogicException.withoutPassthroughFields(field)
              }
            }
        )
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[modeldb.AnnotationEventResponse] = _root_.scala.None
        var svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 1 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    svEx = _root_.scala.Some(readSvExValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'svEx' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          svEx,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[modeldb.AnnotationEventResponse] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ): Result =
        new Result(
          success,
          svEx
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Tuple2[Option[modeldb.AnnotationEventResponse], Option[modeldb.ServerLogicException]]] = _root_.scala.Some(_item.toTuple)
    
    
      @inline private[modeldb] def readSuccessValue(_iprot: TProtocol): modeldb.AnnotationEventResponse = {
        modeldb.AnnotationEventResponse.decode(_iprot)
      }
    
      @inline private def writeSuccessField(success_item: modeldb.AnnotationEventResponse, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: modeldb.AnnotationEventResponse, _oprot: TProtocol): Unit = {
        success_item.write(_oprot)
      }
    
      @inline private[modeldb] def readSvExValue(_iprot: TProtocol): modeldb.ServerLogicException = {
        modeldb.ServerLogicException.decode(_iprot)
      }
    
      @inline private def writeSvExField(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SvExField)
        writeSvExValue(svEx_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSvExValue(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        svEx_item.write(_oprot)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[modeldb.AnnotationEventResponse],
        val svEx: _root_.scala.Option[modeldb.ServerLogicException],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[modeldb.AnnotationEventResponse] with ThriftStruct
      with _root_.scala.Product2[Option[modeldb.AnnotationEventResponse], Option[modeldb.ServerLogicException]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
    
      def this(
        success: _root_.scala.Option[modeldb.AnnotationEventResponse] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ) = this(
        success,
        svEx,
        Map.empty
      )
    
      def _1: _root_.scala.Option[modeldb.AnnotationEventResponse] = success
      def _2: _root_.scala.Option[modeldb.ServerLogicException] = svEx
    
      def toTuple: _root_.scala.Tuple2[Option[modeldb.AnnotationEventResponse], Option[modeldb.ServerLogicException]] = {
        (
          success,
          svEx
        )
      }
    
      def successField: Option[modeldb.AnnotationEventResponse] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Seq(svEx)
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (svEx.isDefined) writeSvExField(svEx.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[modeldb.AnnotationEventResponse] = this.success,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = this.svEx,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          svEx,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 2
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case 1 => this.svEx
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Function1[Args,Future[modeldb.AnnotationEventResponse]]
    type ReqRepFunctionType = Function1[_root_.com.twitter.scrooge.Request[Args],Future[_root_.com.twitter.scrooge.Response[modeldb.AnnotationEventResponse]]]

    type ServiceIfaceServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ReqRepServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]]

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]] { request: _root_.com.twitter.scrooge.Request[Args] =>
        f(request)
      }

    private[this] val toResult = (res: SuccessType) => Result(Some(res))

    val name: String = "storeAnnotationEvent"
    val serviceName: String = "ModelDBService"
    val argsCodec = Args
    val responseCodec = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val storeAnnotationEvent$args = StoreAnnotationEvent.Args
  type storeAnnotationEvent$args = StoreAnnotationEvent.Args

  val storeAnnotationEvent$result = StoreAnnotationEvent.Result
  type storeAnnotationEvent$result = StoreAnnotationEvent.Result

  object StoreProjectEvent extends ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("storeProjectEvent_args")
      val PrField: TField = new TField("pr", TType.STRUCT, 1)
      val PrFieldManifest: Manifest[modeldb.ProjectEvent] = implicitly[Manifest[modeldb.ProjectEvent]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          PrField,
          false,
          false,
          PrFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.pr)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          pr =
            {
              val field = original.pr
              modeldb.ProjectEvent.withoutPassthroughFields(field)
            }
        )
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var pr: modeldb.ProjectEvent = null
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    pr = readPrValue(_iprot)
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'pr' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Args(
          pr,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        pr: modeldb.ProjectEvent
      ): Args =
        new Args(
          pr
        )
    
      def unapply(_item: Args): _root_.scala.Option[modeldb.ProjectEvent] = _root_.scala.Some(_item.pr)
    
    
      @inline private[modeldb] def readPrValue(_iprot: TProtocol): modeldb.ProjectEvent = {
        modeldb.ProjectEvent.decode(_iprot)
      }
    
      @inline private def writePrField(pr_item: modeldb.ProjectEvent, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(PrField)
        writePrValue(pr_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writePrValue(pr_item: modeldb.ProjectEvent, _oprot: TProtocol): Unit = {
        pr_item.write(_oprot)
      }
    
    
    }
    
    class Args(
        val pr: modeldb.ProjectEvent,
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product1[modeldb.ProjectEvent]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
    
      def this(
        pr: modeldb.ProjectEvent
      ) = this(
        pr,
        Map.empty
      )
    
      def _1: modeldb.ProjectEvent = pr
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        if (pr ne null) writePrField(pr, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        pr: modeldb.ProjectEvent = this.pr,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          pr,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.pr
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    }

    type SuccessType = modeldb.ProjectEventResponse
    
    object Result extends ValidatingThriftStructCodec3[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("storeProjectEvent_result")
      val SuccessField: TField = new TField("success", TType.STRUCT, 0)
      val SuccessFieldManifest: Manifest[modeldb.ProjectEventResponse] = implicitly[Manifest[modeldb.ProjectEventResponse]]
      val SvExField: TField = new TField("svEx", TType.STRUCT, 1)
      val SvExFieldManifest: Manifest[modeldb.ServerLogicException] = implicitly[Manifest[modeldb.ServerLogicException]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          SvExField,
          true,
          false,
          SvExFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf ++= validateField(item.svEx)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                modeldb.ProjectEventResponse.withoutPassthroughFields(field)
              }
            },
          svEx =
            {
              val field = original.svEx
              field.map { field =>
                modeldb.ServerLogicException.withoutPassthroughFields(field)
              }
            }
        )
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[modeldb.ProjectEventResponse] = _root_.scala.None
        var svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 1 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    svEx = _root_.scala.Some(readSvExValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'svEx' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          svEx,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[modeldb.ProjectEventResponse] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ): Result =
        new Result(
          success,
          svEx
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Tuple2[Option[modeldb.ProjectEventResponse], Option[modeldb.ServerLogicException]]] = _root_.scala.Some(_item.toTuple)
    
    
      @inline private[modeldb] def readSuccessValue(_iprot: TProtocol): modeldb.ProjectEventResponse = {
        modeldb.ProjectEventResponse.decode(_iprot)
      }
    
      @inline private def writeSuccessField(success_item: modeldb.ProjectEventResponse, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: modeldb.ProjectEventResponse, _oprot: TProtocol): Unit = {
        success_item.write(_oprot)
      }
    
      @inline private[modeldb] def readSvExValue(_iprot: TProtocol): modeldb.ServerLogicException = {
        modeldb.ServerLogicException.decode(_iprot)
      }
    
      @inline private def writeSvExField(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SvExField)
        writeSvExValue(svEx_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSvExValue(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        svEx_item.write(_oprot)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[modeldb.ProjectEventResponse],
        val svEx: _root_.scala.Option[modeldb.ServerLogicException],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[modeldb.ProjectEventResponse] with ThriftStruct
      with _root_.scala.Product2[Option[modeldb.ProjectEventResponse], Option[modeldb.ServerLogicException]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
    
      def this(
        success: _root_.scala.Option[modeldb.ProjectEventResponse] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ) = this(
        success,
        svEx,
        Map.empty
      )
    
      def _1: _root_.scala.Option[modeldb.ProjectEventResponse] = success
      def _2: _root_.scala.Option[modeldb.ServerLogicException] = svEx
    
      def toTuple: _root_.scala.Tuple2[Option[modeldb.ProjectEventResponse], Option[modeldb.ServerLogicException]] = {
        (
          success,
          svEx
        )
      }
    
      def successField: Option[modeldb.ProjectEventResponse] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Seq(svEx)
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (svEx.isDefined) writeSvExField(svEx.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[modeldb.ProjectEventResponse] = this.success,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = this.svEx,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          svEx,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 2
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case 1 => this.svEx
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Function1[Args,Future[modeldb.ProjectEventResponse]]
    type ReqRepFunctionType = Function1[_root_.com.twitter.scrooge.Request[Args],Future[_root_.com.twitter.scrooge.Response[modeldb.ProjectEventResponse]]]

    type ServiceIfaceServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ReqRepServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]]

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]] { request: _root_.com.twitter.scrooge.Request[Args] =>
        f(request)
      }

    private[this] val toResult = (res: SuccessType) => Result(Some(res))

    val name: String = "storeProjectEvent"
    val serviceName: String = "ModelDBService"
    val argsCodec = Args
    val responseCodec = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val storeProjectEvent$args = StoreProjectEvent.Args
  type storeProjectEvent$args = StoreProjectEvent.Args

  val storeProjectEvent$result = StoreProjectEvent.Result
  type storeProjectEvent$result = StoreProjectEvent.Result

  object StoreExperimentEvent extends ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("storeExperimentEvent_args")
      val ErField: TField = new TField("er", TType.STRUCT, 1)
      val ErFieldManifest: Manifest[modeldb.ExperimentEvent] = implicitly[Manifest[modeldb.ExperimentEvent]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          ErField,
          false,
          false,
          ErFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.er)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          er =
            {
              val field = original.er
              modeldb.ExperimentEvent.withoutPassthroughFields(field)
            }
        )
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var er: modeldb.ExperimentEvent = null
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    er = readErValue(_iprot)
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'er' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Args(
          er,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        er: modeldb.ExperimentEvent
      ): Args =
        new Args(
          er
        )
    
      def unapply(_item: Args): _root_.scala.Option[modeldb.ExperimentEvent] = _root_.scala.Some(_item.er)
    
    
      @inline private[modeldb] def readErValue(_iprot: TProtocol): modeldb.ExperimentEvent = {
        modeldb.ExperimentEvent.decode(_iprot)
      }
    
      @inline private def writeErField(er_item: modeldb.ExperimentEvent, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(ErField)
        writeErValue(er_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeErValue(er_item: modeldb.ExperimentEvent, _oprot: TProtocol): Unit = {
        er_item.write(_oprot)
      }
    
    
    }
    
    class Args(
        val er: modeldb.ExperimentEvent,
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product1[modeldb.ExperimentEvent]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
    
      def this(
        er: modeldb.ExperimentEvent
      ) = this(
        er,
        Map.empty
      )
    
      def _1: modeldb.ExperimentEvent = er
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        if (er ne null) writeErField(er, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        er: modeldb.ExperimentEvent = this.er,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          er,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.er
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    }

    type SuccessType = modeldb.ExperimentEventResponse
    
    object Result extends ValidatingThriftStructCodec3[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("storeExperimentEvent_result")
      val SuccessField: TField = new TField("success", TType.STRUCT, 0)
      val SuccessFieldManifest: Manifest[modeldb.ExperimentEventResponse] = implicitly[Manifest[modeldb.ExperimentEventResponse]]
      val SvExField: TField = new TField("svEx", TType.STRUCT, 1)
      val SvExFieldManifest: Manifest[modeldb.ServerLogicException] = implicitly[Manifest[modeldb.ServerLogicException]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          SvExField,
          true,
          false,
          SvExFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf ++= validateField(item.svEx)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                modeldb.ExperimentEventResponse.withoutPassthroughFields(field)
              }
            },
          svEx =
            {
              val field = original.svEx
              field.map { field =>
                modeldb.ServerLogicException.withoutPassthroughFields(field)
              }
            }
        )
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[modeldb.ExperimentEventResponse] = _root_.scala.None
        var svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 1 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    svEx = _root_.scala.Some(readSvExValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'svEx' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          svEx,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[modeldb.ExperimentEventResponse] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ): Result =
        new Result(
          success,
          svEx
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Tuple2[Option[modeldb.ExperimentEventResponse], Option[modeldb.ServerLogicException]]] = _root_.scala.Some(_item.toTuple)
    
    
      @inline private[modeldb] def readSuccessValue(_iprot: TProtocol): modeldb.ExperimentEventResponse = {
        modeldb.ExperimentEventResponse.decode(_iprot)
      }
    
      @inline private def writeSuccessField(success_item: modeldb.ExperimentEventResponse, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: modeldb.ExperimentEventResponse, _oprot: TProtocol): Unit = {
        success_item.write(_oprot)
      }
    
      @inline private[modeldb] def readSvExValue(_iprot: TProtocol): modeldb.ServerLogicException = {
        modeldb.ServerLogicException.decode(_iprot)
      }
    
      @inline private def writeSvExField(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SvExField)
        writeSvExValue(svEx_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSvExValue(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        svEx_item.write(_oprot)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[modeldb.ExperimentEventResponse],
        val svEx: _root_.scala.Option[modeldb.ServerLogicException],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[modeldb.ExperimentEventResponse] with ThriftStruct
      with _root_.scala.Product2[Option[modeldb.ExperimentEventResponse], Option[modeldb.ServerLogicException]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
    
      def this(
        success: _root_.scala.Option[modeldb.ExperimentEventResponse] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ) = this(
        success,
        svEx,
        Map.empty
      )
    
      def _1: _root_.scala.Option[modeldb.ExperimentEventResponse] = success
      def _2: _root_.scala.Option[modeldb.ServerLogicException] = svEx
    
      def toTuple: _root_.scala.Tuple2[Option[modeldb.ExperimentEventResponse], Option[modeldb.ServerLogicException]] = {
        (
          success,
          svEx
        )
      }
    
      def successField: Option[modeldb.ExperimentEventResponse] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Seq(svEx)
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (svEx.isDefined) writeSvExField(svEx.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[modeldb.ExperimentEventResponse] = this.success,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = this.svEx,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          svEx,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 2
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case 1 => this.svEx
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Function1[Args,Future[modeldb.ExperimentEventResponse]]
    type ReqRepFunctionType = Function1[_root_.com.twitter.scrooge.Request[Args],Future[_root_.com.twitter.scrooge.Response[modeldb.ExperimentEventResponse]]]

    type ServiceIfaceServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ReqRepServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]]

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]] { request: _root_.com.twitter.scrooge.Request[Args] =>
        f(request)
      }

    private[this] val toResult = (res: SuccessType) => Result(Some(res))

    val name: String = "storeExperimentEvent"
    val serviceName: String = "ModelDBService"
    val argsCodec = Args
    val responseCodec = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val storeExperimentEvent$args = StoreExperimentEvent.Args
  type storeExperimentEvent$args = StoreExperimentEvent.Args

  val storeExperimentEvent$result = StoreExperimentEvent.Result
  type storeExperimentEvent$result = StoreExperimentEvent.Result

  object StoreExperimentRunEvent extends ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("storeExperimentRunEvent_args")
      val ErField: TField = new TField("er", TType.STRUCT, 1)
      val ErFieldManifest: Manifest[modeldb.ExperimentRunEvent] = implicitly[Manifest[modeldb.ExperimentRunEvent]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          ErField,
          false,
          false,
          ErFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.er)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          er =
            {
              val field = original.er
              modeldb.ExperimentRunEvent.withoutPassthroughFields(field)
            }
        )
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var er: modeldb.ExperimentRunEvent = null
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    er = readErValue(_iprot)
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'er' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Args(
          er,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        er: modeldb.ExperimentRunEvent
      ): Args =
        new Args(
          er
        )
    
      def unapply(_item: Args): _root_.scala.Option[modeldb.ExperimentRunEvent] = _root_.scala.Some(_item.er)
    
    
      @inline private[modeldb] def readErValue(_iprot: TProtocol): modeldb.ExperimentRunEvent = {
        modeldb.ExperimentRunEvent.decode(_iprot)
      }
    
      @inline private def writeErField(er_item: modeldb.ExperimentRunEvent, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(ErField)
        writeErValue(er_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeErValue(er_item: modeldb.ExperimentRunEvent, _oprot: TProtocol): Unit = {
        er_item.write(_oprot)
      }
    
    
    }
    
    class Args(
        val er: modeldb.ExperimentRunEvent,
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product1[modeldb.ExperimentRunEvent]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
    
      def this(
        er: modeldb.ExperimentRunEvent
      ) = this(
        er,
        Map.empty
      )
    
      def _1: modeldb.ExperimentRunEvent = er
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        if (er ne null) writeErField(er, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        er: modeldb.ExperimentRunEvent = this.er,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          er,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.er
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    }

    type SuccessType = modeldb.ExperimentRunEventResponse
    
    object Result extends ValidatingThriftStructCodec3[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("storeExperimentRunEvent_result")
      val SuccessField: TField = new TField("success", TType.STRUCT, 0)
      val SuccessFieldManifest: Manifest[modeldb.ExperimentRunEventResponse] = implicitly[Manifest[modeldb.ExperimentRunEventResponse]]
      val SvExField: TField = new TField("svEx", TType.STRUCT, 1)
      val SvExFieldManifest: Manifest[modeldb.ServerLogicException] = implicitly[Manifest[modeldb.ServerLogicException]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          SvExField,
          true,
          false,
          SvExFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf ++= validateField(item.svEx)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                modeldb.ExperimentRunEventResponse.withoutPassthroughFields(field)
              }
            },
          svEx =
            {
              val field = original.svEx
              field.map { field =>
                modeldb.ServerLogicException.withoutPassthroughFields(field)
              }
            }
        )
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[modeldb.ExperimentRunEventResponse] = _root_.scala.None
        var svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 1 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    svEx = _root_.scala.Some(readSvExValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'svEx' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          svEx,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[modeldb.ExperimentRunEventResponse] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ): Result =
        new Result(
          success,
          svEx
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Tuple2[Option[modeldb.ExperimentRunEventResponse], Option[modeldb.ServerLogicException]]] = _root_.scala.Some(_item.toTuple)
    
    
      @inline private[modeldb] def readSuccessValue(_iprot: TProtocol): modeldb.ExperimentRunEventResponse = {
        modeldb.ExperimentRunEventResponse.decode(_iprot)
      }
    
      @inline private def writeSuccessField(success_item: modeldb.ExperimentRunEventResponse, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: modeldb.ExperimentRunEventResponse, _oprot: TProtocol): Unit = {
        success_item.write(_oprot)
      }
    
      @inline private[modeldb] def readSvExValue(_iprot: TProtocol): modeldb.ServerLogicException = {
        modeldb.ServerLogicException.decode(_iprot)
      }
    
      @inline private def writeSvExField(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SvExField)
        writeSvExValue(svEx_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSvExValue(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        svEx_item.write(_oprot)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[modeldb.ExperimentRunEventResponse],
        val svEx: _root_.scala.Option[modeldb.ServerLogicException],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[modeldb.ExperimentRunEventResponse] with ThriftStruct
      with _root_.scala.Product2[Option[modeldb.ExperimentRunEventResponse], Option[modeldb.ServerLogicException]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
    
      def this(
        success: _root_.scala.Option[modeldb.ExperimentRunEventResponse] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ) = this(
        success,
        svEx,
        Map.empty
      )
    
      def _1: _root_.scala.Option[modeldb.ExperimentRunEventResponse] = success
      def _2: _root_.scala.Option[modeldb.ServerLogicException] = svEx
    
      def toTuple: _root_.scala.Tuple2[Option[modeldb.ExperimentRunEventResponse], Option[modeldb.ServerLogicException]] = {
        (
          success,
          svEx
        )
      }
    
      def successField: Option[modeldb.ExperimentRunEventResponse] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Seq(svEx)
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (svEx.isDefined) writeSvExField(svEx.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[modeldb.ExperimentRunEventResponse] = this.success,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = this.svEx,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          svEx,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 2
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case 1 => this.svEx
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Function1[Args,Future[modeldb.ExperimentRunEventResponse]]
    type ReqRepFunctionType = Function1[_root_.com.twitter.scrooge.Request[Args],Future[_root_.com.twitter.scrooge.Response[modeldb.ExperimentRunEventResponse]]]

    type ServiceIfaceServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ReqRepServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]]

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]] { request: _root_.com.twitter.scrooge.Request[Args] =>
        f(request)
      }

    private[this] val toResult = (res: SuccessType) => Result(Some(res))

    val name: String = "storeExperimentRunEvent"
    val serviceName: String = "ModelDBService"
    val argsCodec = Args
    val responseCodec = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val storeExperimentRunEvent$args = StoreExperimentRunEvent.Args
  type storeExperimentRunEvent$args = StoreExperimentRunEvent.Args

  val storeExperimentRunEvent$result = StoreExperimentRunEvent.Result
  type storeExperimentRunEvent$result = StoreExperimentRunEvent.Result

  object StoreLinearModel extends ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("storeLinearModel_args")
      val ModelIdField: TField = new TField("modelId", TType.I32, 1)
      val ModelIdFieldManifest: Manifest[Int] = implicitly[Manifest[Int]]
      val ModelField: TField = new TField("model", TType.STRUCT, 2)
      val ModelFieldManifest: Manifest[modeldb.LinearModel] = implicitly[Manifest[modeldb.LinearModel]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          ModelIdField,
          false,
          false,
          ModelIdFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          ModelField,
          false,
          false,
          ModelFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.modelId)
        buf ++= validateField(item.model)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          modelId =
            {
              val field = original.modelId
              field
            },
          model =
            {
              val field = original.model
              modeldb.LinearModel.withoutPassthroughFields(field)
            }
        )
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var modelId: Int = 0
        var model: modeldb.LinearModel = null
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.I32 =>
                    modelId = readModelIdValue(_iprot)
                  case _actualType =>
                    val _expectedType = TType.I32
                    throw new TProtocolException(
                      "Received wrong type for field 'modelId' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 2 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    model = readModelValue(_iprot)
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'model' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Args(
          modelId,
          model,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        modelId: Int,
        model: modeldb.LinearModel
      ): Args =
        new Args(
          modelId,
          model
        )
    
      def unapply(_item: Args): _root_.scala.Option[_root_.scala.Tuple2[Int, modeldb.LinearModel]] = _root_.scala.Some(_item.toTuple)
    
    
      @inline private[modeldb] def readModelIdValue(_iprot: TProtocol): Int = {
        _iprot.readI32()
      }
    
      @inline private def writeModelIdField(modelId_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(ModelIdField)
        writeModelIdValue(modelId_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeModelIdValue(modelId_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeI32(modelId_item)
      }
    
      @inline private[modeldb] def readModelValue(_iprot: TProtocol): modeldb.LinearModel = {
        modeldb.LinearModel.decode(_iprot)
      }
    
      @inline private def writeModelField(model_item: modeldb.LinearModel, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(ModelField)
        writeModelValue(model_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeModelValue(model_item: modeldb.LinearModel, _oprot: TProtocol): Unit = {
        model_item.write(_oprot)
      }
    
    
    }
    
    class Args(
        val modelId: Int,
        val model: modeldb.LinearModel,
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product2[Int, modeldb.LinearModel]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
    
      def this(
        modelId: Int,
        model: modeldb.LinearModel
      ) = this(
        modelId,
        model,
        Map.empty
      )
    
      def _1: Int = modelId
      def _2: modeldb.LinearModel = model
    
      def toTuple: _root_.scala.Tuple2[Int, modeldb.LinearModel] = {
        (
          modelId,
          model
        )
      }
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        writeModelIdField(modelId, _oprot)
        if (model ne null) writeModelField(model, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        modelId: Int = this.modelId,
        model: modeldb.LinearModel = this.model,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          modelId,
          model,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 2
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.modelId
        case 1 => this.model
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    }

    type SuccessType = Boolean
    
    object Result extends ValidatingThriftStructCodec3[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("storeLinearModel_result")
      val SuccessField: TField = new TField("success", TType.BOOL, 0)
      val SuccessFieldManifest: Manifest[Boolean] = implicitly[Manifest[Boolean]]
      val RnfExField: TField = new TField("rnfEx", TType.STRUCT, 1)
      val RnfExFieldManifest: Manifest[modeldb.ResourceNotFoundException] = implicitly[Manifest[modeldb.ResourceNotFoundException]]
      val SvExField: TField = new TField("svEx", TType.STRUCT, 2)
      val SvExFieldManifest: Manifest[modeldb.ServerLogicException] = implicitly[Manifest[modeldb.ServerLogicException]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          RnfExField,
          true,
          false,
          RnfExFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          SvExField,
          true,
          false,
          SvExFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf ++= validateField(item.rnfEx)
        buf ++= validateField(item.svEx)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                field
              }
            },
          rnfEx =
            {
              val field = original.rnfEx
              field.map { field =>
                modeldb.ResourceNotFoundException.withoutPassthroughFields(field)
              }
            },
          svEx =
            {
              val field = original.svEx
              field.map { field =>
                modeldb.ServerLogicException.withoutPassthroughFields(field)
              }
            }
        )
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[Boolean] = _root_.scala.None
        var rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException] = _root_.scala.None
        var svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.BOOL =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.BOOL
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 1 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    rnfEx = _root_.scala.Some(readRnfExValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'rnfEx' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 2 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    svEx = _root_.scala.Some(readSvExValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'svEx' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          rnfEx,
          svEx,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[Boolean] = _root_.scala.None,
        rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ): Result =
        new Result(
          success,
          rnfEx,
          svEx
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Tuple3[Option[Boolean], Option[modeldb.ResourceNotFoundException], Option[modeldb.ServerLogicException]]] = _root_.scala.Some(_item.toTuple)
    
    
      @inline private[modeldb] def readSuccessValue(_iprot: TProtocol): Boolean = {
        _iprot.readBool()
      }
    
      @inline private def writeSuccessField(success_item: Boolean, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: Boolean, _oprot: TProtocol): Unit = {
        _oprot.writeBool(success_item)
      }
    
      @inline private[modeldb] def readRnfExValue(_iprot: TProtocol): modeldb.ResourceNotFoundException = {
        modeldb.ResourceNotFoundException.decode(_iprot)
      }
    
      @inline private def writeRnfExField(rnfEx_item: modeldb.ResourceNotFoundException, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(RnfExField)
        writeRnfExValue(rnfEx_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeRnfExValue(rnfEx_item: modeldb.ResourceNotFoundException, _oprot: TProtocol): Unit = {
        rnfEx_item.write(_oprot)
      }
    
      @inline private[modeldb] def readSvExValue(_iprot: TProtocol): modeldb.ServerLogicException = {
        modeldb.ServerLogicException.decode(_iprot)
      }
    
      @inline private def writeSvExField(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SvExField)
        writeSvExValue(svEx_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSvExValue(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        svEx_item.write(_oprot)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[Boolean],
        val rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException],
        val svEx: _root_.scala.Option[modeldb.ServerLogicException],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[Boolean] with ThriftStruct
      with _root_.scala.Product3[Option[Boolean], Option[modeldb.ResourceNotFoundException], Option[modeldb.ServerLogicException]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
    
      def this(
        success: _root_.scala.Option[Boolean] = _root_.scala.None,
        rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ) = this(
        success,
        rnfEx,
        svEx,
        Map.empty
      )
    
      def _1: _root_.scala.Option[Boolean] = success
      def _2: _root_.scala.Option[modeldb.ResourceNotFoundException] = rnfEx
      def _3: _root_.scala.Option[modeldb.ServerLogicException] = svEx
    
      def toTuple: _root_.scala.Tuple3[Option[Boolean], Option[modeldb.ResourceNotFoundException], Option[modeldb.ServerLogicException]] = {
        (
          success,
          rnfEx,
          svEx
        )
      }
    
      def successField: Option[Boolean] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Seq(rnfEx, svEx)
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (rnfEx.isDefined) writeRnfExField(rnfEx.get, _oprot)
        if (svEx.isDefined) writeSvExField(svEx.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[Boolean] = this.success,
        rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException] = this.rnfEx,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = this.svEx,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          rnfEx,
          svEx,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 3
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case 1 => this.rnfEx
        case 2 => this.svEx
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Function1[Args,Future[Boolean]]
    type ReqRepFunctionType = Function1[_root_.com.twitter.scrooge.Request[Args],Future[_root_.com.twitter.scrooge.Response[Boolean]]]

    type ServiceIfaceServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ReqRepServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]]

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]] { request: _root_.com.twitter.scrooge.Request[Args] =>
        f(request)
      }

    private[this] val toResult = (res: SuccessType) => Result(Some(res))

    val name: String = "storeLinearModel"
    val serviceName: String = "ModelDBService"
    val argsCodec = Args
    val responseCodec = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val storeLinearModel$args = StoreLinearModel.Args
  type storeLinearModel$args = StoreLinearModel.Args

  val storeLinearModel$result = StoreLinearModel.Result
  type storeLinearModel$result = StoreLinearModel.Result

  object GetDataFrameAncestry extends ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("getDataFrameAncestry_args")
      val DataFrameIdField: TField = new TField("dataFrameId", TType.I32, 1)
      val DataFrameIdFieldManifest: Manifest[Int] = implicitly[Manifest[Int]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          DataFrameIdField,
          false,
          false,
          DataFrameIdFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.dataFrameId)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          dataFrameId =
            {
              val field = original.dataFrameId
              field
            }
        )
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var dataFrameId: Int = 0
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.I32 =>
                    dataFrameId = readDataFrameIdValue(_iprot)
                  case _actualType =>
                    val _expectedType = TType.I32
                    throw new TProtocolException(
                      "Received wrong type for field 'dataFrameId' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Args(
          dataFrameId,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        dataFrameId: Int
      ): Args =
        new Args(
          dataFrameId
        )
    
      def unapply(_item: Args): _root_.scala.Option[Int] = _root_.scala.Some(_item.dataFrameId)
    
    
      @inline private[modeldb] def readDataFrameIdValue(_iprot: TProtocol): Int = {
        _iprot.readI32()
      }
    
      @inline private def writeDataFrameIdField(dataFrameId_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(DataFrameIdField)
        writeDataFrameIdValue(dataFrameId_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeDataFrameIdValue(dataFrameId_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeI32(dataFrameId_item)
      }
    
    
    }
    
    class Args(
        val dataFrameId: Int,
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product1[Int]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
    
      def this(
        dataFrameId: Int
      ) = this(
        dataFrameId,
        Map.empty
      )
    
      def _1: Int = dataFrameId
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        writeDataFrameIdField(dataFrameId, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        dataFrameId: Int = this.dataFrameId,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          dataFrameId,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.dataFrameId
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    }

    type SuccessType = modeldb.DataFrameAncestry
    
    object Result extends ValidatingThriftStructCodec3[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("getDataFrameAncestry_result")
      val SuccessField: TField = new TField("success", TType.STRUCT, 0)
      val SuccessFieldManifest: Manifest[modeldb.DataFrameAncestry] = implicitly[Manifest[modeldb.DataFrameAncestry]]
      val RnfExField: TField = new TField("rnfEx", TType.STRUCT, 1)
      val RnfExFieldManifest: Manifest[modeldb.ResourceNotFoundException] = implicitly[Manifest[modeldb.ResourceNotFoundException]]
      val SvExField: TField = new TField("svEx", TType.STRUCT, 2)
      val SvExFieldManifest: Manifest[modeldb.ServerLogicException] = implicitly[Manifest[modeldb.ServerLogicException]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          RnfExField,
          true,
          false,
          RnfExFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          SvExField,
          true,
          false,
          SvExFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf ++= validateField(item.rnfEx)
        buf ++= validateField(item.svEx)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                modeldb.DataFrameAncestry.withoutPassthroughFields(field)
              }
            },
          rnfEx =
            {
              val field = original.rnfEx
              field.map { field =>
                modeldb.ResourceNotFoundException.withoutPassthroughFields(field)
              }
            },
          svEx =
            {
              val field = original.svEx
              field.map { field =>
                modeldb.ServerLogicException.withoutPassthroughFields(field)
              }
            }
        )
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[modeldb.DataFrameAncestry] = _root_.scala.None
        var rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException] = _root_.scala.None
        var svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 1 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    rnfEx = _root_.scala.Some(readRnfExValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'rnfEx' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 2 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    svEx = _root_.scala.Some(readSvExValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'svEx' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          rnfEx,
          svEx,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[modeldb.DataFrameAncestry] = _root_.scala.None,
        rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ): Result =
        new Result(
          success,
          rnfEx,
          svEx
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Tuple3[Option[modeldb.DataFrameAncestry], Option[modeldb.ResourceNotFoundException], Option[modeldb.ServerLogicException]]] = _root_.scala.Some(_item.toTuple)
    
    
      @inline private[modeldb] def readSuccessValue(_iprot: TProtocol): modeldb.DataFrameAncestry = {
        modeldb.DataFrameAncestry.decode(_iprot)
      }
    
      @inline private def writeSuccessField(success_item: modeldb.DataFrameAncestry, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: modeldb.DataFrameAncestry, _oprot: TProtocol): Unit = {
        success_item.write(_oprot)
      }
    
      @inline private[modeldb] def readRnfExValue(_iprot: TProtocol): modeldb.ResourceNotFoundException = {
        modeldb.ResourceNotFoundException.decode(_iprot)
      }
    
      @inline private def writeRnfExField(rnfEx_item: modeldb.ResourceNotFoundException, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(RnfExField)
        writeRnfExValue(rnfEx_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeRnfExValue(rnfEx_item: modeldb.ResourceNotFoundException, _oprot: TProtocol): Unit = {
        rnfEx_item.write(_oprot)
      }
    
      @inline private[modeldb] def readSvExValue(_iprot: TProtocol): modeldb.ServerLogicException = {
        modeldb.ServerLogicException.decode(_iprot)
      }
    
      @inline private def writeSvExField(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SvExField)
        writeSvExValue(svEx_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSvExValue(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        svEx_item.write(_oprot)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[modeldb.DataFrameAncestry],
        val rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException],
        val svEx: _root_.scala.Option[modeldb.ServerLogicException],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[modeldb.DataFrameAncestry] with ThriftStruct
      with _root_.scala.Product3[Option[modeldb.DataFrameAncestry], Option[modeldb.ResourceNotFoundException], Option[modeldb.ServerLogicException]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
    
      def this(
        success: _root_.scala.Option[modeldb.DataFrameAncestry] = _root_.scala.None,
        rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ) = this(
        success,
        rnfEx,
        svEx,
        Map.empty
      )
    
      def _1: _root_.scala.Option[modeldb.DataFrameAncestry] = success
      def _2: _root_.scala.Option[modeldb.ResourceNotFoundException] = rnfEx
      def _3: _root_.scala.Option[modeldb.ServerLogicException] = svEx
    
      def toTuple: _root_.scala.Tuple3[Option[modeldb.DataFrameAncestry], Option[modeldb.ResourceNotFoundException], Option[modeldb.ServerLogicException]] = {
        (
          success,
          rnfEx,
          svEx
        )
      }
    
      def successField: Option[modeldb.DataFrameAncestry] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Seq(rnfEx, svEx)
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (rnfEx.isDefined) writeRnfExField(rnfEx.get, _oprot)
        if (svEx.isDefined) writeSvExField(svEx.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[modeldb.DataFrameAncestry] = this.success,
        rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException] = this.rnfEx,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = this.svEx,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          rnfEx,
          svEx,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 3
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case 1 => this.rnfEx
        case 2 => this.svEx
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Function1[Args,Future[modeldb.DataFrameAncestry]]
    type ReqRepFunctionType = Function1[_root_.com.twitter.scrooge.Request[Args],Future[_root_.com.twitter.scrooge.Response[modeldb.DataFrameAncestry]]]

    type ServiceIfaceServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ReqRepServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]]

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]] { request: _root_.com.twitter.scrooge.Request[Args] =>
        f(request)
      }

    private[this] val toResult = (res: SuccessType) => Result(Some(res))

    val name: String = "getDataFrameAncestry"
    val serviceName: String = "ModelDBService"
    val argsCodec = Args
    val responseCodec = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val getDataFrameAncestry$args = GetDataFrameAncestry.Args
  type getDataFrameAncestry$args = GetDataFrameAncestry.Args

  val getDataFrameAncestry$result = GetDataFrameAncestry.Result
  type getDataFrameAncestry$result = GetDataFrameAncestry.Result

  object GetCommonAncestor extends ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("getCommonAncestor_args")
      val DfId1Field: TField = new TField("dfId1", TType.I32, 1)
      val DfId1FieldManifest: Manifest[Int] = implicitly[Manifest[Int]]
      val DfId2Field: TField = new TField("dfId2", TType.I32, 2)
      val DfId2FieldManifest: Manifest[Int] = implicitly[Manifest[Int]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          DfId1Field,
          false,
          false,
          DfId1FieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          DfId2Field,
          false,
          false,
          DfId2FieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.dfId1)
        buf ++= validateField(item.dfId2)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          dfId1 =
            {
              val field = original.dfId1
              field
            },
          dfId2 =
            {
              val field = original.dfId2
              field
            }
        )
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var dfId1: Int = 0
        var dfId2: Int = 0
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.I32 =>
                    dfId1 = readDfId1Value(_iprot)
                  case _actualType =>
                    val _expectedType = TType.I32
                    throw new TProtocolException(
                      "Received wrong type for field 'dfId1' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 2 =>
                _field.`type` match {
                  case TType.I32 =>
                    dfId2 = readDfId2Value(_iprot)
                  case _actualType =>
                    val _expectedType = TType.I32
                    throw new TProtocolException(
                      "Received wrong type for field 'dfId2' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Args(
          dfId1,
          dfId2,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        dfId1: Int,
        dfId2: Int
      ): Args =
        new Args(
          dfId1,
          dfId2
        )
    
      def unapply(_item: Args): _root_.scala.Option[_root_.scala.Tuple2[Int, Int]] = _root_.scala.Some(_item.toTuple)
    
    
      @inline private[modeldb] def readDfId1Value(_iprot: TProtocol): Int = {
        _iprot.readI32()
      }
    
      @inline private def writeDfId1Field(dfId1_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(DfId1Field)
        writeDfId1Value(dfId1_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeDfId1Value(dfId1_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeI32(dfId1_item)
      }
    
      @inline private[modeldb] def readDfId2Value(_iprot: TProtocol): Int = {
        _iprot.readI32()
      }
    
      @inline private def writeDfId2Field(dfId2_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(DfId2Field)
        writeDfId2Value(dfId2_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeDfId2Value(dfId2_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeI32(dfId2_item)
      }
    
    
    }
    
    class Args(
        val dfId1: Int,
        val dfId2: Int,
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product2[Int, Int]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
    
      def this(
        dfId1: Int,
        dfId2: Int
      ) = this(
        dfId1,
        dfId2,
        Map.empty
      )
    
      def _1: Int = dfId1
      def _2: Int = dfId2
    
      def toTuple: _root_.scala.Tuple2[Int, Int] = {
        (
          dfId1,
          dfId2
        )
      }
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        writeDfId1Field(dfId1, _oprot)
        writeDfId2Field(dfId2, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        dfId1: Int = this.dfId1,
        dfId2: Int = this.dfId2,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          dfId1,
          dfId2,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 2
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.dfId1
        case 1 => this.dfId2
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    }

    type SuccessType = modeldb.CommonAncestor
    
    object Result extends ValidatingThriftStructCodec3[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("getCommonAncestor_result")
      val SuccessField: TField = new TField("success", TType.STRUCT, 0)
      val SuccessFieldManifest: Manifest[modeldb.CommonAncestor] = implicitly[Manifest[modeldb.CommonAncestor]]
      val RnfExField: TField = new TField("rnfEx", TType.STRUCT, 1)
      val RnfExFieldManifest: Manifest[modeldb.ResourceNotFoundException] = implicitly[Manifest[modeldb.ResourceNotFoundException]]
      val SvExField: TField = new TField("svEx", TType.STRUCT, 2)
      val SvExFieldManifest: Manifest[modeldb.ServerLogicException] = implicitly[Manifest[modeldb.ServerLogicException]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          RnfExField,
          true,
          false,
          RnfExFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          SvExField,
          true,
          false,
          SvExFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf ++= validateField(item.rnfEx)
        buf ++= validateField(item.svEx)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                modeldb.CommonAncestor.withoutPassthroughFields(field)
              }
            },
          rnfEx =
            {
              val field = original.rnfEx
              field.map { field =>
                modeldb.ResourceNotFoundException.withoutPassthroughFields(field)
              }
            },
          svEx =
            {
              val field = original.svEx
              field.map { field =>
                modeldb.ServerLogicException.withoutPassthroughFields(field)
              }
            }
        )
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[modeldb.CommonAncestor] = _root_.scala.None
        var rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException] = _root_.scala.None
        var svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 1 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    rnfEx = _root_.scala.Some(readRnfExValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'rnfEx' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 2 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    svEx = _root_.scala.Some(readSvExValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'svEx' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          rnfEx,
          svEx,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[modeldb.CommonAncestor] = _root_.scala.None,
        rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ): Result =
        new Result(
          success,
          rnfEx,
          svEx
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Tuple3[Option[modeldb.CommonAncestor], Option[modeldb.ResourceNotFoundException], Option[modeldb.ServerLogicException]]] = _root_.scala.Some(_item.toTuple)
    
    
      @inline private[modeldb] def readSuccessValue(_iprot: TProtocol): modeldb.CommonAncestor = {
        modeldb.CommonAncestor.decode(_iprot)
      }
    
      @inline private def writeSuccessField(success_item: modeldb.CommonAncestor, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: modeldb.CommonAncestor, _oprot: TProtocol): Unit = {
        success_item.write(_oprot)
      }
    
      @inline private[modeldb] def readRnfExValue(_iprot: TProtocol): modeldb.ResourceNotFoundException = {
        modeldb.ResourceNotFoundException.decode(_iprot)
      }
    
      @inline private def writeRnfExField(rnfEx_item: modeldb.ResourceNotFoundException, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(RnfExField)
        writeRnfExValue(rnfEx_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeRnfExValue(rnfEx_item: modeldb.ResourceNotFoundException, _oprot: TProtocol): Unit = {
        rnfEx_item.write(_oprot)
      }
    
      @inline private[modeldb] def readSvExValue(_iprot: TProtocol): modeldb.ServerLogicException = {
        modeldb.ServerLogicException.decode(_iprot)
      }
    
      @inline private def writeSvExField(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SvExField)
        writeSvExValue(svEx_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSvExValue(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        svEx_item.write(_oprot)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[modeldb.CommonAncestor],
        val rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException],
        val svEx: _root_.scala.Option[modeldb.ServerLogicException],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[modeldb.CommonAncestor] with ThriftStruct
      with _root_.scala.Product3[Option[modeldb.CommonAncestor], Option[modeldb.ResourceNotFoundException], Option[modeldb.ServerLogicException]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
    
      def this(
        success: _root_.scala.Option[modeldb.CommonAncestor] = _root_.scala.None,
        rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ) = this(
        success,
        rnfEx,
        svEx,
        Map.empty
      )
    
      def _1: _root_.scala.Option[modeldb.CommonAncestor] = success
      def _2: _root_.scala.Option[modeldb.ResourceNotFoundException] = rnfEx
      def _3: _root_.scala.Option[modeldb.ServerLogicException] = svEx
    
      def toTuple: _root_.scala.Tuple3[Option[modeldb.CommonAncestor], Option[modeldb.ResourceNotFoundException], Option[modeldb.ServerLogicException]] = {
        (
          success,
          rnfEx,
          svEx
        )
      }
    
      def successField: Option[modeldb.CommonAncestor] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Seq(rnfEx, svEx)
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (rnfEx.isDefined) writeRnfExField(rnfEx.get, _oprot)
        if (svEx.isDefined) writeSvExField(svEx.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[modeldb.CommonAncestor] = this.success,
        rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException] = this.rnfEx,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = this.svEx,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          rnfEx,
          svEx,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 3
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case 1 => this.rnfEx
        case 2 => this.svEx
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Function1[Args,Future[modeldb.CommonAncestor]]
    type ReqRepFunctionType = Function1[_root_.com.twitter.scrooge.Request[Args],Future[_root_.com.twitter.scrooge.Response[modeldb.CommonAncestor]]]

    type ServiceIfaceServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ReqRepServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]]

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]] { request: _root_.com.twitter.scrooge.Request[Args] =>
        f(request)
      }

    private[this] val toResult = (res: SuccessType) => Result(Some(res))

    val name: String = "getCommonAncestor"
    val serviceName: String = "ModelDBService"
    val argsCodec = Args
    val responseCodec = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val getCommonAncestor$args = GetCommonAncestor.Args
  type getCommonAncestor$args = GetCommonAncestor.Args

  val getCommonAncestor$result = GetCommonAncestor.Result
  type getCommonAncestor$result = GetCommonAncestor.Result

  object GetCommonAncestorForModels extends ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("getCommonAncestorForModels_args")
      val ModelId1Field: TField = new TField("modelId1", TType.I32, 1)
      val ModelId1FieldManifest: Manifest[Int] = implicitly[Manifest[Int]]
      val ModelId2Field: TField = new TField("modelId2", TType.I32, 2)
      val ModelId2FieldManifest: Manifest[Int] = implicitly[Manifest[Int]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          ModelId1Field,
          false,
          false,
          ModelId1FieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          ModelId2Field,
          false,
          false,
          ModelId2FieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.modelId1)
        buf ++= validateField(item.modelId2)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          modelId1 =
            {
              val field = original.modelId1
              field
            },
          modelId2 =
            {
              val field = original.modelId2
              field
            }
        )
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var modelId1: Int = 0
        var modelId2: Int = 0
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.I32 =>
                    modelId1 = readModelId1Value(_iprot)
                  case _actualType =>
                    val _expectedType = TType.I32
                    throw new TProtocolException(
                      "Received wrong type for field 'modelId1' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 2 =>
                _field.`type` match {
                  case TType.I32 =>
                    modelId2 = readModelId2Value(_iprot)
                  case _actualType =>
                    val _expectedType = TType.I32
                    throw new TProtocolException(
                      "Received wrong type for field 'modelId2' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Args(
          modelId1,
          modelId2,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        modelId1: Int,
        modelId2: Int
      ): Args =
        new Args(
          modelId1,
          modelId2
        )
    
      def unapply(_item: Args): _root_.scala.Option[_root_.scala.Tuple2[Int, Int]] = _root_.scala.Some(_item.toTuple)
    
    
      @inline private[modeldb] def readModelId1Value(_iprot: TProtocol): Int = {
        _iprot.readI32()
      }
    
      @inline private def writeModelId1Field(modelId1_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(ModelId1Field)
        writeModelId1Value(modelId1_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeModelId1Value(modelId1_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeI32(modelId1_item)
      }
    
      @inline private[modeldb] def readModelId2Value(_iprot: TProtocol): Int = {
        _iprot.readI32()
      }
    
      @inline private def writeModelId2Field(modelId2_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(ModelId2Field)
        writeModelId2Value(modelId2_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeModelId2Value(modelId2_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeI32(modelId2_item)
      }
    
    
    }
    
    class Args(
        val modelId1: Int,
        val modelId2: Int,
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product2[Int, Int]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
    
      def this(
        modelId1: Int,
        modelId2: Int
      ) = this(
        modelId1,
        modelId2,
        Map.empty
      )
    
      def _1: Int = modelId1
      def _2: Int = modelId2
    
      def toTuple: _root_.scala.Tuple2[Int, Int] = {
        (
          modelId1,
          modelId2
        )
      }
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        writeModelId1Field(modelId1, _oprot)
        writeModelId2Field(modelId2, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        modelId1: Int = this.modelId1,
        modelId2: Int = this.modelId2,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          modelId1,
          modelId2,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 2
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.modelId1
        case 1 => this.modelId2
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    }

    type SuccessType = modeldb.CommonAncestor
    
    object Result extends ValidatingThriftStructCodec3[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("getCommonAncestorForModels_result")
      val SuccessField: TField = new TField("success", TType.STRUCT, 0)
      val SuccessFieldManifest: Manifest[modeldb.CommonAncestor] = implicitly[Manifest[modeldb.CommonAncestor]]
      val RnfExField: TField = new TField("rnfEx", TType.STRUCT, 1)
      val RnfExFieldManifest: Manifest[modeldb.ResourceNotFoundException] = implicitly[Manifest[modeldb.ResourceNotFoundException]]
      val SvExField: TField = new TField("svEx", TType.STRUCT, 2)
      val SvExFieldManifest: Manifest[modeldb.ServerLogicException] = implicitly[Manifest[modeldb.ServerLogicException]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          RnfExField,
          true,
          false,
          RnfExFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          SvExField,
          true,
          false,
          SvExFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf ++= validateField(item.rnfEx)
        buf ++= validateField(item.svEx)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                modeldb.CommonAncestor.withoutPassthroughFields(field)
              }
            },
          rnfEx =
            {
              val field = original.rnfEx
              field.map { field =>
                modeldb.ResourceNotFoundException.withoutPassthroughFields(field)
              }
            },
          svEx =
            {
              val field = original.svEx
              field.map { field =>
                modeldb.ServerLogicException.withoutPassthroughFields(field)
              }
            }
        )
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[modeldb.CommonAncestor] = _root_.scala.None
        var rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException] = _root_.scala.None
        var svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 1 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    rnfEx = _root_.scala.Some(readRnfExValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'rnfEx' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 2 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    svEx = _root_.scala.Some(readSvExValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'svEx' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          rnfEx,
          svEx,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[modeldb.CommonAncestor] = _root_.scala.None,
        rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ): Result =
        new Result(
          success,
          rnfEx,
          svEx
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Tuple3[Option[modeldb.CommonAncestor], Option[modeldb.ResourceNotFoundException], Option[modeldb.ServerLogicException]]] = _root_.scala.Some(_item.toTuple)
    
    
      @inline private[modeldb] def readSuccessValue(_iprot: TProtocol): modeldb.CommonAncestor = {
        modeldb.CommonAncestor.decode(_iprot)
      }
    
      @inline private def writeSuccessField(success_item: modeldb.CommonAncestor, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: modeldb.CommonAncestor, _oprot: TProtocol): Unit = {
        success_item.write(_oprot)
      }
    
      @inline private[modeldb] def readRnfExValue(_iprot: TProtocol): modeldb.ResourceNotFoundException = {
        modeldb.ResourceNotFoundException.decode(_iprot)
      }
    
      @inline private def writeRnfExField(rnfEx_item: modeldb.ResourceNotFoundException, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(RnfExField)
        writeRnfExValue(rnfEx_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeRnfExValue(rnfEx_item: modeldb.ResourceNotFoundException, _oprot: TProtocol): Unit = {
        rnfEx_item.write(_oprot)
      }
    
      @inline private[modeldb] def readSvExValue(_iprot: TProtocol): modeldb.ServerLogicException = {
        modeldb.ServerLogicException.decode(_iprot)
      }
    
      @inline private def writeSvExField(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SvExField)
        writeSvExValue(svEx_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSvExValue(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        svEx_item.write(_oprot)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[modeldb.CommonAncestor],
        val rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException],
        val svEx: _root_.scala.Option[modeldb.ServerLogicException],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[modeldb.CommonAncestor] with ThriftStruct
      with _root_.scala.Product3[Option[modeldb.CommonAncestor], Option[modeldb.ResourceNotFoundException], Option[modeldb.ServerLogicException]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
    
      def this(
        success: _root_.scala.Option[modeldb.CommonAncestor] = _root_.scala.None,
        rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ) = this(
        success,
        rnfEx,
        svEx,
        Map.empty
      )
    
      def _1: _root_.scala.Option[modeldb.CommonAncestor] = success
      def _2: _root_.scala.Option[modeldb.ResourceNotFoundException] = rnfEx
      def _3: _root_.scala.Option[modeldb.ServerLogicException] = svEx
    
      def toTuple: _root_.scala.Tuple3[Option[modeldb.CommonAncestor], Option[modeldb.ResourceNotFoundException], Option[modeldb.ServerLogicException]] = {
        (
          success,
          rnfEx,
          svEx
        )
      }
    
      def successField: Option[modeldb.CommonAncestor] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Seq(rnfEx, svEx)
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (rnfEx.isDefined) writeRnfExField(rnfEx.get, _oprot)
        if (svEx.isDefined) writeSvExField(svEx.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[modeldb.CommonAncestor] = this.success,
        rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException] = this.rnfEx,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = this.svEx,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          rnfEx,
          svEx,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 3
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case 1 => this.rnfEx
        case 2 => this.svEx
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Function1[Args,Future[modeldb.CommonAncestor]]
    type ReqRepFunctionType = Function1[_root_.com.twitter.scrooge.Request[Args],Future[_root_.com.twitter.scrooge.Response[modeldb.CommonAncestor]]]

    type ServiceIfaceServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ReqRepServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]]

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]] { request: _root_.com.twitter.scrooge.Request[Args] =>
        f(request)
      }

    private[this] val toResult = (res: SuccessType) => Result(Some(res))

    val name: String = "getCommonAncestorForModels"
    val serviceName: String = "ModelDBService"
    val argsCodec = Args
    val responseCodec = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val getCommonAncestorForModels$args = GetCommonAncestorForModels.Args
  type getCommonAncestorForModels$args = GetCommonAncestorForModels.Args

  val getCommonAncestorForModels$result = GetCommonAncestorForModels.Result
  type getCommonAncestorForModels$result = GetCommonAncestorForModels.Result

  object GetTrainingRowsCount extends ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("getTrainingRowsCount_args")
      val ModelIdField: TField = new TField("modelId", TType.I32, 1)
      val ModelIdFieldManifest: Manifest[Int] = implicitly[Manifest[Int]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          ModelIdField,
          false,
          false,
          ModelIdFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.modelId)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          modelId =
            {
              val field = original.modelId
              field
            }
        )
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var modelId: Int = 0
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.I32 =>
                    modelId = readModelIdValue(_iprot)
                  case _actualType =>
                    val _expectedType = TType.I32
                    throw new TProtocolException(
                      "Received wrong type for field 'modelId' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Args(
          modelId,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        modelId: Int
      ): Args =
        new Args(
          modelId
        )
    
      def unapply(_item: Args): _root_.scala.Option[Int] = _root_.scala.Some(_item.modelId)
    
    
      @inline private[modeldb] def readModelIdValue(_iprot: TProtocol): Int = {
        _iprot.readI32()
      }
    
      @inline private def writeModelIdField(modelId_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(ModelIdField)
        writeModelIdValue(modelId_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeModelIdValue(modelId_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeI32(modelId_item)
      }
    
    
    }
    
    class Args(
        val modelId: Int,
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product1[Int]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
    
      def this(
        modelId: Int
      ) = this(
        modelId,
        Map.empty
      )
    
      def _1: Int = modelId
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        writeModelIdField(modelId, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        modelId: Int = this.modelId,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          modelId,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.modelId
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    }

    type SuccessType = Int
    
    object Result extends ValidatingThriftStructCodec3[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("getTrainingRowsCount_result")
      val SuccessField: TField = new TField("success", TType.I32, 0)
      val SuccessFieldManifest: Manifest[Int] = implicitly[Manifest[Int]]
      val RnfExField: TField = new TField("rnfEx", TType.STRUCT, 1)
      val RnfExFieldManifest: Manifest[modeldb.ResourceNotFoundException] = implicitly[Manifest[modeldb.ResourceNotFoundException]]
      val SvExField: TField = new TField("svEx", TType.STRUCT, 2)
      val SvExFieldManifest: Manifest[modeldb.ServerLogicException] = implicitly[Manifest[modeldb.ServerLogicException]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          RnfExField,
          true,
          false,
          RnfExFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          SvExField,
          true,
          false,
          SvExFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf ++= validateField(item.rnfEx)
        buf ++= validateField(item.svEx)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                field
              }
            },
          rnfEx =
            {
              val field = original.rnfEx
              field.map { field =>
                modeldb.ResourceNotFoundException.withoutPassthroughFields(field)
              }
            },
          svEx =
            {
              val field = original.svEx
              field.map { field =>
                modeldb.ServerLogicException.withoutPassthroughFields(field)
              }
            }
        )
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[Int] = _root_.scala.None
        var rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException] = _root_.scala.None
        var svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.I32 =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.I32
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 1 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    rnfEx = _root_.scala.Some(readRnfExValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'rnfEx' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 2 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    svEx = _root_.scala.Some(readSvExValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'svEx' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          rnfEx,
          svEx,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[Int] = _root_.scala.None,
        rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ): Result =
        new Result(
          success,
          rnfEx,
          svEx
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Tuple3[Option[Int], Option[modeldb.ResourceNotFoundException], Option[modeldb.ServerLogicException]]] = _root_.scala.Some(_item.toTuple)
    
    
      @inline private[modeldb] def readSuccessValue(_iprot: TProtocol): Int = {
        _iprot.readI32()
      }
    
      @inline private def writeSuccessField(success_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeI32(success_item)
      }
    
      @inline private[modeldb] def readRnfExValue(_iprot: TProtocol): modeldb.ResourceNotFoundException = {
        modeldb.ResourceNotFoundException.decode(_iprot)
      }
    
      @inline private def writeRnfExField(rnfEx_item: modeldb.ResourceNotFoundException, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(RnfExField)
        writeRnfExValue(rnfEx_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeRnfExValue(rnfEx_item: modeldb.ResourceNotFoundException, _oprot: TProtocol): Unit = {
        rnfEx_item.write(_oprot)
      }
    
      @inline private[modeldb] def readSvExValue(_iprot: TProtocol): modeldb.ServerLogicException = {
        modeldb.ServerLogicException.decode(_iprot)
      }
    
      @inline private def writeSvExField(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SvExField)
        writeSvExValue(svEx_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSvExValue(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        svEx_item.write(_oprot)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[Int],
        val rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException],
        val svEx: _root_.scala.Option[modeldb.ServerLogicException],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[Int] with ThriftStruct
      with _root_.scala.Product3[Option[Int], Option[modeldb.ResourceNotFoundException], Option[modeldb.ServerLogicException]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
    
      def this(
        success: _root_.scala.Option[Int] = _root_.scala.None,
        rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ) = this(
        success,
        rnfEx,
        svEx,
        Map.empty
      )
    
      def _1: _root_.scala.Option[Int] = success
      def _2: _root_.scala.Option[modeldb.ResourceNotFoundException] = rnfEx
      def _3: _root_.scala.Option[modeldb.ServerLogicException] = svEx
    
      def toTuple: _root_.scala.Tuple3[Option[Int], Option[modeldb.ResourceNotFoundException], Option[modeldb.ServerLogicException]] = {
        (
          success,
          rnfEx,
          svEx
        )
      }
    
      def successField: Option[Int] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Seq(rnfEx, svEx)
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (rnfEx.isDefined) writeRnfExField(rnfEx.get, _oprot)
        if (svEx.isDefined) writeSvExField(svEx.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[Int] = this.success,
        rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException] = this.rnfEx,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = this.svEx,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          rnfEx,
          svEx,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 3
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case 1 => this.rnfEx
        case 2 => this.svEx
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Function1[Args,Future[Int]]
    type ReqRepFunctionType = Function1[_root_.com.twitter.scrooge.Request[Args],Future[_root_.com.twitter.scrooge.Response[Int]]]

    type ServiceIfaceServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ReqRepServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]]

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]] { request: _root_.com.twitter.scrooge.Request[Args] =>
        f(request)
      }

    private[this] val toResult = (res: SuccessType) => Result(Some(res))

    val name: String = "getTrainingRowsCount"
    val serviceName: String = "ModelDBService"
    val argsCodec = Args
    val responseCodec = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val getTrainingRowsCount$args = GetTrainingRowsCount.Args
  type getTrainingRowsCount$args = GetTrainingRowsCount.Args

  val getTrainingRowsCount$result = GetTrainingRowsCount.Result
  type getTrainingRowsCount$result = GetTrainingRowsCount.Result

  object GetTrainingRowsCounts extends ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("getTrainingRowsCounts_args")
      val ModelIdsField: TField = new TField("modelIds", TType.LIST, 1)
      val ModelIdsFieldManifest: Manifest[Seq[Int]] = implicitly[Manifest[Seq[Int]]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          ModelIdsField,
          false,
          false,
          ModelIdsFieldManifest,
          _root_.scala.None,
          _root_.scala.Some(implicitly[Manifest[Int]]),
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.modelIds)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          modelIds =
            {
              val field = original.modelIds
              field.map { field =>
                field
              }
            }
        )
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var modelIds: Seq[Int] = Seq[Int]()
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.LIST =>
                    modelIds = readModelIdsValue(_iprot)
                  case _actualType =>
                    val _expectedType = TType.LIST
                    throw new TProtocolException(
                      "Received wrong type for field 'modelIds' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Args(
          modelIds,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        modelIds: Seq[Int] = Seq[Int]()
      ): Args =
        new Args(
          modelIds
        )
    
      def unapply(_item: Args): _root_.scala.Option[Seq[Int]] = _root_.scala.Some(_item.modelIds)
    
    
      @inline private[modeldb] def readModelIdsValue(_iprot: TProtocol): Seq[Int] = {
        val _list = _iprot.readListBegin()
        if (_list.size == 0) {
          _iprot.readListEnd()
          Nil
        } else {
          val _rv = new mutable$ArrayBuffer[Int](_list.size)
          var _i = 0
          while (_i < _list.size) {
            _rv += {
              _iprot.readI32()
            }
            _i += 1
          }
          _iprot.readListEnd()
          _rv
        }
      }
    
      @inline private def writeModelIdsField(modelIds_item: Seq[Int], _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(ModelIdsField)
        writeModelIdsValue(modelIds_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeModelIdsValue(modelIds_item: Seq[Int], _oprot: TProtocol): Unit = {
        _oprot.writeListBegin(new TList(TType.I32, modelIds_item.size))
        modelIds_item match {
          case _: IndexedSeq[_] =>
            var _i = 0
            val _size = modelIds_item.size
            while (_i < _size) {
              val modelIds_item_element = modelIds_item(_i)
              _oprot.writeI32(modelIds_item_element)
              _i += 1
            }
          case _ =>
            modelIds_item.foreach { modelIds_item_element =>
              _oprot.writeI32(modelIds_item_element)
            }
        }
        _oprot.writeListEnd()
      }
    
    
    }
    
    class Args(
        val modelIds: Seq[Int],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product1[Seq[Int]]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
    
      def this(
        modelIds: Seq[Int] = Seq[Int]()
      ) = this(
        modelIds,
        Map.empty
      )
    
      def _1: Seq[Int] = modelIds
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        if (modelIds ne null) writeModelIdsField(modelIds, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        modelIds: Seq[Int] = this.modelIds,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          modelIds,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.modelIds
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    }

    type SuccessType = Seq[Int]
    
    object Result extends ValidatingThriftStructCodec3[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("getTrainingRowsCounts_result")
      val SuccessField: TField = new TField("success", TType.LIST, 0)
      val SuccessFieldManifest: Manifest[Seq[Int]] = implicitly[Manifest[Seq[Int]]]
      val SvExField: TField = new TField("svEx", TType.STRUCT, 1)
      val SvExFieldManifest: Manifest[modeldb.ServerLogicException] = implicitly[Manifest[modeldb.ServerLogicException]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.Some(implicitly[Manifest[Int]]),
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          SvExField,
          true,
          false,
          SvExFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf ++= validateField(item.svEx)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                field.map { field =>
                  field
                }
              }
            },
          svEx =
            {
              val field = original.svEx
              field.map { field =>
                modeldb.ServerLogicException.withoutPassthroughFields(field)
              }
            }
        )
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[Seq[Int]] = _root_.scala.None
        var svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.LIST =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.LIST
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 1 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    svEx = _root_.scala.Some(readSvExValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'svEx' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          svEx,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[Seq[Int]] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ): Result =
        new Result(
          success,
          svEx
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Tuple2[Option[Seq[Int]], Option[modeldb.ServerLogicException]]] = _root_.scala.Some(_item.toTuple)
    
    
      @inline private[modeldb] def readSuccessValue(_iprot: TProtocol): Seq[Int] = {
        val _list = _iprot.readListBegin()
        if (_list.size == 0) {
          _iprot.readListEnd()
          Nil
        } else {
          val _rv = new mutable$ArrayBuffer[Int](_list.size)
          var _i = 0
          while (_i < _list.size) {
            _rv += {
              _iprot.readI32()
            }
            _i += 1
          }
          _iprot.readListEnd()
          _rv
        }
      }
    
      @inline private def writeSuccessField(success_item: Seq[Int], _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: Seq[Int], _oprot: TProtocol): Unit = {
        _oprot.writeListBegin(new TList(TType.I32, success_item.size))
        success_item match {
          case _: IndexedSeq[_] =>
            var _i = 0
            val _size = success_item.size
            while (_i < _size) {
              val success_item_element = success_item(_i)
              _oprot.writeI32(success_item_element)
              _i += 1
            }
          case _ =>
            success_item.foreach { success_item_element =>
              _oprot.writeI32(success_item_element)
            }
        }
        _oprot.writeListEnd()
      }
    
      @inline private[modeldb] def readSvExValue(_iprot: TProtocol): modeldb.ServerLogicException = {
        modeldb.ServerLogicException.decode(_iprot)
      }
    
      @inline private def writeSvExField(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SvExField)
        writeSvExValue(svEx_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSvExValue(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        svEx_item.write(_oprot)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[Seq[Int]],
        val svEx: _root_.scala.Option[modeldb.ServerLogicException],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[Seq[Int]] with ThriftStruct
      with _root_.scala.Product2[Option[Seq[Int]], Option[modeldb.ServerLogicException]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
    
      def this(
        success: _root_.scala.Option[Seq[Int]] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ) = this(
        success,
        svEx,
        Map.empty
      )
    
      def _1: _root_.scala.Option[Seq[Int]] = success
      def _2: _root_.scala.Option[modeldb.ServerLogicException] = svEx
    
      def toTuple: _root_.scala.Tuple2[Option[Seq[Int]], Option[modeldb.ServerLogicException]] = {
        (
          success,
          svEx
        )
      }
    
      def successField: Option[Seq[Int]] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Seq(svEx)
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (svEx.isDefined) writeSvExField(svEx.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[Seq[Int]] = this.success,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = this.svEx,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          svEx,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 2
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case 1 => this.svEx
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Function1[Args,Future[Seq[Int]]]
    type ReqRepFunctionType = Function1[_root_.com.twitter.scrooge.Request[Args],Future[_root_.com.twitter.scrooge.Response[Seq[Int]]]]

    type ServiceIfaceServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ReqRepServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]]

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]] { request: _root_.com.twitter.scrooge.Request[Args] =>
        f(request)
      }

    private[this] val toResult = (res: SuccessType) => Result(Some(res))

    val name: String = "getTrainingRowsCounts"
    val serviceName: String = "ModelDBService"
    val argsCodec = Args
    val responseCodec = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val getTrainingRowsCounts$args = GetTrainingRowsCounts.Args
  type getTrainingRowsCounts$args = GetTrainingRowsCounts.Args

  val getTrainingRowsCounts$result = GetTrainingRowsCounts.Result
  type getTrainingRowsCounts$result = GetTrainingRowsCounts.Result

  object CompareHyperparameters extends ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("compareHyperparameters_args")
      val ModelId1Field: TField = new TField("modelId1", TType.I32, 1)
      val ModelId1FieldManifest: Manifest[Int] = implicitly[Manifest[Int]]
      val ModelId2Field: TField = new TField("modelId2", TType.I32, 2)
      val ModelId2FieldManifest: Manifest[Int] = implicitly[Manifest[Int]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          ModelId1Field,
          false,
          false,
          ModelId1FieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          ModelId2Field,
          false,
          false,
          ModelId2FieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.modelId1)
        buf ++= validateField(item.modelId2)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          modelId1 =
            {
              val field = original.modelId1
              field
            },
          modelId2 =
            {
              val field = original.modelId2
              field
            }
        )
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var modelId1: Int = 0
        var modelId2: Int = 0
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.I32 =>
                    modelId1 = readModelId1Value(_iprot)
                  case _actualType =>
                    val _expectedType = TType.I32
                    throw new TProtocolException(
                      "Received wrong type for field 'modelId1' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 2 =>
                _field.`type` match {
                  case TType.I32 =>
                    modelId2 = readModelId2Value(_iprot)
                  case _actualType =>
                    val _expectedType = TType.I32
                    throw new TProtocolException(
                      "Received wrong type for field 'modelId2' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Args(
          modelId1,
          modelId2,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        modelId1: Int,
        modelId2: Int
      ): Args =
        new Args(
          modelId1,
          modelId2
        )
    
      def unapply(_item: Args): _root_.scala.Option[_root_.scala.Tuple2[Int, Int]] = _root_.scala.Some(_item.toTuple)
    
    
      @inline private[modeldb] def readModelId1Value(_iprot: TProtocol): Int = {
        _iprot.readI32()
      }
    
      @inline private def writeModelId1Field(modelId1_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(ModelId1Field)
        writeModelId1Value(modelId1_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeModelId1Value(modelId1_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeI32(modelId1_item)
      }
    
      @inline private[modeldb] def readModelId2Value(_iprot: TProtocol): Int = {
        _iprot.readI32()
      }
    
      @inline private def writeModelId2Field(modelId2_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(ModelId2Field)
        writeModelId2Value(modelId2_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeModelId2Value(modelId2_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeI32(modelId2_item)
      }
    
    
    }
    
    class Args(
        val modelId1: Int,
        val modelId2: Int,
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product2[Int, Int]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
    
      def this(
        modelId1: Int,
        modelId2: Int
      ) = this(
        modelId1,
        modelId2,
        Map.empty
      )
    
      def _1: Int = modelId1
      def _2: Int = modelId2
    
      def toTuple: _root_.scala.Tuple2[Int, Int] = {
        (
          modelId1,
          modelId2
        )
      }
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        writeModelId1Field(modelId1, _oprot)
        writeModelId2Field(modelId2, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        modelId1: Int = this.modelId1,
        modelId2: Int = this.modelId2,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          modelId1,
          modelId2,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 2
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.modelId1
        case 1 => this.modelId2
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    }

    type SuccessType = modeldb.CompareHyperParametersResponse
    
    object Result extends ValidatingThriftStructCodec3[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("compareHyperparameters_result")
      val SuccessField: TField = new TField("success", TType.STRUCT, 0)
      val SuccessFieldManifest: Manifest[modeldb.CompareHyperParametersResponse] = implicitly[Manifest[modeldb.CompareHyperParametersResponse]]
      val RnfExField: TField = new TField("rnfEx", TType.STRUCT, 1)
      val RnfExFieldManifest: Manifest[modeldb.ResourceNotFoundException] = implicitly[Manifest[modeldb.ResourceNotFoundException]]
      val SvExField: TField = new TField("svEx", TType.STRUCT, 2)
      val SvExFieldManifest: Manifest[modeldb.ServerLogicException] = implicitly[Manifest[modeldb.ServerLogicException]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          RnfExField,
          true,
          false,
          RnfExFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          SvExField,
          true,
          false,
          SvExFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf ++= validateField(item.rnfEx)
        buf ++= validateField(item.svEx)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                modeldb.CompareHyperParametersResponse.withoutPassthroughFields(field)
              }
            },
          rnfEx =
            {
              val field = original.rnfEx
              field.map { field =>
                modeldb.ResourceNotFoundException.withoutPassthroughFields(field)
              }
            },
          svEx =
            {
              val field = original.svEx
              field.map { field =>
                modeldb.ServerLogicException.withoutPassthroughFields(field)
              }
            }
        )
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[modeldb.CompareHyperParametersResponse] = _root_.scala.None
        var rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException] = _root_.scala.None
        var svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 1 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    rnfEx = _root_.scala.Some(readRnfExValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'rnfEx' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 2 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    svEx = _root_.scala.Some(readSvExValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'svEx' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          rnfEx,
          svEx,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[modeldb.CompareHyperParametersResponse] = _root_.scala.None,
        rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ): Result =
        new Result(
          success,
          rnfEx,
          svEx
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Tuple3[Option[modeldb.CompareHyperParametersResponse], Option[modeldb.ResourceNotFoundException], Option[modeldb.ServerLogicException]]] = _root_.scala.Some(_item.toTuple)
    
    
      @inline private[modeldb] def readSuccessValue(_iprot: TProtocol): modeldb.CompareHyperParametersResponse = {
        modeldb.CompareHyperParametersResponse.decode(_iprot)
      }
    
      @inline private def writeSuccessField(success_item: modeldb.CompareHyperParametersResponse, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: modeldb.CompareHyperParametersResponse, _oprot: TProtocol): Unit = {
        success_item.write(_oprot)
      }
    
      @inline private[modeldb] def readRnfExValue(_iprot: TProtocol): modeldb.ResourceNotFoundException = {
        modeldb.ResourceNotFoundException.decode(_iprot)
      }
    
      @inline private def writeRnfExField(rnfEx_item: modeldb.ResourceNotFoundException, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(RnfExField)
        writeRnfExValue(rnfEx_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeRnfExValue(rnfEx_item: modeldb.ResourceNotFoundException, _oprot: TProtocol): Unit = {
        rnfEx_item.write(_oprot)
      }
    
      @inline private[modeldb] def readSvExValue(_iprot: TProtocol): modeldb.ServerLogicException = {
        modeldb.ServerLogicException.decode(_iprot)
      }
    
      @inline private def writeSvExField(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SvExField)
        writeSvExValue(svEx_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSvExValue(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        svEx_item.write(_oprot)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[modeldb.CompareHyperParametersResponse],
        val rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException],
        val svEx: _root_.scala.Option[modeldb.ServerLogicException],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[modeldb.CompareHyperParametersResponse] with ThriftStruct
      with _root_.scala.Product3[Option[modeldb.CompareHyperParametersResponse], Option[modeldb.ResourceNotFoundException], Option[modeldb.ServerLogicException]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
    
      def this(
        success: _root_.scala.Option[modeldb.CompareHyperParametersResponse] = _root_.scala.None,
        rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ) = this(
        success,
        rnfEx,
        svEx,
        Map.empty
      )
    
      def _1: _root_.scala.Option[modeldb.CompareHyperParametersResponse] = success
      def _2: _root_.scala.Option[modeldb.ResourceNotFoundException] = rnfEx
      def _3: _root_.scala.Option[modeldb.ServerLogicException] = svEx
    
      def toTuple: _root_.scala.Tuple3[Option[modeldb.CompareHyperParametersResponse], Option[modeldb.ResourceNotFoundException], Option[modeldb.ServerLogicException]] = {
        (
          success,
          rnfEx,
          svEx
        )
      }
    
      def successField: Option[modeldb.CompareHyperParametersResponse] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Seq(rnfEx, svEx)
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (rnfEx.isDefined) writeRnfExField(rnfEx.get, _oprot)
        if (svEx.isDefined) writeSvExField(svEx.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[modeldb.CompareHyperParametersResponse] = this.success,
        rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException] = this.rnfEx,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = this.svEx,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          rnfEx,
          svEx,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 3
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case 1 => this.rnfEx
        case 2 => this.svEx
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Function1[Args,Future[modeldb.CompareHyperParametersResponse]]
    type ReqRepFunctionType = Function1[_root_.com.twitter.scrooge.Request[Args],Future[_root_.com.twitter.scrooge.Response[modeldb.CompareHyperParametersResponse]]]

    type ServiceIfaceServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ReqRepServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]]

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]] { request: _root_.com.twitter.scrooge.Request[Args] =>
        f(request)
      }

    private[this] val toResult = (res: SuccessType) => Result(Some(res))

    val name: String = "compareHyperparameters"
    val serviceName: String = "ModelDBService"
    val argsCodec = Args
    val responseCodec = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val compareHyperparameters$args = CompareHyperparameters.Args
  type compareHyperparameters$args = CompareHyperparameters.Args

  val compareHyperparameters$result = CompareHyperparameters.Result
  type compareHyperparameters$result = CompareHyperparameters.Result

  object CompareFeatures extends ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("compareFeatures_args")
      val ModelId1Field: TField = new TField("modelId1", TType.I32, 1)
      val ModelId1FieldManifest: Manifest[Int] = implicitly[Manifest[Int]]
      val ModelId2Field: TField = new TField("modelId2", TType.I32, 2)
      val ModelId2FieldManifest: Manifest[Int] = implicitly[Manifest[Int]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          ModelId1Field,
          false,
          false,
          ModelId1FieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          ModelId2Field,
          false,
          false,
          ModelId2FieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.modelId1)
        buf ++= validateField(item.modelId2)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          modelId1 =
            {
              val field = original.modelId1
              field
            },
          modelId2 =
            {
              val field = original.modelId2
              field
            }
        )
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var modelId1: Int = 0
        var modelId2: Int = 0
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.I32 =>
                    modelId1 = readModelId1Value(_iprot)
                  case _actualType =>
                    val _expectedType = TType.I32
                    throw new TProtocolException(
                      "Received wrong type for field 'modelId1' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 2 =>
                _field.`type` match {
                  case TType.I32 =>
                    modelId2 = readModelId2Value(_iprot)
                  case _actualType =>
                    val _expectedType = TType.I32
                    throw new TProtocolException(
                      "Received wrong type for field 'modelId2' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Args(
          modelId1,
          modelId2,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        modelId1: Int,
        modelId2: Int
      ): Args =
        new Args(
          modelId1,
          modelId2
        )
    
      def unapply(_item: Args): _root_.scala.Option[_root_.scala.Tuple2[Int, Int]] = _root_.scala.Some(_item.toTuple)
    
    
      @inline private[modeldb] def readModelId1Value(_iprot: TProtocol): Int = {
        _iprot.readI32()
      }
    
      @inline private def writeModelId1Field(modelId1_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(ModelId1Field)
        writeModelId1Value(modelId1_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeModelId1Value(modelId1_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeI32(modelId1_item)
      }
    
      @inline private[modeldb] def readModelId2Value(_iprot: TProtocol): Int = {
        _iprot.readI32()
      }
    
      @inline private def writeModelId2Field(modelId2_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(ModelId2Field)
        writeModelId2Value(modelId2_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeModelId2Value(modelId2_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeI32(modelId2_item)
      }
    
    
    }
    
    class Args(
        val modelId1: Int,
        val modelId2: Int,
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product2[Int, Int]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
    
      def this(
        modelId1: Int,
        modelId2: Int
      ) = this(
        modelId1,
        modelId2,
        Map.empty
      )
    
      def _1: Int = modelId1
      def _2: Int = modelId2
    
      def toTuple: _root_.scala.Tuple2[Int, Int] = {
        (
          modelId1,
          modelId2
        )
      }
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        writeModelId1Field(modelId1, _oprot)
        writeModelId2Field(modelId2, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        modelId1: Int = this.modelId1,
        modelId2: Int = this.modelId2,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          modelId1,
          modelId2,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 2
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.modelId1
        case 1 => this.modelId2
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    }

    type SuccessType = modeldb.CompareFeaturesResponse
    
    object Result extends ValidatingThriftStructCodec3[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("compareFeatures_result")
      val SuccessField: TField = new TField("success", TType.STRUCT, 0)
      val SuccessFieldManifest: Manifest[modeldb.CompareFeaturesResponse] = implicitly[Manifest[modeldb.CompareFeaturesResponse]]
      val RnfExField: TField = new TField("rnfEx", TType.STRUCT, 1)
      val RnfExFieldManifest: Manifest[modeldb.ResourceNotFoundException] = implicitly[Manifest[modeldb.ResourceNotFoundException]]
      val SvExField: TField = new TField("svEx", TType.STRUCT, 2)
      val SvExFieldManifest: Manifest[modeldb.ServerLogicException] = implicitly[Manifest[modeldb.ServerLogicException]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          RnfExField,
          true,
          false,
          RnfExFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          SvExField,
          true,
          false,
          SvExFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf ++= validateField(item.rnfEx)
        buf ++= validateField(item.svEx)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                modeldb.CompareFeaturesResponse.withoutPassthroughFields(field)
              }
            },
          rnfEx =
            {
              val field = original.rnfEx
              field.map { field =>
                modeldb.ResourceNotFoundException.withoutPassthroughFields(field)
              }
            },
          svEx =
            {
              val field = original.svEx
              field.map { field =>
                modeldb.ServerLogicException.withoutPassthroughFields(field)
              }
            }
        )
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[modeldb.CompareFeaturesResponse] = _root_.scala.None
        var rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException] = _root_.scala.None
        var svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 1 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    rnfEx = _root_.scala.Some(readRnfExValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'rnfEx' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 2 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    svEx = _root_.scala.Some(readSvExValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'svEx' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          rnfEx,
          svEx,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[modeldb.CompareFeaturesResponse] = _root_.scala.None,
        rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ): Result =
        new Result(
          success,
          rnfEx,
          svEx
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Tuple3[Option[modeldb.CompareFeaturesResponse], Option[modeldb.ResourceNotFoundException], Option[modeldb.ServerLogicException]]] = _root_.scala.Some(_item.toTuple)
    
    
      @inline private[modeldb] def readSuccessValue(_iprot: TProtocol): modeldb.CompareFeaturesResponse = {
        modeldb.CompareFeaturesResponse.decode(_iprot)
      }
    
      @inline private def writeSuccessField(success_item: modeldb.CompareFeaturesResponse, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: modeldb.CompareFeaturesResponse, _oprot: TProtocol): Unit = {
        success_item.write(_oprot)
      }
    
      @inline private[modeldb] def readRnfExValue(_iprot: TProtocol): modeldb.ResourceNotFoundException = {
        modeldb.ResourceNotFoundException.decode(_iprot)
      }
    
      @inline private def writeRnfExField(rnfEx_item: modeldb.ResourceNotFoundException, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(RnfExField)
        writeRnfExValue(rnfEx_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeRnfExValue(rnfEx_item: modeldb.ResourceNotFoundException, _oprot: TProtocol): Unit = {
        rnfEx_item.write(_oprot)
      }
    
      @inline private[modeldb] def readSvExValue(_iprot: TProtocol): modeldb.ServerLogicException = {
        modeldb.ServerLogicException.decode(_iprot)
      }
    
      @inline private def writeSvExField(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SvExField)
        writeSvExValue(svEx_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSvExValue(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        svEx_item.write(_oprot)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[modeldb.CompareFeaturesResponse],
        val rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException],
        val svEx: _root_.scala.Option[modeldb.ServerLogicException],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[modeldb.CompareFeaturesResponse] with ThriftStruct
      with _root_.scala.Product3[Option[modeldb.CompareFeaturesResponse], Option[modeldb.ResourceNotFoundException], Option[modeldb.ServerLogicException]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
    
      def this(
        success: _root_.scala.Option[modeldb.CompareFeaturesResponse] = _root_.scala.None,
        rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ) = this(
        success,
        rnfEx,
        svEx,
        Map.empty
      )
    
      def _1: _root_.scala.Option[modeldb.CompareFeaturesResponse] = success
      def _2: _root_.scala.Option[modeldb.ResourceNotFoundException] = rnfEx
      def _3: _root_.scala.Option[modeldb.ServerLogicException] = svEx
    
      def toTuple: _root_.scala.Tuple3[Option[modeldb.CompareFeaturesResponse], Option[modeldb.ResourceNotFoundException], Option[modeldb.ServerLogicException]] = {
        (
          success,
          rnfEx,
          svEx
        )
      }
    
      def successField: Option[modeldb.CompareFeaturesResponse] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Seq(rnfEx, svEx)
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (rnfEx.isDefined) writeRnfExField(rnfEx.get, _oprot)
        if (svEx.isDefined) writeSvExField(svEx.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[modeldb.CompareFeaturesResponse] = this.success,
        rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException] = this.rnfEx,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = this.svEx,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          rnfEx,
          svEx,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 3
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case 1 => this.rnfEx
        case 2 => this.svEx
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Function1[Args,Future[modeldb.CompareFeaturesResponse]]
    type ReqRepFunctionType = Function1[_root_.com.twitter.scrooge.Request[Args],Future[_root_.com.twitter.scrooge.Response[modeldb.CompareFeaturesResponse]]]

    type ServiceIfaceServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ReqRepServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]]

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]] { request: _root_.com.twitter.scrooge.Request[Args] =>
        f(request)
      }

    private[this] val toResult = (res: SuccessType) => Result(Some(res))

    val name: String = "compareFeatures"
    val serviceName: String = "ModelDBService"
    val argsCodec = Args
    val responseCodec = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val compareFeatures$args = CompareFeatures.Args
  type compareFeatures$args = CompareFeatures.Args

  val compareFeatures$result = CompareFeatures.Result
  type compareFeatures$result = CompareFeatures.Result

  object GroupByProblemType extends ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("groupByProblemType_args")
      val ModelIdsField: TField = new TField("modelIds", TType.LIST, 1)
      val ModelIdsFieldManifest: Manifest[Seq[Int]] = implicitly[Manifest[Seq[Int]]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          ModelIdsField,
          false,
          false,
          ModelIdsFieldManifest,
          _root_.scala.None,
          _root_.scala.Some(implicitly[Manifest[Int]]),
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.modelIds)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          modelIds =
            {
              val field = original.modelIds
              field.map { field =>
                field
              }
            }
        )
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var modelIds: Seq[Int] = Seq[Int]()
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.LIST =>
                    modelIds = readModelIdsValue(_iprot)
                  case _actualType =>
                    val _expectedType = TType.LIST
                    throw new TProtocolException(
                      "Received wrong type for field 'modelIds' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Args(
          modelIds,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        modelIds: Seq[Int] = Seq[Int]()
      ): Args =
        new Args(
          modelIds
        )
    
      def unapply(_item: Args): _root_.scala.Option[Seq[Int]] = _root_.scala.Some(_item.modelIds)
    
    
      @inline private[modeldb] def readModelIdsValue(_iprot: TProtocol): Seq[Int] = {
        val _list = _iprot.readListBegin()
        if (_list.size == 0) {
          _iprot.readListEnd()
          Nil
        } else {
          val _rv = new mutable$ArrayBuffer[Int](_list.size)
          var _i = 0
          while (_i < _list.size) {
            _rv += {
              _iprot.readI32()
            }
            _i += 1
          }
          _iprot.readListEnd()
          _rv
        }
      }
    
      @inline private def writeModelIdsField(modelIds_item: Seq[Int], _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(ModelIdsField)
        writeModelIdsValue(modelIds_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeModelIdsValue(modelIds_item: Seq[Int], _oprot: TProtocol): Unit = {
        _oprot.writeListBegin(new TList(TType.I32, modelIds_item.size))
        modelIds_item match {
          case _: IndexedSeq[_] =>
            var _i = 0
            val _size = modelIds_item.size
            while (_i < _size) {
              val modelIds_item_element = modelIds_item(_i)
              _oprot.writeI32(modelIds_item_element)
              _i += 1
            }
          case _ =>
            modelIds_item.foreach { modelIds_item_element =>
              _oprot.writeI32(modelIds_item_element)
            }
        }
        _oprot.writeListEnd()
      }
    
    
    }
    
    class Args(
        val modelIds: Seq[Int],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product1[Seq[Int]]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
    
      def this(
        modelIds: Seq[Int] = Seq[Int]()
      ) = this(
        modelIds,
        Map.empty
      )
    
      def _1: Seq[Int] = modelIds
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        if (modelIds ne null) writeModelIdsField(modelIds, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        modelIds: Seq[Int] = this.modelIds,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          modelIds,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.modelIds
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    }

    type SuccessType = Map[modeldb.ProblemType, Seq[Int]]
    
    object Result extends ValidatingThriftStructCodec3[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("groupByProblemType_result")
      val SuccessField: TField = new TField("success", TType.MAP, 0)
      val SuccessFieldManifest: Manifest[Map[modeldb.ProblemType, Seq[Int]]] = implicitly[Manifest[Map[modeldb.ProblemType, Seq[Int]]]]
      val SvExField: TField = new TField("svEx", TType.STRUCT, 1)
      val SvExFieldManifest: Manifest[modeldb.ServerLogicException] = implicitly[Manifest[modeldb.ServerLogicException]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.Some(implicitly[Manifest[modeldb.ProblemType]]),
          _root_.scala.Some(implicitly[Manifest[Seq[Int]]]),
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          SvExField,
          true,
          false,
          SvExFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf ++= validateField(item.svEx)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                field.map { case (key, value) =>
                    val newKey = {
                    val field = key
                    field
                  }
  
  
                    val newValue = {
                    val field = value
                    field.map { field =>
                        field
                      }
                  }
  
  
                  newKey -> newValue
                }
              }
            },
          svEx =
            {
              val field = original.svEx
              field.map { field =>
                modeldb.ServerLogicException.withoutPassthroughFields(field)
              }
            }
        )
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[Map[modeldb.ProblemType, Seq[Int]]] = _root_.scala.None
        var svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.MAP =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.MAP
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 1 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    svEx = _root_.scala.Some(readSvExValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'svEx' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          svEx,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[Map[modeldb.ProblemType, Seq[Int]]] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ): Result =
        new Result(
          success,
          svEx
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Tuple2[Option[Map[modeldb.ProblemType, Seq[Int]]], Option[modeldb.ServerLogicException]]] = _root_.scala.Some(_item.toTuple)
    
    
      @inline private[modeldb] def readSuccessValue(_iprot: TProtocol): Map[modeldb.ProblemType, Seq[Int]] = {
        val _map = _iprot.readMapBegin()
        if (_map.size == 0) {
          _iprot.readMapEnd()
          Map.empty[modeldb.ProblemType, Seq[Int]]
        } else {
          val _rv = new mutable$HashMap[modeldb.ProblemType, Seq[Int]]
          var _i = 0
          while (_i < _map.size) {
            val _key = {
              modeldb.ProblemType.getOrUnknown(_iprot.readI32())
            }
            val _value = {
              val _list = _iprot.readListBegin()
              if (_list.size == 0) {
                _iprot.readListEnd()
                Nil
              } else {
                val _rv = new mutable$ArrayBuffer[Int](_list.size)
                var _i = 0
                while (_i < _list.size) {
                  _rv += {
                    _iprot.readI32()
                  }
                  _i += 1
                }
                _iprot.readListEnd()
                _rv
              }
            }
            _rv(_key) = _value
            _i += 1
          }
          _iprot.readMapEnd()
          _rv
        }
      }
    
      @inline private def writeSuccessField(success_item: Map[modeldb.ProblemType, Seq[Int]], _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: Map[modeldb.ProblemType, Seq[Int]], _oprot: TProtocol): Unit = {
        _oprot.writeMapBegin(new TMap(TType.I32, TType.LIST, success_item.size))
        success_item.foreach { case (success_item_key, success_item_value) =>
          _oprot.writeI32(success_item_key.value)
          _oprot.writeListBegin(new TList(TType.I32, success_item_value.size))
          success_item_value match {
            case _: IndexedSeq[_] =>
              var _i = 0
              val _size = success_item_value.size
              while (_i < _size) {
                val success_item_value_element = success_item_value(_i)
                _oprot.writeI32(success_item_value_element)
                _i += 1
              }
            case _ =>
              success_item_value.foreach { success_item_value_element =>
                _oprot.writeI32(success_item_value_element)
              }
          }
          _oprot.writeListEnd()
        }
        _oprot.writeMapEnd()
      }
    
      @inline private[modeldb] def readSvExValue(_iprot: TProtocol): modeldb.ServerLogicException = {
        modeldb.ServerLogicException.decode(_iprot)
      }
    
      @inline private def writeSvExField(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SvExField)
        writeSvExValue(svEx_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSvExValue(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        svEx_item.write(_oprot)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[Map[modeldb.ProblemType, Seq[Int]]],
        val svEx: _root_.scala.Option[modeldb.ServerLogicException],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[Map[modeldb.ProblemType, Seq[Int]]] with ThriftStruct
      with _root_.scala.Product2[Option[Map[modeldb.ProblemType, Seq[Int]]], Option[modeldb.ServerLogicException]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
    
      def this(
        success: _root_.scala.Option[Map[modeldb.ProblemType, Seq[Int]]] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ) = this(
        success,
        svEx,
        Map.empty
      )
    
      def _1: _root_.scala.Option[Map[modeldb.ProblemType, Seq[Int]]] = success
      def _2: _root_.scala.Option[modeldb.ServerLogicException] = svEx
    
      def toTuple: _root_.scala.Tuple2[Option[Map[modeldb.ProblemType, Seq[Int]]], Option[modeldb.ServerLogicException]] = {
        (
          success,
          svEx
        )
      }
    
      def successField: Option[Map[modeldb.ProblemType, Seq[Int]]] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Seq(svEx)
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (svEx.isDefined) writeSvExField(svEx.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[Map[modeldb.ProblemType, Seq[Int]]] = this.success,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = this.svEx,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          svEx,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 2
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case 1 => this.svEx
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Function1[Args,Future[Map[modeldb.ProblemType, Seq[Int]]]]
    type ReqRepFunctionType = Function1[_root_.com.twitter.scrooge.Request[Args],Future[_root_.com.twitter.scrooge.Response[Map[modeldb.ProblemType, Seq[Int]]]]]

    type ServiceIfaceServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ReqRepServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]]

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]] { request: _root_.com.twitter.scrooge.Request[Args] =>
        f(request)
      }

    private[this] val toResult = (res: SuccessType) => Result(Some(res))

    val name: String = "groupByProblemType"
    val serviceName: String = "ModelDBService"
    val argsCodec = Args
    val responseCodec = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val groupByProblemType$args = GroupByProblemType.Args
  type groupByProblemType$args = GroupByProblemType.Args

  val groupByProblemType$result = GroupByProblemType.Result
  type groupByProblemType$result = GroupByProblemType.Result

  object SimilarModels extends ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("similarModels_args")
      val ModelIdField: TField = new TField("modelId", TType.I32, 1)
      val ModelIdFieldManifest: Manifest[Int] = implicitly[Manifest[Int]]
      val CompMetricsField: TField = new TField("compMetrics", TType.LIST, 2)
      val CompMetricsFieldManifest: Manifest[Seq[modeldb.ModelCompMetric]] = implicitly[Manifest[Seq[modeldb.ModelCompMetric]]]
      val NumModelsField: TField = new TField("numModels", TType.I32, 3)
      val NumModelsFieldManifest: Manifest[Int] = implicitly[Manifest[Int]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          ModelIdField,
          false,
          false,
          ModelIdFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          CompMetricsField,
          false,
          false,
          CompMetricsFieldManifest,
          _root_.scala.None,
          _root_.scala.Some(implicitly[Manifest[modeldb.ModelCompMetric]]),
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          NumModelsField,
          false,
          false,
          NumModelsFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.modelId)
        buf ++= validateField(item.compMetrics)
        buf ++= validateField(item.numModels)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          modelId =
            {
              val field = original.modelId
              field
            },
          compMetrics =
            {
              val field = original.compMetrics
              field.map { field =>
                field
              }
            },
          numModels =
            {
              val field = original.numModels
              field
            }
        )
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var modelId: Int = 0
        var compMetrics: Seq[modeldb.ModelCompMetric] = Seq[modeldb.ModelCompMetric]()
        var numModels: Int = 0
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.I32 =>
                    modelId = readModelIdValue(_iprot)
                  case _actualType =>
                    val _expectedType = TType.I32
                    throw new TProtocolException(
                      "Received wrong type for field 'modelId' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 2 =>
                _field.`type` match {
                  case TType.LIST =>
                    compMetrics = readCompMetricsValue(_iprot)
                  case _actualType =>
                    val _expectedType = TType.LIST
                    throw new TProtocolException(
                      "Received wrong type for field 'compMetrics' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 3 =>
                _field.`type` match {
                  case TType.I32 =>
                    numModels = readNumModelsValue(_iprot)
                  case _actualType =>
                    val _expectedType = TType.I32
                    throw new TProtocolException(
                      "Received wrong type for field 'numModels' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Args(
          modelId,
          compMetrics,
          numModels,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        modelId: Int,
        compMetrics: Seq[modeldb.ModelCompMetric] = Seq[modeldb.ModelCompMetric](),
        numModels: Int
      ): Args =
        new Args(
          modelId,
          compMetrics,
          numModels
        )
    
      def unapply(_item: Args): _root_.scala.Option[_root_.scala.Tuple3[Int, Seq[modeldb.ModelCompMetric], Int]] = _root_.scala.Some(_item.toTuple)
    
    
      @inline private[modeldb] def readModelIdValue(_iprot: TProtocol): Int = {
        _iprot.readI32()
      }
    
      @inline private def writeModelIdField(modelId_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(ModelIdField)
        writeModelIdValue(modelId_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeModelIdValue(modelId_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeI32(modelId_item)
      }
    
      @inline private[modeldb] def readCompMetricsValue(_iprot: TProtocol): Seq[modeldb.ModelCompMetric] = {
        val _list = _iprot.readListBegin()
        if (_list.size == 0) {
          _iprot.readListEnd()
          Nil
        } else {
          val _rv = new mutable$ArrayBuffer[modeldb.ModelCompMetric](_list.size)
          var _i = 0
          while (_i < _list.size) {
            _rv += {
              modeldb.ModelCompMetric.getOrUnknown(_iprot.readI32())
            }
            _i += 1
          }
          _iprot.readListEnd()
          _rv
        }
      }
    
      @inline private def writeCompMetricsField(compMetrics_item: Seq[modeldb.ModelCompMetric], _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(CompMetricsField)
        writeCompMetricsValue(compMetrics_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeCompMetricsValue(compMetrics_item: Seq[modeldb.ModelCompMetric], _oprot: TProtocol): Unit = {
        _oprot.writeListBegin(new TList(TType.I32, compMetrics_item.size))
        compMetrics_item match {
          case _: IndexedSeq[_] =>
            var _i = 0
            val _size = compMetrics_item.size
            while (_i < _size) {
              val compMetrics_item_element = compMetrics_item(_i)
              _oprot.writeI32(compMetrics_item_element.value)
              _i += 1
            }
          case _ =>
            compMetrics_item.foreach { compMetrics_item_element =>
              _oprot.writeI32(compMetrics_item_element.value)
            }
        }
        _oprot.writeListEnd()
      }
    
      @inline private[modeldb] def readNumModelsValue(_iprot: TProtocol): Int = {
        _iprot.readI32()
      }
    
      @inline private def writeNumModelsField(numModels_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(NumModelsField)
        writeNumModelsValue(numModels_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeNumModelsValue(numModels_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeI32(numModels_item)
      }
    
    
    }
    
    class Args(
        val modelId: Int,
        val compMetrics: Seq[modeldb.ModelCompMetric],
        val numModels: Int,
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product3[Int, Seq[modeldb.ModelCompMetric], Int]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
    
      def this(
        modelId: Int,
        compMetrics: Seq[modeldb.ModelCompMetric] = Seq[modeldb.ModelCompMetric](),
        numModels: Int
      ) = this(
        modelId,
        compMetrics,
        numModels,
        Map.empty
      )
    
      def _1: Int = modelId
      def _2: Seq[modeldb.ModelCompMetric] = compMetrics
      def _3: Int = numModels
    
      def toTuple: _root_.scala.Tuple3[Int, Seq[modeldb.ModelCompMetric], Int] = {
        (
          modelId,
          compMetrics,
          numModels
        )
      }
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        writeModelIdField(modelId, _oprot)
        if (compMetrics ne null) writeCompMetricsField(compMetrics, _oprot)
        writeNumModelsField(numModels, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        modelId: Int = this.modelId,
        compMetrics: Seq[modeldb.ModelCompMetric] = this.compMetrics,
        numModels: Int = this.numModels,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          modelId,
          compMetrics,
          numModels,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 3
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.modelId
        case 1 => this.compMetrics
        case 2 => this.numModels
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    }

    type SuccessType = Seq[Int]
    
    object Result extends ValidatingThriftStructCodec3[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("similarModels_result")
      val SuccessField: TField = new TField("success", TType.LIST, 0)
      val SuccessFieldManifest: Manifest[Seq[Int]] = implicitly[Manifest[Seq[Int]]]
      val RnfExField: TField = new TField("rnfEx", TType.STRUCT, 1)
      val RnfExFieldManifest: Manifest[modeldb.ResourceNotFoundException] = implicitly[Manifest[modeldb.ResourceNotFoundException]]
      val BrExField: TField = new TField("brEx", TType.STRUCT, 2)
      val BrExFieldManifest: Manifest[modeldb.BadRequestException] = implicitly[Manifest[modeldb.BadRequestException]]
      val SvExField: TField = new TField("svEx", TType.STRUCT, 3)
      val SvExFieldManifest: Manifest[modeldb.ServerLogicException] = implicitly[Manifest[modeldb.ServerLogicException]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.Some(implicitly[Manifest[Int]]),
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          RnfExField,
          true,
          false,
          RnfExFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          BrExField,
          true,
          false,
          BrExFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          SvExField,
          true,
          false,
          SvExFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf ++= validateField(item.rnfEx)
        buf ++= validateField(item.brEx)
        buf ++= validateField(item.svEx)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                field.map { field =>
                  field
                }
              }
            },
          rnfEx =
            {
              val field = original.rnfEx
              field.map { field =>
                modeldb.ResourceNotFoundException.withoutPassthroughFields(field)
              }
            },
          brEx =
            {
              val field = original.brEx
              field.map { field =>
                modeldb.BadRequestException.withoutPassthroughFields(field)
              }
            },
          svEx =
            {
              val field = original.svEx
              field.map { field =>
                modeldb.ServerLogicException.withoutPassthroughFields(field)
              }
            }
        )
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[Seq[Int]] = _root_.scala.None
        var rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException] = _root_.scala.None
        var brEx: _root_.scala.Option[modeldb.BadRequestException] = _root_.scala.None
        var svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.LIST =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.LIST
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 1 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    rnfEx = _root_.scala.Some(readRnfExValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'rnfEx' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 2 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    brEx = _root_.scala.Some(readBrExValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'brEx' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 3 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    svEx = _root_.scala.Some(readSvExValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'svEx' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          rnfEx,
          brEx,
          svEx,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[Seq[Int]] = _root_.scala.None,
        rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException] = _root_.scala.None,
        brEx: _root_.scala.Option[modeldb.BadRequestException] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ): Result =
        new Result(
          success,
          rnfEx,
          brEx,
          svEx
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Tuple4[Option[Seq[Int]], Option[modeldb.ResourceNotFoundException], Option[modeldb.BadRequestException], Option[modeldb.ServerLogicException]]] = _root_.scala.Some(_item.toTuple)
    
    
      @inline private[modeldb] def readSuccessValue(_iprot: TProtocol): Seq[Int] = {
        val _list = _iprot.readListBegin()
        if (_list.size == 0) {
          _iprot.readListEnd()
          Nil
        } else {
          val _rv = new mutable$ArrayBuffer[Int](_list.size)
          var _i = 0
          while (_i < _list.size) {
            _rv += {
              _iprot.readI32()
            }
            _i += 1
          }
          _iprot.readListEnd()
          _rv
        }
      }
    
      @inline private def writeSuccessField(success_item: Seq[Int], _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: Seq[Int], _oprot: TProtocol): Unit = {
        _oprot.writeListBegin(new TList(TType.I32, success_item.size))
        success_item match {
          case _: IndexedSeq[_] =>
            var _i = 0
            val _size = success_item.size
            while (_i < _size) {
              val success_item_element = success_item(_i)
              _oprot.writeI32(success_item_element)
              _i += 1
            }
          case _ =>
            success_item.foreach { success_item_element =>
              _oprot.writeI32(success_item_element)
            }
        }
        _oprot.writeListEnd()
      }
    
      @inline private[modeldb] def readRnfExValue(_iprot: TProtocol): modeldb.ResourceNotFoundException = {
        modeldb.ResourceNotFoundException.decode(_iprot)
      }
    
      @inline private def writeRnfExField(rnfEx_item: modeldb.ResourceNotFoundException, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(RnfExField)
        writeRnfExValue(rnfEx_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeRnfExValue(rnfEx_item: modeldb.ResourceNotFoundException, _oprot: TProtocol): Unit = {
        rnfEx_item.write(_oprot)
      }
    
      @inline private[modeldb] def readBrExValue(_iprot: TProtocol): modeldb.BadRequestException = {
        modeldb.BadRequestException.decode(_iprot)
      }
    
      @inline private def writeBrExField(brEx_item: modeldb.BadRequestException, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(BrExField)
        writeBrExValue(brEx_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeBrExValue(brEx_item: modeldb.BadRequestException, _oprot: TProtocol): Unit = {
        brEx_item.write(_oprot)
      }
    
      @inline private[modeldb] def readSvExValue(_iprot: TProtocol): modeldb.ServerLogicException = {
        modeldb.ServerLogicException.decode(_iprot)
      }
    
      @inline private def writeSvExField(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SvExField)
        writeSvExValue(svEx_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSvExValue(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        svEx_item.write(_oprot)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[Seq[Int]],
        val rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException],
        val brEx: _root_.scala.Option[modeldb.BadRequestException],
        val svEx: _root_.scala.Option[modeldb.ServerLogicException],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[Seq[Int]] with ThriftStruct
      with _root_.scala.Product4[Option[Seq[Int]], Option[modeldb.ResourceNotFoundException], Option[modeldb.BadRequestException], Option[modeldb.ServerLogicException]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
    
      def this(
        success: _root_.scala.Option[Seq[Int]] = _root_.scala.None,
        rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException] = _root_.scala.None,
        brEx: _root_.scala.Option[modeldb.BadRequestException] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ) = this(
        success,
        rnfEx,
        brEx,
        svEx,
        Map.empty
      )
    
      def _1: _root_.scala.Option[Seq[Int]] = success
      def _2: _root_.scala.Option[modeldb.ResourceNotFoundException] = rnfEx
      def _3: _root_.scala.Option[modeldb.BadRequestException] = brEx
      def _4: _root_.scala.Option[modeldb.ServerLogicException] = svEx
    
      def toTuple: _root_.scala.Tuple4[Option[Seq[Int]], Option[modeldb.ResourceNotFoundException], Option[modeldb.BadRequestException], Option[modeldb.ServerLogicException]] = {
        (
          success,
          rnfEx,
          brEx,
          svEx
        )
      }
    
      def successField: Option[Seq[Int]] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Seq(rnfEx, brEx, svEx)
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (rnfEx.isDefined) writeRnfExField(rnfEx.get, _oprot)
        if (brEx.isDefined) writeBrExField(brEx.get, _oprot)
        if (svEx.isDefined) writeSvExField(svEx.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[Seq[Int]] = this.success,
        rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException] = this.rnfEx,
        brEx: _root_.scala.Option[modeldb.BadRequestException] = this.brEx,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = this.svEx,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          rnfEx,
          brEx,
          svEx,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 4
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case 1 => this.rnfEx
        case 2 => this.brEx
        case 3 => this.svEx
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Function1[Args,Future[Seq[Int]]]
    type ReqRepFunctionType = Function1[_root_.com.twitter.scrooge.Request[Args],Future[_root_.com.twitter.scrooge.Response[Seq[Int]]]]

    type ServiceIfaceServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ReqRepServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]]

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]] { request: _root_.com.twitter.scrooge.Request[Args] =>
        f(request)
      }

    private[this] val toResult = (res: SuccessType) => Result(Some(res))

    val name: String = "similarModels"
    val serviceName: String = "ModelDBService"
    val argsCodec = Args
    val responseCodec = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val similarModels$args = SimilarModels.Args
  type similarModels$args = SimilarModels.Args

  val similarModels$result = SimilarModels.Result
  type similarModels$result = SimilarModels.Result

  object LinearModelFeatureImportances extends ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("linearModelFeatureImportances_args")
      val ModelIdField: TField = new TField("modelId", TType.I32, 1)
      val ModelIdFieldManifest: Manifest[Int] = implicitly[Manifest[Int]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          ModelIdField,
          false,
          false,
          ModelIdFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.modelId)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          modelId =
            {
              val field = original.modelId
              field
            }
        )
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var modelId: Int = 0
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.I32 =>
                    modelId = readModelIdValue(_iprot)
                  case _actualType =>
                    val _expectedType = TType.I32
                    throw new TProtocolException(
                      "Received wrong type for field 'modelId' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Args(
          modelId,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        modelId: Int
      ): Args =
        new Args(
          modelId
        )
    
      def unapply(_item: Args): _root_.scala.Option[Int] = _root_.scala.Some(_item.modelId)
    
    
      @inline private[modeldb] def readModelIdValue(_iprot: TProtocol): Int = {
        _iprot.readI32()
      }
    
      @inline private def writeModelIdField(modelId_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(ModelIdField)
        writeModelIdValue(modelId_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeModelIdValue(modelId_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeI32(modelId_item)
      }
    
    
    }
    
    class Args(
        val modelId: Int,
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product1[Int]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
    
      def this(
        modelId: Int
      ) = this(
        modelId,
        Map.empty
      )
    
      def _1: Int = modelId
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        writeModelIdField(modelId, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        modelId: Int = this.modelId,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          modelId,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.modelId
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    }

    type SuccessType = Seq[String]
    
    object Result extends ValidatingThriftStructCodec3[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("linearModelFeatureImportances_result")
      val SuccessField: TField = new TField("success", TType.LIST, 0)
      val SuccessFieldManifest: Manifest[Seq[String]] = implicitly[Manifest[Seq[String]]]
      val RnfExField: TField = new TField("rnfEx", TType.STRUCT, 1)
      val RnfExFieldManifest: Manifest[modeldb.ResourceNotFoundException] = implicitly[Manifest[modeldb.ResourceNotFoundException]]
      val IoExField: TField = new TField("ioEx", TType.STRUCT, 2)
      val IoExFieldManifest: Manifest[modeldb.IllegalOperationException] = implicitly[Manifest[modeldb.IllegalOperationException]]
      val SvExField: TField = new TField("svEx", TType.STRUCT, 3)
      val SvExFieldManifest: Manifest[modeldb.ServerLogicException] = implicitly[Manifest[modeldb.ServerLogicException]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.Some(implicitly[Manifest[String]]),
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          RnfExField,
          true,
          false,
          RnfExFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          IoExField,
          true,
          false,
          IoExFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          SvExField,
          true,
          false,
          SvExFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf ++= validateField(item.rnfEx)
        buf ++= validateField(item.ioEx)
        buf ++= validateField(item.svEx)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                field.map { field =>
                  field
                }
              }
            },
          rnfEx =
            {
              val field = original.rnfEx
              field.map { field =>
                modeldb.ResourceNotFoundException.withoutPassthroughFields(field)
              }
            },
          ioEx =
            {
              val field = original.ioEx
              field.map { field =>
                modeldb.IllegalOperationException.withoutPassthroughFields(field)
              }
            },
          svEx =
            {
              val field = original.svEx
              field.map { field =>
                modeldb.ServerLogicException.withoutPassthroughFields(field)
              }
            }
        )
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[Seq[String]] = _root_.scala.None
        var rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException] = _root_.scala.None
        var ioEx: _root_.scala.Option[modeldb.IllegalOperationException] = _root_.scala.None
        var svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.LIST =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.LIST
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 1 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    rnfEx = _root_.scala.Some(readRnfExValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'rnfEx' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 2 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    ioEx = _root_.scala.Some(readIoExValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'ioEx' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 3 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    svEx = _root_.scala.Some(readSvExValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'svEx' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          rnfEx,
          ioEx,
          svEx,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[Seq[String]] = _root_.scala.None,
        rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException] = _root_.scala.None,
        ioEx: _root_.scala.Option[modeldb.IllegalOperationException] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ): Result =
        new Result(
          success,
          rnfEx,
          ioEx,
          svEx
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Tuple4[Option[Seq[String]], Option[modeldb.ResourceNotFoundException], Option[modeldb.IllegalOperationException], Option[modeldb.ServerLogicException]]] = _root_.scala.Some(_item.toTuple)
    
    
      @inline private[modeldb] def readSuccessValue(_iprot: TProtocol): Seq[String] = {
        val _list = _iprot.readListBegin()
        if (_list.size == 0) {
          _iprot.readListEnd()
          Nil
        } else {
          val _rv = new mutable$ArrayBuffer[String](_list.size)
          var _i = 0
          while (_i < _list.size) {
            _rv += {
              _iprot.readString()
            }
            _i += 1
          }
          _iprot.readListEnd()
          _rv
        }
      }
    
      @inline private def writeSuccessField(success_item: Seq[String], _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: Seq[String], _oprot: TProtocol): Unit = {
        _oprot.writeListBegin(new TList(TType.STRING, success_item.size))
        success_item match {
          case _: IndexedSeq[_] =>
            var _i = 0
            val _size = success_item.size
            while (_i < _size) {
              val success_item_element = success_item(_i)
              _oprot.writeString(success_item_element)
              _i += 1
            }
          case _ =>
            success_item.foreach { success_item_element =>
              _oprot.writeString(success_item_element)
            }
        }
        _oprot.writeListEnd()
      }
    
      @inline private[modeldb] def readRnfExValue(_iprot: TProtocol): modeldb.ResourceNotFoundException = {
        modeldb.ResourceNotFoundException.decode(_iprot)
      }
    
      @inline private def writeRnfExField(rnfEx_item: modeldb.ResourceNotFoundException, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(RnfExField)
        writeRnfExValue(rnfEx_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeRnfExValue(rnfEx_item: modeldb.ResourceNotFoundException, _oprot: TProtocol): Unit = {
        rnfEx_item.write(_oprot)
      }
    
      @inline private[modeldb] def readIoExValue(_iprot: TProtocol): modeldb.IllegalOperationException = {
        modeldb.IllegalOperationException.decode(_iprot)
      }
    
      @inline private def writeIoExField(ioEx_item: modeldb.IllegalOperationException, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(IoExField)
        writeIoExValue(ioEx_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeIoExValue(ioEx_item: modeldb.IllegalOperationException, _oprot: TProtocol): Unit = {
        ioEx_item.write(_oprot)
      }
    
      @inline private[modeldb] def readSvExValue(_iprot: TProtocol): modeldb.ServerLogicException = {
        modeldb.ServerLogicException.decode(_iprot)
      }
    
      @inline private def writeSvExField(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SvExField)
        writeSvExValue(svEx_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSvExValue(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        svEx_item.write(_oprot)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[Seq[String]],
        val rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException],
        val ioEx: _root_.scala.Option[modeldb.IllegalOperationException],
        val svEx: _root_.scala.Option[modeldb.ServerLogicException],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[Seq[String]] with ThriftStruct
      with _root_.scala.Product4[Option[Seq[String]], Option[modeldb.ResourceNotFoundException], Option[modeldb.IllegalOperationException], Option[modeldb.ServerLogicException]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
    
      def this(
        success: _root_.scala.Option[Seq[String]] = _root_.scala.None,
        rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException] = _root_.scala.None,
        ioEx: _root_.scala.Option[modeldb.IllegalOperationException] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ) = this(
        success,
        rnfEx,
        ioEx,
        svEx,
        Map.empty
      )
    
      def _1: _root_.scala.Option[Seq[String]] = success
      def _2: _root_.scala.Option[modeldb.ResourceNotFoundException] = rnfEx
      def _3: _root_.scala.Option[modeldb.IllegalOperationException] = ioEx
      def _4: _root_.scala.Option[modeldb.ServerLogicException] = svEx
    
      def toTuple: _root_.scala.Tuple4[Option[Seq[String]], Option[modeldb.ResourceNotFoundException], Option[modeldb.IllegalOperationException], Option[modeldb.ServerLogicException]] = {
        (
          success,
          rnfEx,
          ioEx,
          svEx
        )
      }
    
      def successField: Option[Seq[String]] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Seq(rnfEx, ioEx, svEx)
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (rnfEx.isDefined) writeRnfExField(rnfEx.get, _oprot)
        if (ioEx.isDefined) writeIoExField(ioEx.get, _oprot)
        if (svEx.isDefined) writeSvExField(svEx.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[Seq[String]] = this.success,
        rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException] = this.rnfEx,
        ioEx: _root_.scala.Option[modeldb.IllegalOperationException] = this.ioEx,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = this.svEx,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          rnfEx,
          ioEx,
          svEx,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 4
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case 1 => this.rnfEx
        case 2 => this.ioEx
        case 3 => this.svEx
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Function1[Args,Future[Seq[String]]]
    type ReqRepFunctionType = Function1[_root_.com.twitter.scrooge.Request[Args],Future[_root_.com.twitter.scrooge.Response[Seq[String]]]]

    type ServiceIfaceServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ReqRepServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]]

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]] { request: _root_.com.twitter.scrooge.Request[Args] =>
        f(request)
      }

    private[this] val toResult = (res: SuccessType) => Result(Some(res))

    val name: String = "linearModelFeatureImportances"
    val serviceName: String = "ModelDBService"
    val argsCodec = Args
    val responseCodec = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val linearModelFeatureImportances$args = LinearModelFeatureImportances.Args
  type linearModelFeatureImportances$args = LinearModelFeatureImportances.Args

  val linearModelFeatureImportances$result = LinearModelFeatureImportances.Result
  type linearModelFeatureImportances$result = LinearModelFeatureImportances.Result

  object CompareLinearModelFeatureImportances extends ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("compareLinearModelFeatureImportances_args")
      val Model1IdField: TField = new TField("model1Id", TType.I32, 1)
      val Model1IdFieldManifest: Manifest[Int] = implicitly[Manifest[Int]]
      val Model2IdField: TField = new TField("model2Id", TType.I32, 2)
      val Model2IdFieldManifest: Manifest[Int] = implicitly[Manifest[Int]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          Model1IdField,
          false,
          false,
          Model1IdFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          Model2IdField,
          false,
          false,
          Model2IdFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.model1Id)
        buf ++= validateField(item.model2Id)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          model1Id =
            {
              val field = original.model1Id
              field
            },
          model2Id =
            {
              val field = original.model2Id
              field
            }
        )
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var model1Id: Int = 0
        var model2Id: Int = 0
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.I32 =>
                    model1Id = readModel1IdValue(_iprot)
                  case _actualType =>
                    val _expectedType = TType.I32
                    throw new TProtocolException(
                      "Received wrong type for field 'model1Id' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 2 =>
                _field.`type` match {
                  case TType.I32 =>
                    model2Id = readModel2IdValue(_iprot)
                  case _actualType =>
                    val _expectedType = TType.I32
                    throw new TProtocolException(
                      "Received wrong type for field 'model2Id' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Args(
          model1Id,
          model2Id,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        model1Id: Int,
        model2Id: Int
      ): Args =
        new Args(
          model1Id,
          model2Id
        )
    
      def unapply(_item: Args): _root_.scala.Option[_root_.scala.Tuple2[Int, Int]] = _root_.scala.Some(_item.toTuple)
    
    
      @inline private[modeldb] def readModel1IdValue(_iprot: TProtocol): Int = {
        _iprot.readI32()
      }
    
      @inline private def writeModel1IdField(model1Id_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(Model1IdField)
        writeModel1IdValue(model1Id_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeModel1IdValue(model1Id_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeI32(model1Id_item)
      }
    
      @inline private[modeldb] def readModel2IdValue(_iprot: TProtocol): Int = {
        _iprot.readI32()
      }
    
      @inline private def writeModel2IdField(model2Id_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(Model2IdField)
        writeModel2IdValue(model2Id_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeModel2IdValue(model2Id_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeI32(model2Id_item)
      }
    
    
    }
    
    class Args(
        val model1Id: Int,
        val model2Id: Int,
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product2[Int, Int]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
    
      def this(
        model1Id: Int,
        model2Id: Int
      ) = this(
        model1Id,
        model2Id,
        Map.empty
      )
    
      def _1: Int = model1Id
      def _2: Int = model2Id
    
      def toTuple: _root_.scala.Tuple2[Int, Int] = {
        (
          model1Id,
          model2Id
        )
      }
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        writeModel1IdField(model1Id, _oprot)
        writeModel2IdField(model2Id, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        model1Id: Int = this.model1Id,
        model2Id: Int = this.model2Id,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          model1Id,
          model2Id,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 2
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.model1Id
        case 1 => this.model2Id
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    }

    type SuccessType = Seq[modeldb.FeatureImportanceComparison]
    
    object Result extends ValidatingThriftStructCodec3[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("compareLinearModelFeatureImportances_result")
      val SuccessField: TField = new TField("success", TType.LIST, 0)
      val SuccessFieldManifest: Manifest[Seq[modeldb.FeatureImportanceComparison]] = implicitly[Manifest[Seq[modeldb.FeatureImportanceComparison]]]
      val RnfExField: TField = new TField("rnfEx", TType.STRUCT, 1)
      val RnfExFieldManifest: Manifest[modeldb.ResourceNotFoundException] = implicitly[Manifest[modeldb.ResourceNotFoundException]]
      val IoExField: TField = new TField("ioEx", TType.STRUCT, 2)
      val IoExFieldManifest: Manifest[modeldb.IllegalOperationException] = implicitly[Manifest[modeldb.IllegalOperationException]]
      val SvExField: TField = new TField("svEx", TType.STRUCT, 3)
      val SvExFieldManifest: Manifest[modeldb.ServerLogicException] = implicitly[Manifest[modeldb.ServerLogicException]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.Some(implicitly[Manifest[modeldb.FeatureImportanceComparison]]),
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          RnfExField,
          true,
          false,
          RnfExFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          IoExField,
          true,
          false,
          IoExFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          SvExField,
          true,
          false,
          SvExFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf ++= validateField(item.rnfEx)
        buf ++= validateField(item.ioEx)
        buf ++= validateField(item.svEx)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                field.map { field =>
                  modeldb.FeatureImportanceComparison.withoutPassthroughFields(field)
                }
              }
            },
          rnfEx =
            {
              val field = original.rnfEx
              field.map { field =>
                modeldb.ResourceNotFoundException.withoutPassthroughFields(field)
              }
            },
          ioEx =
            {
              val field = original.ioEx
              field.map { field =>
                modeldb.IllegalOperationException.withoutPassthroughFields(field)
              }
            },
          svEx =
            {
              val field = original.svEx
              field.map { field =>
                modeldb.ServerLogicException.withoutPassthroughFields(field)
              }
            }
        )
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[Seq[modeldb.FeatureImportanceComparison]] = _root_.scala.None
        var rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException] = _root_.scala.None
        var ioEx: _root_.scala.Option[modeldb.IllegalOperationException] = _root_.scala.None
        var svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.LIST =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.LIST
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 1 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    rnfEx = _root_.scala.Some(readRnfExValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'rnfEx' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 2 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    ioEx = _root_.scala.Some(readIoExValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'ioEx' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 3 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    svEx = _root_.scala.Some(readSvExValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'svEx' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          rnfEx,
          ioEx,
          svEx,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[Seq[modeldb.FeatureImportanceComparison]] = _root_.scala.None,
        rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException] = _root_.scala.None,
        ioEx: _root_.scala.Option[modeldb.IllegalOperationException] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ): Result =
        new Result(
          success,
          rnfEx,
          ioEx,
          svEx
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Tuple4[Option[Seq[modeldb.FeatureImportanceComparison]], Option[modeldb.ResourceNotFoundException], Option[modeldb.IllegalOperationException], Option[modeldb.ServerLogicException]]] = _root_.scala.Some(_item.toTuple)
    
    
      @inline private[modeldb] def readSuccessValue(_iprot: TProtocol): Seq[modeldb.FeatureImportanceComparison] = {
        val _list = _iprot.readListBegin()
        if (_list.size == 0) {
          _iprot.readListEnd()
          Nil
        } else {
          val _rv = new mutable$ArrayBuffer[modeldb.FeatureImportanceComparison](_list.size)
          var _i = 0
          while (_i < _list.size) {
            _rv += {
              modeldb.FeatureImportanceComparison.decode(_iprot)
            }
            _i += 1
          }
          _iprot.readListEnd()
          _rv
        }
      }
    
      @inline private def writeSuccessField(success_item: Seq[modeldb.FeatureImportanceComparison], _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: Seq[modeldb.FeatureImportanceComparison], _oprot: TProtocol): Unit = {
        _oprot.writeListBegin(new TList(TType.STRUCT, success_item.size))
        success_item match {
          case _: IndexedSeq[_] =>
            var _i = 0
            val _size = success_item.size
            while (_i < _size) {
              val success_item_element = success_item(_i)
              success_item_element.write(_oprot)
              _i += 1
            }
          case _ =>
            success_item.foreach { success_item_element =>
              success_item_element.write(_oprot)
            }
        }
        _oprot.writeListEnd()
      }
    
      @inline private[modeldb] def readRnfExValue(_iprot: TProtocol): modeldb.ResourceNotFoundException = {
        modeldb.ResourceNotFoundException.decode(_iprot)
      }
    
      @inline private def writeRnfExField(rnfEx_item: modeldb.ResourceNotFoundException, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(RnfExField)
        writeRnfExValue(rnfEx_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeRnfExValue(rnfEx_item: modeldb.ResourceNotFoundException, _oprot: TProtocol): Unit = {
        rnfEx_item.write(_oprot)
      }
    
      @inline private[modeldb] def readIoExValue(_iprot: TProtocol): modeldb.IllegalOperationException = {
        modeldb.IllegalOperationException.decode(_iprot)
      }
    
      @inline private def writeIoExField(ioEx_item: modeldb.IllegalOperationException, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(IoExField)
        writeIoExValue(ioEx_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeIoExValue(ioEx_item: modeldb.IllegalOperationException, _oprot: TProtocol): Unit = {
        ioEx_item.write(_oprot)
      }
    
      @inline private[modeldb] def readSvExValue(_iprot: TProtocol): modeldb.ServerLogicException = {
        modeldb.ServerLogicException.decode(_iprot)
      }
    
      @inline private def writeSvExField(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SvExField)
        writeSvExValue(svEx_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSvExValue(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        svEx_item.write(_oprot)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[Seq[modeldb.FeatureImportanceComparison]],
        val rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException],
        val ioEx: _root_.scala.Option[modeldb.IllegalOperationException],
        val svEx: _root_.scala.Option[modeldb.ServerLogicException],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[Seq[modeldb.FeatureImportanceComparison]] with ThriftStruct
      with _root_.scala.Product4[Option[Seq[modeldb.FeatureImportanceComparison]], Option[modeldb.ResourceNotFoundException], Option[modeldb.IllegalOperationException], Option[modeldb.ServerLogicException]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
    
      def this(
        success: _root_.scala.Option[Seq[modeldb.FeatureImportanceComparison]] = _root_.scala.None,
        rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException] = _root_.scala.None,
        ioEx: _root_.scala.Option[modeldb.IllegalOperationException] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ) = this(
        success,
        rnfEx,
        ioEx,
        svEx,
        Map.empty
      )
    
      def _1: _root_.scala.Option[Seq[modeldb.FeatureImportanceComparison]] = success
      def _2: _root_.scala.Option[modeldb.ResourceNotFoundException] = rnfEx
      def _3: _root_.scala.Option[modeldb.IllegalOperationException] = ioEx
      def _4: _root_.scala.Option[modeldb.ServerLogicException] = svEx
    
      def toTuple: _root_.scala.Tuple4[Option[Seq[modeldb.FeatureImportanceComparison]], Option[modeldb.ResourceNotFoundException], Option[modeldb.IllegalOperationException], Option[modeldb.ServerLogicException]] = {
        (
          success,
          rnfEx,
          ioEx,
          svEx
        )
      }
    
      def successField: Option[Seq[modeldb.FeatureImportanceComparison]] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Seq(rnfEx, ioEx, svEx)
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (rnfEx.isDefined) writeRnfExField(rnfEx.get, _oprot)
        if (ioEx.isDefined) writeIoExField(ioEx.get, _oprot)
        if (svEx.isDefined) writeSvExField(svEx.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[Seq[modeldb.FeatureImportanceComparison]] = this.success,
        rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException] = this.rnfEx,
        ioEx: _root_.scala.Option[modeldb.IllegalOperationException] = this.ioEx,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = this.svEx,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          rnfEx,
          ioEx,
          svEx,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 4
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case 1 => this.rnfEx
        case 2 => this.ioEx
        case 3 => this.svEx
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Function1[Args,Future[Seq[modeldb.FeatureImportanceComparison]]]
    type ReqRepFunctionType = Function1[_root_.com.twitter.scrooge.Request[Args],Future[_root_.com.twitter.scrooge.Response[Seq[modeldb.FeatureImportanceComparison]]]]

    type ServiceIfaceServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ReqRepServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]]

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]] { request: _root_.com.twitter.scrooge.Request[Args] =>
        f(request)
      }

    private[this] val toResult = (res: SuccessType) => Result(Some(res))

    val name: String = "compareLinearModelFeatureImportances"
    val serviceName: String = "ModelDBService"
    val argsCodec = Args
    val responseCodec = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val compareLinearModelFeatureImportances$args = CompareLinearModelFeatureImportances.Args
  type compareLinearModelFeatureImportances$args = CompareLinearModelFeatureImportances.Args

  val compareLinearModelFeatureImportances$result = CompareLinearModelFeatureImportances.Result
  type compareLinearModelFeatureImportances$result = CompareLinearModelFeatureImportances.Result

  object IterationsUntilConvergence extends ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("iterationsUntilConvergence_args")
      val ModelIdsField: TField = new TField("modelIds", TType.LIST, 1)
      val ModelIdsFieldManifest: Manifest[Seq[Int]] = implicitly[Manifest[Seq[Int]]]
      val ToleranceField: TField = new TField("tolerance", TType.DOUBLE, 2)
      val ToleranceFieldManifest: Manifest[Double] = implicitly[Manifest[Double]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          ModelIdsField,
          false,
          false,
          ModelIdsFieldManifest,
          _root_.scala.None,
          _root_.scala.Some(implicitly[Manifest[Int]]),
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          ToleranceField,
          false,
          false,
          ToleranceFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.modelIds)
        buf ++= validateField(item.tolerance)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          modelIds =
            {
              val field = original.modelIds
              field.map { field =>
                field
              }
            },
          tolerance =
            {
              val field = original.tolerance
              field
            }
        )
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var modelIds: Seq[Int] = Seq[Int]()
        var tolerance: Double = 0.0
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.LIST =>
                    modelIds = readModelIdsValue(_iprot)
                  case _actualType =>
                    val _expectedType = TType.LIST
                    throw new TProtocolException(
                      "Received wrong type for field 'modelIds' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 2 =>
                _field.`type` match {
                  case TType.DOUBLE =>
                    tolerance = readToleranceValue(_iprot)
                  case _actualType =>
                    val _expectedType = TType.DOUBLE
                    throw new TProtocolException(
                      "Received wrong type for field 'tolerance' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Args(
          modelIds,
          tolerance,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        modelIds: Seq[Int] = Seq[Int](),
        tolerance: Double
      ): Args =
        new Args(
          modelIds,
          tolerance
        )
    
      def unapply(_item: Args): _root_.scala.Option[_root_.scala.Tuple2[Seq[Int], Double]] = _root_.scala.Some(_item.toTuple)
    
    
      @inline private[modeldb] def readModelIdsValue(_iprot: TProtocol): Seq[Int] = {
        val _list = _iprot.readListBegin()
        if (_list.size == 0) {
          _iprot.readListEnd()
          Nil
        } else {
          val _rv = new mutable$ArrayBuffer[Int](_list.size)
          var _i = 0
          while (_i < _list.size) {
            _rv += {
              _iprot.readI32()
            }
            _i += 1
          }
          _iprot.readListEnd()
          _rv
        }
      }
    
      @inline private def writeModelIdsField(modelIds_item: Seq[Int], _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(ModelIdsField)
        writeModelIdsValue(modelIds_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeModelIdsValue(modelIds_item: Seq[Int], _oprot: TProtocol): Unit = {
        _oprot.writeListBegin(new TList(TType.I32, modelIds_item.size))
        modelIds_item match {
          case _: IndexedSeq[_] =>
            var _i = 0
            val _size = modelIds_item.size
            while (_i < _size) {
              val modelIds_item_element = modelIds_item(_i)
              _oprot.writeI32(modelIds_item_element)
              _i += 1
            }
          case _ =>
            modelIds_item.foreach { modelIds_item_element =>
              _oprot.writeI32(modelIds_item_element)
            }
        }
        _oprot.writeListEnd()
      }
    
      @inline private[modeldb] def readToleranceValue(_iprot: TProtocol): Double = {
        _iprot.readDouble()
      }
    
      @inline private def writeToleranceField(tolerance_item: Double, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(ToleranceField)
        writeToleranceValue(tolerance_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeToleranceValue(tolerance_item: Double, _oprot: TProtocol): Unit = {
        _oprot.writeDouble(tolerance_item)
      }
    
    
    }
    
    class Args(
        val modelIds: Seq[Int],
        val tolerance: Double,
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product2[Seq[Int], Double]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
    
      def this(
        modelIds: Seq[Int] = Seq[Int](),
        tolerance: Double
      ) = this(
        modelIds,
        tolerance,
        Map.empty
      )
    
      def _1: Seq[Int] = modelIds
      def _2: Double = tolerance
    
      def toTuple: _root_.scala.Tuple2[Seq[Int], Double] = {
        (
          modelIds,
          tolerance
        )
      }
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        if (modelIds ne null) writeModelIdsField(modelIds, _oprot)
        writeToleranceField(tolerance, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        modelIds: Seq[Int] = this.modelIds,
        tolerance: Double = this.tolerance,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          modelIds,
          tolerance,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 2
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.modelIds
        case 1 => this.tolerance
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    }

    type SuccessType = Seq[Int]
    
    object Result extends ValidatingThriftStructCodec3[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("iterationsUntilConvergence_result")
      val SuccessField: TField = new TField("success", TType.LIST, 0)
      val SuccessFieldManifest: Manifest[Seq[Int]] = implicitly[Manifest[Seq[Int]]]
      val SvExField: TField = new TField("svEx", TType.STRUCT, 1)
      val SvExFieldManifest: Manifest[modeldb.ServerLogicException] = implicitly[Manifest[modeldb.ServerLogicException]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.Some(implicitly[Manifest[Int]]),
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          SvExField,
          true,
          false,
          SvExFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf ++= validateField(item.svEx)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                field.map { field =>
                  field
                }
              }
            },
          svEx =
            {
              val field = original.svEx
              field.map { field =>
                modeldb.ServerLogicException.withoutPassthroughFields(field)
              }
            }
        )
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[Seq[Int]] = _root_.scala.None
        var svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.LIST =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.LIST
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 1 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    svEx = _root_.scala.Some(readSvExValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'svEx' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          svEx,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[Seq[Int]] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ): Result =
        new Result(
          success,
          svEx
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Tuple2[Option[Seq[Int]], Option[modeldb.ServerLogicException]]] = _root_.scala.Some(_item.toTuple)
    
    
      @inline private[modeldb] def readSuccessValue(_iprot: TProtocol): Seq[Int] = {
        val _list = _iprot.readListBegin()
        if (_list.size == 0) {
          _iprot.readListEnd()
          Nil
        } else {
          val _rv = new mutable$ArrayBuffer[Int](_list.size)
          var _i = 0
          while (_i < _list.size) {
            _rv += {
              _iprot.readI32()
            }
            _i += 1
          }
          _iprot.readListEnd()
          _rv
        }
      }
    
      @inline private def writeSuccessField(success_item: Seq[Int], _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: Seq[Int], _oprot: TProtocol): Unit = {
        _oprot.writeListBegin(new TList(TType.I32, success_item.size))
        success_item match {
          case _: IndexedSeq[_] =>
            var _i = 0
            val _size = success_item.size
            while (_i < _size) {
              val success_item_element = success_item(_i)
              _oprot.writeI32(success_item_element)
              _i += 1
            }
          case _ =>
            success_item.foreach { success_item_element =>
              _oprot.writeI32(success_item_element)
            }
        }
        _oprot.writeListEnd()
      }
    
      @inline private[modeldb] def readSvExValue(_iprot: TProtocol): modeldb.ServerLogicException = {
        modeldb.ServerLogicException.decode(_iprot)
      }
    
      @inline private def writeSvExField(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SvExField)
        writeSvExValue(svEx_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSvExValue(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        svEx_item.write(_oprot)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[Seq[Int]],
        val svEx: _root_.scala.Option[modeldb.ServerLogicException],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[Seq[Int]] with ThriftStruct
      with _root_.scala.Product2[Option[Seq[Int]], Option[modeldb.ServerLogicException]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
    
      def this(
        success: _root_.scala.Option[Seq[Int]] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ) = this(
        success,
        svEx,
        Map.empty
      )
    
      def _1: _root_.scala.Option[Seq[Int]] = success
      def _2: _root_.scala.Option[modeldb.ServerLogicException] = svEx
    
      def toTuple: _root_.scala.Tuple2[Option[Seq[Int]], Option[modeldb.ServerLogicException]] = {
        (
          success,
          svEx
        )
      }
    
      def successField: Option[Seq[Int]] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Seq(svEx)
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (svEx.isDefined) writeSvExField(svEx.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[Seq[Int]] = this.success,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = this.svEx,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          svEx,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 2
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case 1 => this.svEx
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Function1[Args,Future[Seq[Int]]]
    type ReqRepFunctionType = Function1[_root_.com.twitter.scrooge.Request[Args],Future[_root_.com.twitter.scrooge.Response[Seq[Int]]]]

    type ServiceIfaceServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ReqRepServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]]

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]] { request: _root_.com.twitter.scrooge.Request[Args] =>
        f(request)
      }

    private[this] val toResult = (res: SuccessType) => Result(Some(res))

    val name: String = "iterationsUntilConvergence"
    val serviceName: String = "ModelDBService"
    val argsCodec = Args
    val responseCodec = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val iterationsUntilConvergence$args = IterationsUntilConvergence.Args
  type iterationsUntilConvergence$args = IterationsUntilConvergence.Args

  val iterationsUntilConvergence$result = IterationsUntilConvergence.Result
  type iterationsUntilConvergence$result = IterationsUntilConvergence.Result

  object RankModels extends ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("rankModels_args")
      val ModelIdsField: TField = new TField("modelIds", TType.LIST, 1)
      val ModelIdsFieldManifest: Manifest[Seq[Int]] = implicitly[Manifest[Seq[Int]]]
      val MetricField: TField = new TField("metric", TType.ENUM, 2)
      val MetricFieldI32: TField = new TField("metric", TType.I32, 2)
      val MetricFieldManifest: Manifest[modeldb.ModelRankMetric] = implicitly[Manifest[modeldb.ModelRankMetric]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          ModelIdsField,
          false,
          false,
          ModelIdsFieldManifest,
          _root_.scala.None,
          _root_.scala.Some(implicitly[Manifest[Int]]),
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          MetricField,
          false,
          false,
          MetricFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.modelIds)
        buf ++= validateField(item.metric)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          modelIds =
            {
              val field = original.modelIds
              field.map { field =>
                field
              }
            },
          metric =
            {
              val field = original.metric
              field
            }
        )
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var modelIds: Seq[Int] = Seq[Int]()
        var metric: modeldb.ModelRankMetric = null
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.LIST =>
                    modelIds = readModelIdsValue(_iprot)
                  case _actualType =>
                    val _expectedType = TType.LIST
                    throw new TProtocolException(
                      "Received wrong type for field 'modelIds' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 2 =>
                _field.`type` match {
                  case TType.I32 | TType.ENUM =>
                    metric = readMetricValue(_iprot)
                  case _actualType =>
                    val _expectedType = TType.ENUM
                    throw new TProtocolException(
                      "Received wrong type for field 'metric' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Args(
          modelIds,
          metric,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        modelIds: Seq[Int] = Seq[Int](),
        metric: modeldb.ModelRankMetric
      ): Args =
        new Args(
          modelIds,
          metric
        )
    
      def unapply(_item: Args): _root_.scala.Option[_root_.scala.Tuple2[Seq[Int], modeldb.ModelRankMetric]] = _root_.scala.Some(_item.toTuple)
    
    
      @inline private[modeldb] def readModelIdsValue(_iprot: TProtocol): Seq[Int] = {
        val _list = _iprot.readListBegin()
        if (_list.size == 0) {
          _iprot.readListEnd()
          Nil
        } else {
          val _rv = new mutable$ArrayBuffer[Int](_list.size)
          var _i = 0
          while (_i < _list.size) {
            _rv += {
              _iprot.readI32()
            }
            _i += 1
          }
          _iprot.readListEnd()
          _rv
        }
      }
    
      @inline private def writeModelIdsField(modelIds_item: Seq[Int], _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(ModelIdsField)
        writeModelIdsValue(modelIds_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeModelIdsValue(modelIds_item: Seq[Int], _oprot: TProtocol): Unit = {
        _oprot.writeListBegin(new TList(TType.I32, modelIds_item.size))
        modelIds_item match {
          case _: IndexedSeq[_] =>
            var _i = 0
            val _size = modelIds_item.size
            while (_i < _size) {
              val modelIds_item_element = modelIds_item(_i)
              _oprot.writeI32(modelIds_item_element)
              _i += 1
            }
          case _ =>
            modelIds_item.foreach { modelIds_item_element =>
              _oprot.writeI32(modelIds_item_element)
            }
        }
        _oprot.writeListEnd()
      }
    
      @inline private[modeldb] def readMetricValue(_iprot: TProtocol): modeldb.ModelRankMetric = {
        modeldb.ModelRankMetric.getOrUnknown(_iprot.readI32())
      }
    
      @inline private def writeMetricField(metric_item: modeldb.ModelRankMetric, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(MetricFieldI32)
        writeMetricValue(metric_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeMetricValue(metric_item: modeldb.ModelRankMetric, _oprot: TProtocol): Unit = {
        _oprot.writeI32(metric_item.value)
      }
    
    
    }
    
    class Args(
        val modelIds: Seq[Int],
        val metric: modeldb.ModelRankMetric,
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product2[Seq[Int], modeldb.ModelRankMetric]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
    
      def this(
        modelIds: Seq[Int] = Seq[Int](),
        metric: modeldb.ModelRankMetric
      ) = this(
        modelIds,
        metric,
        Map.empty
      )
    
      def _1: Seq[Int] = modelIds
      def _2: modeldb.ModelRankMetric = metric
    
      def toTuple: _root_.scala.Tuple2[Seq[Int], modeldb.ModelRankMetric] = {
        (
          modelIds,
          metric
        )
      }
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        if (modelIds ne null) writeModelIdsField(modelIds, _oprot)
        if (metric ne null) writeMetricField(metric, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        modelIds: Seq[Int] = this.modelIds,
        metric: modeldb.ModelRankMetric = this.metric,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          modelIds,
          metric,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 2
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.modelIds
        case 1 => this.metric
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    }

    type SuccessType = Seq[Int]
    
    object Result extends ValidatingThriftStructCodec3[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("rankModels_result")
      val SuccessField: TField = new TField("success", TType.LIST, 0)
      val SuccessFieldManifest: Manifest[Seq[Int]] = implicitly[Manifest[Seq[Int]]]
      val SvExField: TField = new TField("svEx", TType.STRUCT, 1)
      val SvExFieldManifest: Manifest[modeldb.ServerLogicException] = implicitly[Manifest[modeldb.ServerLogicException]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.Some(implicitly[Manifest[Int]]),
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          SvExField,
          true,
          false,
          SvExFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf ++= validateField(item.svEx)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                field.map { field =>
                  field
                }
              }
            },
          svEx =
            {
              val field = original.svEx
              field.map { field =>
                modeldb.ServerLogicException.withoutPassthroughFields(field)
              }
            }
        )
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[Seq[Int]] = _root_.scala.None
        var svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.LIST =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.LIST
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 1 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    svEx = _root_.scala.Some(readSvExValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'svEx' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          svEx,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[Seq[Int]] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ): Result =
        new Result(
          success,
          svEx
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Tuple2[Option[Seq[Int]], Option[modeldb.ServerLogicException]]] = _root_.scala.Some(_item.toTuple)
    
    
      @inline private[modeldb] def readSuccessValue(_iprot: TProtocol): Seq[Int] = {
        val _list = _iprot.readListBegin()
        if (_list.size == 0) {
          _iprot.readListEnd()
          Nil
        } else {
          val _rv = new mutable$ArrayBuffer[Int](_list.size)
          var _i = 0
          while (_i < _list.size) {
            _rv += {
              _iprot.readI32()
            }
            _i += 1
          }
          _iprot.readListEnd()
          _rv
        }
      }
    
      @inline private def writeSuccessField(success_item: Seq[Int], _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: Seq[Int], _oprot: TProtocol): Unit = {
        _oprot.writeListBegin(new TList(TType.I32, success_item.size))
        success_item match {
          case _: IndexedSeq[_] =>
            var _i = 0
            val _size = success_item.size
            while (_i < _size) {
              val success_item_element = success_item(_i)
              _oprot.writeI32(success_item_element)
              _i += 1
            }
          case _ =>
            success_item.foreach { success_item_element =>
              _oprot.writeI32(success_item_element)
            }
        }
        _oprot.writeListEnd()
      }
    
      @inline private[modeldb] def readSvExValue(_iprot: TProtocol): modeldb.ServerLogicException = {
        modeldb.ServerLogicException.decode(_iprot)
      }
    
      @inline private def writeSvExField(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SvExField)
        writeSvExValue(svEx_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSvExValue(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        svEx_item.write(_oprot)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[Seq[Int]],
        val svEx: _root_.scala.Option[modeldb.ServerLogicException],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[Seq[Int]] with ThriftStruct
      with _root_.scala.Product2[Option[Seq[Int]], Option[modeldb.ServerLogicException]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
    
      def this(
        success: _root_.scala.Option[Seq[Int]] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ) = this(
        success,
        svEx,
        Map.empty
      )
    
      def _1: _root_.scala.Option[Seq[Int]] = success
      def _2: _root_.scala.Option[modeldb.ServerLogicException] = svEx
    
      def toTuple: _root_.scala.Tuple2[Option[Seq[Int]], Option[modeldb.ServerLogicException]] = {
        (
          success,
          svEx
        )
      }
    
      def successField: Option[Seq[Int]] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Seq(svEx)
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (svEx.isDefined) writeSvExField(svEx.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[Seq[Int]] = this.success,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = this.svEx,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          svEx,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 2
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case 1 => this.svEx
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Function1[Args,Future[Seq[Int]]]
    type ReqRepFunctionType = Function1[_root_.com.twitter.scrooge.Request[Args],Future[_root_.com.twitter.scrooge.Response[Seq[Int]]]]

    type ServiceIfaceServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ReqRepServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]]

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]] { request: _root_.com.twitter.scrooge.Request[Args] =>
        f(request)
      }

    private[this] val toResult = (res: SuccessType) => Result(Some(res))

    val name: String = "rankModels"
    val serviceName: String = "ModelDBService"
    val argsCodec = Args
    val responseCodec = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val rankModels$args = RankModels.Args
  type rankModels$args = RankModels.Args

  val rankModels$result = RankModels.Result
  type rankModels$result = RankModels.Result

  object ConfidenceIntervals extends ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("confidenceIntervals_args")
      val ModelIdField: TField = new TField("modelId", TType.I32, 1)
      val ModelIdFieldManifest: Manifest[Int] = implicitly[Manifest[Int]]
      val SigLevelField: TField = new TField("sigLevel", TType.DOUBLE, 2)
      val SigLevelFieldManifest: Manifest[Double] = implicitly[Manifest[Double]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          ModelIdField,
          false,
          false,
          ModelIdFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          SigLevelField,
          false,
          false,
          SigLevelFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.modelId)
        buf ++= validateField(item.sigLevel)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          modelId =
            {
              val field = original.modelId
              field
            },
          sigLevel =
            {
              val field = original.sigLevel
              field
            }
        )
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var modelId: Int = 0
        var sigLevel: Double = 0.0
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.I32 =>
                    modelId = readModelIdValue(_iprot)
                  case _actualType =>
                    val _expectedType = TType.I32
                    throw new TProtocolException(
                      "Received wrong type for field 'modelId' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 2 =>
                _field.`type` match {
                  case TType.DOUBLE =>
                    sigLevel = readSigLevelValue(_iprot)
                  case _actualType =>
                    val _expectedType = TType.DOUBLE
                    throw new TProtocolException(
                      "Received wrong type for field 'sigLevel' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Args(
          modelId,
          sigLevel,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        modelId: Int,
        sigLevel: Double
      ): Args =
        new Args(
          modelId,
          sigLevel
        )
    
      def unapply(_item: Args): _root_.scala.Option[_root_.scala.Tuple2[Int, Double]] = _root_.scala.Some(_item.toTuple)
    
    
      @inline private[modeldb] def readModelIdValue(_iprot: TProtocol): Int = {
        _iprot.readI32()
      }
    
      @inline private def writeModelIdField(modelId_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(ModelIdField)
        writeModelIdValue(modelId_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeModelIdValue(modelId_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeI32(modelId_item)
      }
    
      @inline private[modeldb] def readSigLevelValue(_iprot: TProtocol): Double = {
        _iprot.readDouble()
      }
    
      @inline private def writeSigLevelField(sigLevel_item: Double, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SigLevelField)
        writeSigLevelValue(sigLevel_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSigLevelValue(sigLevel_item: Double, _oprot: TProtocol): Unit = {
        _oprot.writeDouble(sigLevel_item)
      }
    
    
    }
    
    class Args(
        val modelId: Int,
        val sigLevel: Double,
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product2[Int, Double]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
    
      def this(
        modelId: Int,
        sigLevel: Double
      ) = this(
        modelId,
        sigLevel,
        Map.empty
      )
    
      def _1: Int = modelId
      def _2: Double = sigLevel
    
      def toTuple: _root_.scala.Tuple2[Int, Double] = {
        (
          modelId,
          sigLevel
        )
      }
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        writeModelIdField(modelId, _oprot)
        writeSigLevelField(sigLevel, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        modelId: Int = this.modelId,
        sigLevel: Double = this.sigLevel,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          modelId,
          sigLevel,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 2
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.modelId
        case 1 => this.sigLevel
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    }

    type SuccessType = Seq[modeldb.ConfidenceInterval]
    
    object Result extends ValidatingThriftStructCodec3[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("confidenceIntervals_result")
      val SuccessField: TField = new TField("success", TType.LIST, 0)
      val SuccessFieldManifest: Manifest[Seq[modeldb.ConfidenceInterval]] = implicitly[Manifest[Seq[modeldb.ConfidenceInterval]]]
      val RnfExField: TField = new TField("rnfEx", TType.STRUCT, 1)
      val RnfExFieldManifest: Manifest[modeldb.ResourceNotFoundException] = implicitly[Manifest[modeldb.ResourceNotFoundException]]
      val IoExField: TField = new TField("ioEx", TType.STRUCT, 2)
      val IoExFieldManifest: Manifest[modeldb.IllegalOperationException] = implicitly[Manifest[modeldb.IllegalOperationException]]
      val BrExField: TField = new TField("brEx", TType.STRUCT, 3)
      val BrExFieldManifest: Manifest[modeldb.BadRequestException] = implicitly[Manifest[modeldb.BadRequestException]]
      val SvExField: TField = new TField("svEx", TType.STRUCT, 4)
      val SvExFieldManifest: Manifest[modeldb.ServerLogicException] = implicitly[Manifest[modeldb.ServerLogicException]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.Some(implicitly[Manifest[modeldb.ConfidenceInterval]]),
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          RnfExField,
          true,
          false,
          RnfExFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          IoExField,
          true,
          false,
          IoExFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          BrExField,
          true,
          false,
          BrExFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          SvExField,
          true,
          false,
          SvExFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf ++= validateField(item.rnfEx)
        buf ++= validateField(item.ioEx)
        buf ++= validateField(item.brEx)
        buf ++= validateField(item.svEx)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                field.map { field =>
                  modeldb.ConfidenceInterval.withoutPassthroughFields(field)
                }
              }
            },
          rnfEx =
            {
              val field = original.rnfEx
              field.map { field =>
                modeldb.ResourceNotFoundException.withoutPassthroughFields(field)
              }
            },
          ioEx =
            {
              val field = original.ioEx
              field.map { field =>
                modeldb.IllegalOperationException.withoutPassthroughFields(field)
              }
            },
          brEx =
            {
              val field = original.brEx
              field.map { field =>
                modeldb.BadRequestException.withoutPassthroughFields(field)
              }
            },
          svEx =
            {
              val field = original.svEx
              field.map { field =>
                modeldb.ServerLogicException.withoutPassthroughFields(field)
              }
            }
        )
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[Seq[modeldb.ConfidenceInterval]] = _root_.scala.None
        var rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException] = _root_.scala.None
        var ioEx: _root_.scala.Option[modeldb.IllegalOperationException] = _root_.scala.None
        var brEx: _root_.scala.Option[modeldb.BadRequestException] = _root_.scala.None
        var svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.LIST =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.LIST
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 1 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    rnfEx = _root_.scala.Some(readRnfExValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'rnfEx' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 2 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    ioEx = _root_.scala.Some(readIoExValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'ioEx' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 3 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    brEx = _root_.scala.Some(readBrExValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'brEx' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 4 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    svEx = _root_.scala.Some(readSvExValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'svEx' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          rnfEx,
          ioEx,
          brEx,
          svEx,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[Seq[modeldb.ConfidenceInterval]] = _root_.scala.None,
        rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException] = _root_.scala.None,
        ioEx: _root_.scala.Option[modeldb.IllegalOperationException] = _root_.scala.None,
        brEx: _root_.scala.Option[modeldb.BadRequestException] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ): Result =
        new Result(
          success,
          rnfEx,
          ioEx,
          brEx,
          svEx
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Tuple5[Option[Seq[modeldb.ConfidenceInterval]], Option[modeldb.ResourceNotFoundException], Option[modeldb.IllegalOperationException], Option[modeldb.BadRequestException], Option[modeldb.ServerLogicException]]] = _root_.scala.Some(_item.toTuple)
    
    
      @inline private[modeldb] def readSuccessValue(_iprot: TProtocol): Seq[modeldb.ConfidenceInterval] = {
        val _list = _iprot.readListBegin()
        if (_list.size == 0) {
          _iprot.readListEnd()
          Nil
        } else {
          val _rv = new mutable$ArrayBuffer[modeldb.ConfidenceInterval](_list.size)
          var _i = 0
          while (_i < _list.size) {
            _rv += {
              modeldb.ConfidenceInterval.decode(_iprot)
            }
            _i += 1
          }
          _iprot.readListEnd()
          _rv
        }
      }
    
      @inline private def writeSuccessField(success_item: Seq[modeldb.ConfidenceInterval], _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: Seq[modeldb.ConfidenceInterval], _oprot: TProtocol): Unit = {
        _oprot.writeListBegin(new TList(TType.STRUCT, success_item.size))
        success_item match {
          case _: IndexedSeq[_] =>
            var _i = 0
            val _size = success_item.size
            while (_i < _size) {
              val success_item_element = success_item(_i)
              success_item_element.write(_oprot)
              _i += 1
            }
          case _ =>
            success_item.foreach { success_item_element =>
              success_item_element.write(_oprot)
            }
        }
        _oprot.writeListEnd()
      }
    
      @inline private[modeldb] def readRnfExValue(_iprot: TProtocol): modeldb.ResourceNotFoundException = {
        modeldb.ResourceNotFoundException.decode(_iprot)
      }
    
      @inline private def writeRnfExField(rnfEx_item: modeldb.ResourceNotFoundException, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(RnfExField)
        writeRnfExValue(rnfEx_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeRnfExValue(rnfEx_item: modeldb.ResourceNotFoundException, _oprot: TProtocol): Unit = {
        rnfEx_item.write(_oprot)
      }
    
      @inline private[modeldb] def readIoExValue(_iprot: TProtocol): modeldb.IllegalOperationException = {
        modeldb.IllegalOperationException.decode(_iprot)
      }
    
      @inline private def writeIoExField(ioEx_item: modeldb.IllegalOperationException, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(IoExField)
        writeIoExValue(ioEx_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeIoExValue(ioEx_item: modeldb.IllegalOperationException, _oprot: TProtocol): Unit = {
        ioEx_item.write(_oprot)
      }
    
      @inline private[modeldb] def readBrExValue(_iprot: TProtocol): modeldb.BadRequestException = {
        modeldb.BadRequestException.decode(_iprot)
      }
    
      @inline private def writeBrExField(brEx_item: modeldb.BadRequestException, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(BrExField)
        writeBrExValue(brEx_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeBrExValue(brEx_item: modeldb.BadRequestException, _oprot: TProtocol): Unit = {
        brEx_item.write(_oprot)
      }
    
      @inline private[modeldb] def readSvExValue(_iprot: TProtocol): modeldb.ServerLogicException = {
        modeldb.ServerLogicException.decode(_iprot)
      }
    
      @inline private def writeSvExField(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SvExField)
        writeSvExValue(svEx_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSvExValue(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        svEx_item.write(_oprot)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[Seq[modeldb.ConfidenceInterval]],
        val rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException],
        val ioEx: _root_.scala.Option[modeldb.IllegalOperationException],
        val brEx: _root_.scala.Option[modeldb.BadRequestException],
        val svEx: _root_.scala.Option[modeldb.ServerLogicException],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[Seq[modeldb.ConfidenceInterval]] with ThriftStruct
      with _root_.scala.Product5[Option[Seq[modeldb.ConfidenceInterval]], Option[modeldb.ResourceNotFoundException], Option[modeldb.IllegalOperationException], Option[modeldb.BadRequestException], Option[modeldb.ServerLogicException]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
    
      def this(
        success: _root_.scala.Option[Seq[modeldb.ConfidenceInterval]] = _root_.scala.None,
        rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException] = _root_.scala.None,
        ioEx: _root_.scala.Option[modeldb.IllegalOperationException] = _root_.scala.None,
        brEx: _root_.scala.Option[modeldb.BadRequestException] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ) = this(
        success,
        rnfEx,
        ioEx,
        brEx,
        svEx,
        Map.empty
      )
    
      def _1: _root_.scala.Option[Seq[modeldb.ConfidenceInterval]] = success
      def _2: _root_.scala.Option[modeldb.ResourceNotFoundException] = rnfEx
      def _3: _root_.scala.Option[modeldb.IllegalOperationException] = ioEx
      def _4: _root_.scala.Option[modeldb.BadRequestException] = brEx
      def _5: _root_.scala.Option[modeldb.ServerLogicException] = svEx
    
      def toTuple: _root_.scala.Tuple5[Option[Seq[modeldb.ConfidenceInterval]], Option[modeldb.ResourceNotFoundException], Option[modeldb.IllegalOperationException], Option[modeldb.BadRequestException], Option[modeldb.ServerLogicException]] = {
        (
          success,
          rnfEx,
          ioEx,
          brEx,
          svEx
        )
      }
    
      def successField: Option[Seq[modeldb.ConfidenceInterval]] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Seq(rnfEx, ioEx, brEx, svEx)
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (rnfEx.isDefined) writeRnfExField(rnfEx.get, _oprot)
        if (ioEx.isDefined) writeIoExField(ioEx.get, _oprot)
        if (brEx.isDefined) writeBrExField(brEx.get, _oprot)
        if (svEx.isDefined) writeSvExField(svEx.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[Seq[modeldb.ConfidenceInterval]] = this.success,
        rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException] = this.rnfEx,
        ioEx: _root_.scala.Option[modeldb.IllegalOperationException] = this.ioEx,
        brEx: _root_.scala.Option[modeldb.BadRequestException] = this.brEx,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = this.svEx,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          rnfEx,
          ioEx,
          brEx,
          svEx,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 5
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case 1 => this.rnfEx
        case 2 => this.ioEx
        case 3 => this.brEx
        case 4 => this.svEx
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Function1[Args,Future[Seq[modeldb.ConfidenceInterval]]]
    type ReqRepFunctionType = Function1[_root_.com.twitter.scrooge.Request[Args],Future[_root_.com.twitter.scrooge.Response[Seq[modeldb.ConfidenceInterval]]]]

    type ServiceIfaceServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ReqRepServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]]

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]] { request: _root_.com.twitter.scrooge.Request[Args] =>
        f(request)
      }

    private[this] val toResult = (res: SuccessType) => Result(Some(res))

    val name: String = "confidenceIntervals"
    val serviceName: String = "ModelDBService"
    val argsCodec = Args
    val responseCodec = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val confidenceIntervals$args = ConfidenceIntervals.Args
  type confidenceIntervals$args = ConfidenceIntervals.Args

  val confidenceIntervals$result = ConfidenceIntervals.Result
  type confidenceIntervals$result = ConfidenceIntervals.Result

  object ModelsWithFeatures extends ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("modelsWithFeatures_args")
      val FeatureNamesField: TField = new TField("featureNames", TType.LIST, 1)
      val FeatureNamesFieldManifest: Manifest[Seq[String]] = implicitly[Manifest[Seq[String]]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          FeatureNamesField,
          false,
          false,
          FeatureNamesFieldManifest,
          _root_.scala.None,
          _root_.scala.Some(implicitly[Manifest[String]]),
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.featureNames)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          featureNames =
            {
              val field = original.featureNames
              field.map { field =>
                field
              }
            }
        )
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var featureNames: Seq[String] = Seq[String]()
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.LIST =>
                    featureNames = readFeatureNamesValue(_iprot)
                  case _actualType =>
                    val _expectedType = TType.LIST
                    throw new TProtocolException(
                      "Received wrong type for field 'featureNames' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Args(
          featureNames,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        featureNames: Seq[String] = Seq[String]()
      ): Args =
        new Args(
          featureNames
        )
    
      def unapply(_item: Args): _root_.scala.Option[Seq[String]] = _root_.scala.Some(_item.featureNames)
    
    
      @inline private[modeldb] def readFeatureNamesValue(_iprot: TProtocol): Seq[String] = {
        val _list = _iprot.readListBegin()
        if (_list.size == 0) {
          _iprot.readListEnd()
          Nil
        } else {
          val _rv = new mutable$ArrayBuffer[String](_list.size)
          var _i = 0
          while (_i < _list.size) {
            _rv += {
              _iprot.readString()
            }
            _i += 1
          }
          _iprot.readListEnd()
          _rv
        }
      }
    
      @inline private def writeFeatureNamesField(featureNames_item: Seq[String], _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(FeatureNamesField)
        writeFeatureNamesValue(featureNames_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeFeatureNamesValue(featureNames_item: Seq[String], _oprot: TProtocol): Unit = {
        _oprot.writeListBegin(new TList(TType.STRING, featureNames_item.size))
        featureNames_item match {
          case _: IndexedSeq[_] =>
            var _i = 0
            val _size = featureNames_item.size
            while (_i < _size) {
              val featureNames_item_element = featureNames_item(_i)
              _oprot.writeString(featureNames_item_element)
              _i += 1
            }
          case _ =>
            featureNames_item.foreach { featureNames_item_element =>
              _oprot.writeString(featureNames_item_element)
            }
        }
        _oprot.writeListEnd()
      }
    
    
    }
    
    class Args(
        val featureNames: Seq[String],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product1[Seq[String]]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
    
      def this(
        featureNames: Seq[String] = Seq[String]()
      ) = this(
        featureNames,
        Map.empty
      )
    
      def _1: Seq[String] = featureNames
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        if (featureNames ne null) writeFeatureNamesField(featureNames, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        featureNames: Seq[String] = this.featureNames,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          featureNames,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.featureNames
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    }

    type SuccessType = Seq[Int]
    
    object Result extends ValidatingThriftStructCodec3[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("modelsWithFeatures_result")
      val SuccessField: TField = new TField("success", TType.LIST, 0)
      val SuccessFieldManifest: Manifest[Seq[Int]] = implicitly[Manifest[Seq[Int]]]
      val SvExField: TField = new TField("svEx", TType.STRUCT, 1)
      val SvExFieldManifest: Manifest[modeldb.ServerLogicException] = implicitly[Manifest[modeldb.ServerLogicException]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.Some(implicitly[Manifest[Int]]),
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          SvExField,
          true,
          false,
          SvExFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf ++= validateField(item.svEx)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                field.map { field =>
                  field
                }
              }
            },
          svEx =
            {
              val field = original.svEx
              field.map { field =>
                modeldb.ServerLogicException.withoutPassthroughFields(field)
              }
            }
        )
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[Seq[Int]] = _root_.scala.None
        var svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.LIST =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.LIST
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 1 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    svEx = _root_.scala.Some(readSvExValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'svEx' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          svEx,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[Seq[Int]] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ): Result =
        new Result(
          success,
          svEx
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Tuple2[Option[Seq[Int]], Option[modeldb.ServerLogicException]]] = _root_.scala.Some(_item.toTuple)
    
    
      @inline private[modeldb] def readSuccessValue(_iprot: TProtocol): Seq[Int] = {
        val _list = _iprot.readListBegin()
        if (_list.size == 0) {
          _iprot.readListEnd()
          Nil
        } else {
          val _rv = new mutable$ArrayBuffer[Int](_list.size)
          var _i = 0
          while (_i < _list.size) {
            _rv += {
              _iprot.readI32()
            }
            _i += 1
          }
          _iprot.readListEnd()
          _rv
        }
      }
    
      @inline private def writeSuccessField(success_item: Seq[Int], _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: Seq[Int], _oprot: TProtocol): Unit = {
        _oprot.writeListBegin(new TList(TType.I32, success_item.size))
        success_item match {
          case _: IndexedSeq[_] =>
            var _i = 0
            val _size = success_item.size
            while (_i < _size) {
              val success_item_element = success_item(_i)
              _oprot.writeI32(success_item_element)
              _i += 1
            }
          case _ =>
            success_item.foreach { success_item_element =>
              _oprot.writeI32(success_item_element)
            }
        }
        _oprot.writeListEnd()
      }
    
      @inline private[modeldb] def readSvExValue(_iprot: TProtocol): modeldb.ServerLogicException = {
        modeldb.ServerLogicException.decode(_iprot)
      }
    
      @inline private def writeSvExField(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SvExField)
        writeSvExValue(svEx_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSvExValue(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        svEx_item.write(_oprot)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[Seq[Int]],
        val svEx: _root_.scala.Option[modeldb.ServerLogicException],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[Seq[Int]] with ThriftStruct
      with _root_.scala.Product2[Option[Seq[Int]], Option[modeldb.ServerLogicException]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
    
      def this(
        success: _root_.scala.Option[Seq[Int]] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ) = this(
        success,
        svEx,
        Map.empty
      )
    
      def _1: _root_.scala.Option[Seq[Int]] = success
      def _2: _root_.scala.Option[modeldb.ServerLogicException] = svEx
    
      def toTuple: _root_.scala.Tuple2[Option[Seq[Int]], Option[modeldb.ServerLogicException]] = {
        (
          success,
          svEx
        )
      }
    
      def successField: Option[Seq[Int]] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Seq(svEx)
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (svEx.isDefined) writeSvExField(svEx.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[Seq[Int]] = this.success,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = this.svEx,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          svEx,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 2
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case 1 => this.svEx
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Function1[Args,Future[Seq[Int]]]
    type ReqRepFunctionType = Function1[_root_.com.twitter.scrooge.Request[Args],Future[_root_.com.twitter.scrooge.Response[Seq[Int]]]]

    type ServiceIfaceServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ReqRepServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]]

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]] { request: _root_.com.twitter.scrooge.Request[Args] =>
        f(request)
      }

    private[this] val toResult = (res: SuccessType) => Result(Some(res))

    val name: String = "modelsWithFeatures"
    val serviceName: String = "ModelDBService"
    val argsCodec = Args
    val responseCodec = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val modelsWithFeatures$args = ModelsWithFeatures.Args
  type modelsWithFeatures$args = ModelsWithFeatures.Args

  val modelsWithFeatures$result = ModelsWithFeatures.Result
  type modelsWithFeatures$result = ModelsWithFeatures.Result

  object ModelsDerivedFromDataFrame extends ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("modelsDerivedFromDataFrame_args")
      val DfIdField: TField = new TField("dfId", TType.I32, 1)
      val DfIdFieldManifest: Manifest[Int] = implicitly[Manifest[Int]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          DfIdField,
          false,
          false,
          DfIdFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.dfId)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          dfId =
            {
              val field = original.dfId
              field
            }
        )
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var dfId: Int = 0
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.I32 =>
                    dfId = readDfIdValue(_iprot)
                  case _actualType =>
                    val _expectedType = TType.I32
                    throw new TProtocolException(
                      "Received wrong type for field 'dfId' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Args(
          dfId,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        dfId: Int
      ): Args =
        new Args(
          dfId
        )
    
      def unapply(_item: Args): _root_.scala.Option[Int] = _root_.scala.Some(_item.dfId)
    
    
      @inline private[modeldb] def readDfIdValue(_iprot: TProtocol): Int = {
        _iprot.readI32()
      }
    
      @inline private def writeDfIdField(dfId_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(DfIdField)
        writeDfIdValue(dfId_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeDfIdValue(dfId_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeI32(dfId_item)
      }
    
    
    }
    
    class Args(
        val dfId: Int,
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product1[Int]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
    
      def this(
        dfId: Int
      ) = this(
        dfId,
        Map.empty
      )
    
      def _1: Int = dfId
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        writeDfIdField(dfId, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        dfId: Int = this.dfId,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          dfId,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.dfId
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    }

    type SuccessType = Seq[Int]
    
    object Result extends ValidatingThriftStructCodec3[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("modelsDerivedFromDataFrame_result")
      val SuccessField: TField = new TField("success", TType.LIST, 0)
      val SuccessFieldManifest: Manifest[Seq[Int]] = implicitly[Manifest[Seq[Int]]]
      val RnfExField: TField = new TField("rnfEx", TType.STRUCT, 1)
      val RnfExFieldManifest: Manifest[modeldb.ResourceNotFoundException] = implicitly[Manifest[modeldb.ResourceNotFoundException]]
      val SvExField: TField = new TField("svEx", TType.STRUCT, 2)
      val SvExFieldManifest: Manifest[modeldb.ServerLogicException] = implicitly[Manifest[modeldb.ServerLogicException]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.Some(implicitly[Manifest[Int]]),
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          RnfExField,
          true,
          false,
          RnfExFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          SvExField,
          true,
          false,
          SvExFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf ++= validateField(item.rnfEx)
        buf ++= validateField(item.svEx)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                field.map { field =>
                  field
                }
              }
            },
          rnfEx =
            {
              val field = original.rnfEx
              field.map { field =>
                modeldb.ResourceNotFoundException.withoutPassthroughFields(field)
              }
            },
          svEx =
            {
              val field = original.svEx
              field.map { field =>
                modeldb.ServerLogicException.withoutPassthroughFields(field)
              }
            }
        )
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[Seq[Int]] = _root_.scala.None
        var rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException] = _root_.scala.None
        var svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.LIST =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.LIST
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 1 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    rnfEx = _root_.scala.Some(readRnfExValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'rnfEx' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 2 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    svEx = _root_.scala.Some(readSvExValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'svEx' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          rnfEx,
          svEx,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[Seq[Int]] = _root_.scala.None,
        rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ): Result =
        new Result(
          success,
          rnfEx,
          svEx
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Tuple3[Option[Seq[Int]], Option[modeldb.ResourceNotFoundException], Option[modeldb.ServerLogicException]]] = _root_.scala.Some(_item.toTuple)
    
    
      @inline private[modeldb] def readSuccessValue(_iprot: TProtocol): Seq[Int] = {
        val _list = _iprot.readListBegin()
        if (_list.size == 0) {
          _iprot.readListEnd()
          Nil
        } else {
          val _rv = new mutable$ArrayBuffer[Int](_list.size)
          var _i = 0
          while (_i < _list.size) {
            _rv += {
              _iprot.readI32()
            }
            _i += 1
          }
          _iprot.readListEnd()
          _rv
        }
      }
    
      @inline private def writeSuccessField(success_item: Seq[Int], _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: Seq[Int], _oprot: TProtocol): Unit = {
        _oprot.writeListBegin(new TList(TType.I32, success_item.size))
        success_item match {
          case _: IndexedSeq[_] =>
            var _i = 0
            val _size = success_item.size
            while (_i < _size) {
              val success_item_element = success_item(_i)
              _oprot.writeI32(success_item_element)
              _i += 1
            }
          case _ =>
            success_item.foreach { success_item_element =>
              _oprot.writeI32(success_item_element)
            }
        }
        _oprot.writeListEnd()
      }
    
      @inline private[modeldb] def readRnfExValue(_iprot: TProtocol): modeldb.ResourceNotFoundException = {
        modeldb.ResourceNotFoundException.decode(_iprot)
      }
    
      @inline private def writeRnfExField(rnfEx_item: modeldb.ResourceNotFoundException, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(RnfExField)
        writeRnfExValue(rnfEx_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeRnfExValue(rnfEx_item: modeldb.ResourceNotFoundException, _oprot: TProtocol): Unit = {
        rnfEx_item.write(_oprot)
      }
    
      @inline private[modeldb] def readSvExValue(_iprot: TProtocol): modeldb.ServerLogicException = {
        modeldb.ServerLogicException.decode(_iprot)
      }
    
      @inline private def writeSvExField(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SvExField)
        writeSvExValue(svEx_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSvExValue(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        svEx_item.write(_oprot)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[Seq[Int]],
        val rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException],
        val svEx: _root_.scala.Option[modeldb.ServerLogicException],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[Seq[Int]] with ThriftStruct
      with _root_.scala.Product3[Option[Seq[Int]], Option[modeldb.ResourceNotFoundException], Option[modeldb.ServerLogicException]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
    
      def this(
        success: _root_.scala.Option[Seq[Int]] = _root_.scala.None,
        rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ) = this(
        success,
        rnfEx,
        svEx,
        Map.empty
      )
    
      def _1: _root_.scala.Option[Seq[Int]] = success
      def _2: _root_.scala.Option[modeldb.ResourceNotFoundException] = rnfEx
      def _3: _root_.scala.Option[modeldb.ServerLogicException] = svEx
    
      def toTuple: _root_.scala.Tuple3[Option[Seq[Int]], Option[modeldb.ResourceNotFoundException], Option[modeldb.ServerLogicException]] = {
        (
          success,
          rnfEx,
          svEx
        )
      }
    
      def successField: Option[Seq[Int]] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Seq(rnfEx, svEx)
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (rnfEx.isDefined) writeRnfExField(rnfEx.get, _oprot)
        if (svEx.isDefined) writeSvExField(svEx.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[Seq[Int]] = this.success,
        rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException] = this.rnfEx,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = this.svEx,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          rnfEx,
          svEx,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 3
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case 1 => this.rnfEx
        case 2 => this.svEx
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Function1[Args,Future[Seq[Int]]]
    type ReqRepFunctionType = Function1[_root_.com.twitter.scrooge.Request[Args],Future[_root_.com.twitter.scrooge.Response[Seq[Int]]]]

    type ServiceIfaceServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ReqRepServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]]

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]] { request: _root_.com.twitter.scrooge.Request[Args] =>
        f(request)
      }

    private[this] val toResult = (res: SuccessType) => Result(Some(res))

    val name: String = "modelsDerivedFromDataFrame"
    val serviceName: String = "ModelDBService"
    val argsCodec = Args
    val responseCodec = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val modelsDerivedFromDataFrame$args = ModelsDerivedFromDataFrame.Args
  type modelsDerivedFromDataFrame$args = ModelsDerivedFromDataFrame.Args

  val modelsDerivedFromDataFrame$result = ModelsDerivedFromDataFrame.Result
  type modelsDerivedFromDataFrame$result = ModelsDerivedFromDataFrame.Result

  object GetProjectIds extends ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("getProjectIds_args")
      val KeyValuePairsField: TField = new TField("keyValuePairs", TType.MAP, 1)
      val KeyValuePairsFieldManifest: Manifest[Map[String, String]] = implicitly[Manifest[Map[String, String]]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          KeyValuePairsField,
          false,
          false,
          KeyValuePairsFieldManifest,
          _root_.scala.Some(implicitly[Manifest[String]]),
          _root_.scala.Some(implicitly[Manifest[String]]),
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.keyValuePairs)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          keyValuePairs =
            {
              val field = original.keyValuePairs
              field.map { case (key, value) =>
                  val newKey = {
                  val field = key
                  field
                }
  
          
                  val newValue = {
                  val field = value
                  field
                }
  
          
                newKey -> newValue
              }
            }
        )
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var keyValuePairs: Map[String, String] = Map[String, String]()
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.MAP =>
                    keyValuePairs = readKeyValuePairsValue(_iprot)
                  case _actualType =>
                    val _expectedType = TType.MAP
                    throw new TProtocolException(
                      "Received wrong type for field 'keyValuePairs' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Args(
          keyValuePairs,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        keyValuePairs: Map[String, String] = Map[String, String]()
      ): Args =
        new Args(
          keyValuePairs
        )
    
      def unapply(_item: Args): _root_.scala.Option[Map[String, String]] = _root_.scala.Some(_item.keyValuePairs)
    
    
      @inline private[modeldb] def readKeyValuePairsValue(_iprot: TProtocol): Map[String, String] = {
        val _map = _iprot.readMapBegin()
        if (_map.size == 0) {
          _iprot.readMapEnd()
          Map.empty[String, String]
        } else {
          val _rv = new mutable$HashMap[String, String]
          var _i = 0
          while (_i < _map.size) {
            val _key = {
              _iprot.readString()
            }
            val _value = {
              _iprot.readString()
            }
            _rv(_key) = _value
            _i += 1
          }
          _iprot.readMapEnd()
          _rv
        }
      }
    
      @inline private def writeKeyValuePairsField(keyValuePairs_item: Map[String, String], _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(KeyValuePairsField)
        writeKeyValuePairsValue(keyValuePairs_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeKeyValuePairsValue(keyValuePairs_item: Map[String, String], _oprot: TProtocol): Unit = {
        _oprot.writeMapBegin(new TMap(TType.STRING, TType.STRING, keyValuePairs_item.size))
        keyValuePairs_item.foreach { case (keyValuePairs_item_key, keyValuePairs_item_value) =>
          _oprot.writeString(keyValuePairs_item_key)
          _oprot.writeString(keyValuePairs_item_value)
        }
        _oprot.writeMapEnd()
      }
    
    
    }
    
    class Args(
        val keyValuePairs: Map[String, String],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product1[Map[String, String]]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
    
      def this(
        keyValuePairs: Map[String, String] = Map[String, String]()
      ) = this(
        keyValuePairs,
        Map.empty
      )
    
      def _1: Map[String, String] = keyValuePairs
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        if (keyValuePairs ne null) writeKeyValuePairsField(keyValuePairs, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        keyValuePairs: Map[String, String] = this.keyValuePairs,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          keyValuePairs,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.keyValuePairs
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    }

    type SuccessType = Seq[Int]
    
    object Result extends ValidatingThriftStructCodec3[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("getProjectIds_result")
      val SuccessField: TField = new TField("success", TType.LIST, 0)
      val SuccessFieldManifest: Manifest[Seq[Int]] = implicitly[Manifest[Seq[Int]]]
      val SvExField: TField = new TField("svEx", TType.STRUCT, 1)
      val SvExFieldManifest: Manifest[modeldb.ServerLogicException] = implicitly[Manifest[modeldb.ServerLogicException]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.Some(implicitly[Manifest[Int]]),
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          SvExField,
          true,
          false,
          SvExFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf ++= validateField(item.svEx)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                field.map { field =>
                  field
                }
              }
            },
          svEx =
            {
              val field = original.svEx
              field.map { field =>
                modeldb.ServerLogicException.withoutPassthroughFields(field)
              }
            }
        )
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[Seq[Int]] = _root_.scala.None
        var svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.LIST =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.LIST
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 1 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    svEx = _root_.scala.Some(readSvExValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'svEx' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          svEx,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[Seq[Int]] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ): Result =
        new Result(
          success,
          svEx
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Tuple2[Option[Seq[Int]], Option[modeldb.ServerLogicException]]] = _root_.scala.Some(_item.toTuple)
    
    
      @inline private[modeldb] def readSuccessValue(_iprot: TProtocol): Seq[Int] = {
        val _list = _iprot.readListBegin()
        if (_list.size == 0) {
          _iprot.readListEnd()
          Nil
        } else {
          val _rv = new mutable$ArrayBuffer[Int](_list.size)
          var _i = 0
          while (_i < _list.size) {
            _rv += {
              _iprot.readI32()
            }
            _i += 1
          }
          _iprot.readListEnd()
          _rv
        }
      }
    
      @inline private def writeSuccessField(success_item: Seq[Int], _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: Seq[Int], _oprot: TProtocol): Unit = {
        _oprot.writeListBegin(new TList(TType.I32, success_item.size))
        success_item match {
          case _: IndexedSeq[_] =>
            var _i = 0
            val _size = success_item.size
            while (_i < _size) {
              val success_item_element = success_item(_i)
              _oprot.writeI32(success_item_element)
              _i += 1
            }
          case _ =>
            success_item.foreach { success_item_element =>
              _oprot.writeI32(success_item_element)
            }
        }
        _oprot.writeListEnd()
      }
    
      @inline private[modeldb] def readSvExValue(_iprot: TProtocol): modeldb.ServerLogicException = {
        modeldb.ServerLogicException.decode(_iprot)
      }
    
      @inline private def writeSvExField(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SvExField)
        writeSvExValue(svEx_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSvExValue(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        svEx_item.write(_oprot)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[Seq[Int]],
        val svEx: _root_.scala.Option[modeldb.ServerLogicException],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[Seq[Int]] with ThriftStruct
      with _root_.scala.Product2[Option[Seq[Int]], Option[modeldb.ServerLogicException]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
    
      def this(
        success: _root_.scala.Option[Seq[Int]] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ) = this(
        success,
        svEx,
        Map.empty
      )
    
      def _1: _root_.scala.Option[Seq[Int]] = success
      def _2: _root_.scala.Option[modeldb.ServerLogicException] = svEx
    
      def toTuple: _root_.scala.Tuple2[Option[Seq[Int]], Option[modeldb.ServerLogicException]] = {
        (
          success,
          svEx
        )
      }
    
      def successField: Option[Seq[Int]] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Seq(svEx)
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (svEx.isDefined) writeSvExField(svEx.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[Seq[Int]] = this.success,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = this.svEx,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          svEx,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 2
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case 1 => this.svEx
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Function1[Args,Future[Seq[Int]]]
    type ReqRepFunctionType = Function1[_root_.com.twitter.scrooge.Request[Args],Future[_root_.com.twitter.scrooge.Response[Seq[Int]]]]

    type ServiceIfaceServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ReqRepServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]]

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]] { request: _root_.com.twitter.scrooge.Request[Args] =>
        f(request)
      }

    private[this] val toResult = (res: SuccessType) => Result(Some(res))

    val name: String = "getProjectIds"
    val serviceName: String = "ModelDBService"
    val argsCodec = Args
    val responseCodec = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val getProjectIds$args = GetProjectIds.Args
  type getProjectIds$args = GetProjectIds.Args

  val getProjectIds$result = GetProjectIds.Result
  type getProjectIds$result = GetProjectIds.Result

  object GetModelIds extends ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("getModelIds_args")
      val KeyValuePairsField: TField = new TField("keyValuePairs", TType.MAP, 1)
      val KeyValuePairsFieldManifest: Manifest[Map[String, String]] = implicitly[Manifest[Map[String, String]]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          KeyValuePairsField,
          false,
          false,
          KeyValuePairsFieldManifest,
          _root_.scala.Some(implicitly[Manifest[String]]),
          _root_.scala.Some(implicitly[Manifest[String]]),
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.keyValuePairs)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          keyValuePairs =
            {
              val field = original.keyValuePairs
              field.map { case (key, value) =>
                  val newKey = {
                  val field = key
                  field
                }
  
          
                  val newValue = {
                  val field = value
                  field
                }
  
          
                newKey -> newValue
              }
            }
        )
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var keyValuePairs: Map[String, String] = Map[String, String]()
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.MAP =>
                    keyValuePairs = readKeyValuePairsValue(_iprot)
                  case _actualType =>
                    val _expectedType = TType.MAP
                    throw new TProtocolException(
                      "Received wrong type for field 'keyValuePairs' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Args(
          keyValuePairs,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        keyValuePairs: Map[String, String] = Map[String, String]()
      ): Args =
        new Args(
          keyValuePairs
        )
    
      def unapply(_item: Args): _root_.scala.Option[Map[String, String]] = _root_.scala.Some(_item.keyValuePairs)
    
    
      @inline private[modeldb] def readKeyValuePairsValue(_iprot: TProtocol): Map[String, String] = {
        val _map = _iprot.readMapBegin()
        if (_map.size == 0) {
          _iprot.readMapEnd()
          Map.empty[String, String]
        } else {
          val _rv = new mutable$HashMap[String, String]
          var _i = 0
          while (_i < _map.size) {
            val _key = {
              _iprot.readString()
            }
            val _value = {
              _iprot.readString()
            }
            _rv(_key) = _value
            _i += 1
          }
          _iprot.readMapEnd()
          _rv
        }
      }
    
      @inline private def writeKeyValuePairsField(keyValuePairs_item: Map[String, String], _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(KeyValuePairsField)
        writeKeyValuePairsValue(keyValuePairs_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeKeyValuePairsValue(keyValuePairs_item: Map[String, String], _oprot: TProtocol): Unit = {
        _oprot.writeMapBegin(new TMap(TType.STRING, TType.STRING, keyValuePairs_item.size))
        keyValuePairs_item.foreach { case (keyValuePairs_item_key, keyValuePairs_item_value) =>
          _oprot.writeString(keyValuePairs_item_key)
          _oprot.writeString(keyValuePairs_item_value)
        }
        _oprot.writeMapEnd()
      }
    
    
    }
    
    class Args(
        val keyValuePairs: Map[String, String],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product1[Map[String, String]]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
    
      def this(
        keyValuePairs: Map[String, String] = Map[String, String]()
      ) = this(
        keyValuePairs,
        Map.empty
      )
    
      def _1: Map[String, String] = keyValuePairs
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        if (keyValuePairs ne null) writeKeyValuePairsField(keyValuePairs, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        keyValuePairs: Map[String, String] = this.keyValuePairs,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          keyValuePairs,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.keyValuePairs
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    }

    type SuccessType = Seq[Int]
    
    object Result extends ValidatingThriftStructCodec3[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("getModelIds_result")
      val SuccessField: TField = new TField("success", TType.LIST, 0)
      val SuccessFieldManifest: Manifest[Seq[Int]] = implicitly[Manifest[Seq[Int]]]
      val SvExField: TField = new TField("svEx", TType.STRUCT, 1)
      val SvExFieldManifest: Manifest[modeldb.ServerLogicException] = implicitly[Manifest[modeldb.ServerLogicException]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.Some(implicitly[Manifest[Int]]),
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          SvExField,
          true,
          false,
          SvExFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf ++= validateField(item.svEx)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                field.map { field =>
                  field
                }
              }
            },
          svEx =
            {
              val field = original.svEx
              field.map { field =>
                modeldb.ServerLogicException.withoutPassthroughFields(field)
              }
            }
        )
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[Seq[Int]] = _root_.scala.None
        var svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.LIST =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.LIST
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 1 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    svEx = _root_.scala.Some(readSvExValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'svEx' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          svEx,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[Seq[Int]] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ): Result =
        new Result(
          success,
          svEx
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Tuple2[Option[Seq[Int]], Option[modeldb.ServerLogicException]]] = _root_.scala.Some(_item.toTuple)
    
    
      @inline private[modeldb] def readSuccessValue(_iprot: TProtocol): Seq[Int] = {
        val _list = _iprot.readListBegin()
        if (_list.size == 0) {
          _iprot.readListEnd()
          Nil
        } else {
          val _rv = new mutable$ArrayBuffer[Int](_list.size)
          var _i = 0
          while (_i < _list.size) {
            _rv += {
              _iprot.readI32()
            }
            _i += 1
          }
          _iprot.readListEnd()
          _rv
        }
      }
    
      @inline private def writeSuccessField(success_item: Seq[Int], _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: Seq[Int], _oprot: TProtocol): Unit = {
        _oprot.writeListBegin(new TList(TType.I32, success_item.size))
        success_item match {
          case _: IndexedSeq[_] =>
            var _i = 0
            val _size = success_item.size
            while (_i < _size) {
              val success_item_element = success_item(_i)
              _oprot.writeI32(success_item_element)
              _i += 1
            }
          case _ =>
            success_item.foreach { success_item_element =>
              _oprot.writeI32(success_item_element)
            }
        }
        _oprot.writeListEnd()
      }
    
      @inline private[modeldb] def readSvExValue(_iprot: TProtocol): modeldb.ServerLogicException = {
        modeldb.ServerLogicException.decode(_iprot)
      }
    
      @inline private def writeSvExField(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SvExField)
        writeSvExValue(svEx_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSvExValue(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        svEx_item.write(_oprot)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[Seq[Int]],
        val svEx: _root_.scala.Option[modeldb.ServerLogicException],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[Seq[Int]] with ThriftStruct
      with _root_.scala.Product2[Option[Seq[Int]], Option[modeldb.ServerLogicException]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
    
      def this(
        success: _root_.scala.Option[Seq[Int]] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ) = this(
        success,
        svEx,
        Map.empty
      )
    
      def _1: _root_.scala.Option[Seq[Int]] = success
      def _2: _root_.scala.Option[modeldb.ServerLogicException] = svEx
    
      def toTuple: _root_.scala.Tuple2[Option[Seq[Int]], Option[modeldb.ServerLogicException]] = {
        (
          success,
          svEx
        )
      }
    
      def successField: Option[Seq[Int]] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Seq(svEx)
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (svEx.isDefined) writeSvExField(svEx.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[Seq[Int]] = this.success,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = this.svEx,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          svEx,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 2
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case 1 => this.svEx
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Function1[Args,Future[Seq[Int]]]
    type ReqRepFunctionType = Function1[_root_.com.twitter.scrooge.Request[Args],Future[_root_.com.twitter.scrooge.Response[Seq[Int]]]]

    type ServiceIfaceServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ReqRepServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]]

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]] { request: _root_.com.twitter.scrooge.Request[Args] =>
        f(request)
      }

    private[this] val toResult = (res: SuccessType) => Result(Some(res))

    val name: String = "getModelIds"
    val serviceName: String = "ModelDBService"
    val argsCodec = Args
    val responseCodec = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val getModelIds$args = GetModelIds.Args
  type getModelIds$args = GetModelIds.Args

  val getModelIds$result = GetModelIds.Result
  type getModelIds$result = GetModelIds.Result

  object UpdateProject extends ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("updateProject_args")
      val ProjectIdField: TField = new TField("projectId", TType.I32, 1)
      val ProjectIdFieldManifest: Manifest[Int] = implicitly[Manifest[Int]]
      val KeyField: TField = new TField("key", TType.STRING, 2)
      val KeyFieldManifest: Manifest[String] = implicitly[Manifest[String]]
      val ValueField: TField = new TField("value", TType.STRING, 3)
      val ValueFieldManifest: Manifest[String] = implicitly[Manifest[String]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          ProjectIdField,
          false,
          false,
          ProjectIdFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          KeyField,
          false,
          false,
          KeyFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          ValueField,
          false,
          false,
          ValueFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.projectId)
        buf ++= validateField(item.key)
        buf ++= validateField(item.value)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          projectId =
            {
              val field = original.projectId
              field
            },
          key =
            {
              val field = original.key
              field
            },
          value =
            {
              val field = original.value
              field
            }
        )
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var projectId: Int = 0
        var key: String = null
        var value: String = null
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.I32 =>
                    projectId = readProjectIdValue(_iprot)
                  case _actualType =>
                    val _expectedType = TType.I32
                    throw new TProtocolException(
                      "Received wrong type for field 'projectId' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 2 =>
                _field.`type` match {
                  case TType.STRING =>
                    key = readKeyValue(_iprot)
                  case _actualType =>
                    val _expectedType = TType.STRING
                    throw new TProtocolException(
                      "Received wrong type for field 'key' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 3 =>
                _field.`type` match {
                  case TType.STRING =>
                    value = readValueValue(_iprot)
                  case _actualType =>
                    val _expectedType = TType.STRING
                    throw new TProtocolException(
                      "Received wrong type for field 'value' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Args(
          projectId,
          key,
          value,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        projectId: Int,
        key: String,
        value: String
      ): Args =
        new Args(
          projectId,
          key,
          value
        )
    
      def unapply(_item: Args): _root_.scala.Option[_root_.scala.Tuple3[Int, String, String]] = _root_.scala.Some(_item.toTuple)
    
    
      @inline private[modeldb] def readProjectIdValue(_iprot: TProtocol): Int = {
        _iprot.readI32()
      }
    
      @inline private def writeProjectIdField(projectId_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(ProjectIdField)
        writeProjectIdValue(projectId_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeProjectIdValue(projectId_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeI32(projectId_item)
      }
    
      @inline private[modeldb] def readKeyValue(_iprot: TProtocol): String = {
        _iprot.readString()
      }
    
      @inline private def writeKeyField(key_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(KeyField)
        writeKeyValue(key_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeKeyValue(key_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeString(key_item)
      }
    
      @inline private[modeldb] def readValueValue(_iprot: TProtocol): String = {
        _iprot.readString()
      }
    
      @inline private def writeValueField(value_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(ValueField)
        writeValueValue(value_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeValueValue(value_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeString(value_item)
      }
    
    
    }
    
    class Args(
        val projectId: Int,
        val key: String,
        val value: String,
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product3[Int, String, String]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
    
      def this(
        projectId: Int,
        key: String,
        value: String
      ) = this(
        projectId,
        key,
        value,
        Map.empty
      )
    
      def _1: Int = projectId
      def _2: String = key
      def _3: String = value
    
      def toTuple: _root_.scala.Tuple3[Int, String, String] = {
        (
          projectId,
          key,
          value
        )
      }
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        writeProjectIdField(projectId, _oprot)
        if (key ne null) writeKeyField(key, _oprot)
        if (value ne null) writeValueField(value, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        projectId: Int = this.projectId,
        key: String = this.key,
        value: String = this.value,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          projectId,
          key,
          value,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 3
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.projectId
        case 1 => this.key
        case 2 => this.value
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    }

    type SuccessType = Boolean
    
    object Result extends ValidatingThriftStructCodec3[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("updateProject_result")
      val SuccessField: TField = new TField("success", TType.BOOL, 0)
      val SuccessFieldManifest: Manifest[Boolean] = implicitly[Manifest[Boolean]]
      val SvExField: TField = new TField("svEx", TType.STRUCT, 1)
      val SvExFieldManifest: Manifest[modeldb.ServerLogicException] = implicitly[Manifest[modeldb.ServerLogicException]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          SvExField,
          true,
          false,
          SvExFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf ++= validateField(item.svEx)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                field
              }
            },
          svEx =
            {
              val field = original.svEx
              field.map { field =>
                modeldb.ServerLogicException.withoutPassthroughFields(field)
              }
            }
        )
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[Boolean] = _root_.scala.None
        var svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.BOOL =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.BOOL
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 1 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    svEx = _root_.scala.Some(readSvExValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'svEx' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          svEx,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[Boolean] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ): Result =
        new Result(
          success,
          svEx
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Tuple2[Option[Boolean], Option[modeldb.ServerLogicException]]] = _root_.scala.Some(_item.toTuple)
    
    
      @inline private[modeldb] def readSuccessValue(_iprot: TProtocol): Boolean = {
        _iprot.readBool()
      }
    
      @inline private def writeSuccessField(success_item: Boolean, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: Boolean, _oprot: TProtocol): Unit = {
        _oprot.writeBool(success_item)
      }
    
      @inline private[modeldb] def readSvExValue(_iprot: TProtocol): modeldb.ServerLogicException = {
        modeldb.ServerLogicException.decode(_iprot)
      }
    
      @inline private def writeSvExField(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SvExField)
        writeSvExValue(svEx_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSvExValue(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        svEx_item.write(_oprot)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[Boolean],
        val svEx: _root_.scala.Option[modeldb.ServerLogicException],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[Boolean] with ThriftStruct
      with _root_.scala.Product2[Option[Boolean], Option[modeldb.ServerLogicException]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
    
      def this(
        success: _root_.scala.Option[Boolean] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ) = this(
        success,
        svEx,
        Map.empty
      )
    
      def _1: _root_.scala.Option[Boolean] = success
      def _2: _root_.scala.Option[modeldb.ServerLogicException] = svEx
    
      def toTuple: _root_.scala.Tuple2[Option[Boolean], Option[modeldb.ServerLogicException]] = {
        (
          success,
          svEx
        )
      }
    
      def successField: Option[Boolean] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Seq(svEx)
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (svEx.isDefined) writeSvExField(svEx.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[Boolean] = this.success,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = this.svEx,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          svEx,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 2
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case 1 => this.svEx
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Function1[Args,Future[Boolean]]
    type ReqRepFunctionType = Function1[_root_.com.twitter.scrooge.Request[Args],Future[_root_.com.twitter.scrooge.Response[Boolean]]]

    type ServiceIfaceServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ReqRepServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]]

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]] { request: _root_.com.twitter.scrooge.Request[Args] =>
        f(request)
      }

    private[this] val toResult = (res: SuccessType) => Result(Some(res))

    val name: String = "updateProject"
    val serviceName: String = "ModelDBService"
    val argsCodec = Args
    val responseCodec = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val updateProject$args = UpdateProject.Args
  type updateProject$args = UpdateProject.Args

  val updateProject$result = UpdateProject.Result
  type updateProject$result = UpdateProject.Result

  object CreateOrUpdateScalarField extends ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("createOrUpdateScalarField_args")
      val ModelIdField: TField = new TField("modelId", TType.I32, 1)
      val ModelIdFieldManifest: Manifest[Int] = implicitly[Manifest[Int]]
      val KeyField: TField = new TField("key", TType.STRING, 2)
      val KeyFieldManifest: Manifest[String] = implicitly[Manifest[String]]
      val ValueField: TField = new TField("value", TType.STRING, 3)
      val ValueFieldManifest: Manifest[String] = implicitly[Manifest[String]]
      val ValueTypeField: TField = new TField("valueType", TType.STRING, 4)
      val ValueTypeFieldManifest: Manifest[String] = implicitly[Manifest[String]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          ModelIdField,
          false,
          false,
          ModelIdFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          KeyField,
          false,
          false,
          KeyFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          ValueField,
          false,
          false,
          ValueFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          ValueTypeField,
          false,
          false,
          ValueTypeFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.modelId)
        buf ++= validateField(item.key)
        buf ++= validateField(item.value)
        buf ++= validateField(item.valueType)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          modelId =
            {
              val field = original.modelId
              field
            },
          key =
            {
              val field = original.key
              field
            },
          value =
            {
              val field = original.value
              field
            },
          valueType =
            {
              val field = original.valueType
              field
            }
        )
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var modelId: Int = 0
        var key: String = null
        var value: String = null
        var valueType: String = null
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.I32 =>
                    modelId = readModelIdValue(_iprot)
                  case _actualType =>
                    val _expectedType = TType.I32
                    throw new TProtocolException(
                      "Received wrong type for field 'modelId' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 2 =>
                _field.`type` match {
                  case TType.STRING =>
                    key = readKeyValue(_iprot)
                  case _actualType =>
                    val _expectedType = TType.STRING
                    throw new TProtocolException(
                      "Received wrong type for field 'key' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 3 =>
                _field.`type` match {
                  case TType.STRING =>
                    value = readValueValue(_iprot)
                  case _actualType =>
                    val _expectedType = TType.STRING
                    throw new TProtocolException(
                      "Received wrong type for field 'value' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 4 =>
                _field.`type` match {
                  case TType.STRING =>
                    valueType = readValueTypeValue(_iprot)
                  case _actualType =>
                    val _expectedType = TType.STRING
                    throw new TProtocolException(
                      "Received wrong type for field 'valueType' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Args(
          modelId,
          key,
          value,
          valueType,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        modelId: Int,
        key: String,
        value: String,
        valueType: String
      ): Args =
        new Args(
          modelId,
          key,
          value,
          valueType
        )
    
      def unapply(_item: Args): _root_.scala.Option[_root_.scala.Tuple4[Int, String, String, String]] = _root_.scala.Some(_item.toTuple)
    
    
      @inline private[modeldb] def readModelIdValue(_iprot: TProtocol): Int = {
        _iprot.readI32()
      }
    
      @inline private def writeModelIdField(modelId_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(ModelIdField)
        writeModelIdValue(modelId_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeModelIdValue(modelId_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeI32(modelId_item)
      }
    
      @inline private[modeldb] def readKeyValue(_iprot: TProtocol): String = {
        _iprot.readString()
      }
    
      @inline private def writeKeyField(key_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(KeyField)
        writeKeyValue(key_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeKeyValue(key_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeString(key_item)
      }
    
      @inline private[modeldb] def readValueValue(_iprot: TProtocol): String = {
        _iprot.readString()
      }
    
      @inline private def writeValueField(value_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(ValueField)
        writeValueValue(value_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeValueValue(value_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeString(value_item)
      }
    
      @inline private[modeldb] def readValueTypeValue(_iprot: TProtocol): String = {
        _iprot.readString()
      }
    
      @inline private def writeValueTypeField(valueType_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(ValueTypeField)
        writeValueTypeValue(valueType_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeValueTypeValue(valueType_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeString(valueType_item)
      }
    
    
    }
    
    class Args(
        val modelId: Int,
        val key: String,
        val value: String,
        val valueType: String,
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product4[Int, String, String, String]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
    
      def this(
        modelId: Int,
        key: String,
        value: String,
        valueType: String
      ) = this(
        modelId,
        key,
        value,
        valueType,
        Map.empty
      )
    
      def _1: Int = modelId
      def _2: String = key
      def _3: String = value
      def _4: String = valueType
    
      def toTuple: _root_.scala.Tuple4[Int, String, String, String] = {
        (
          modelId,
          key,
          value,
          valueType
        )
      }
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        writeModelIdField(modelId, _oprot)
        if (key ne null) writeKeyField(key, _oprot)
        if (value ne null) writeValueField(value, _oprot)
        if (valueType ne null) writeValueTypeField(valueType, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        modelId: Int = this.modelId,
        key: String = this.key,
        value: String = this.value,
        valueType: String = this.valueType,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          modelId,
          key,
          value,
          valueType,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 4
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.modelId
        case 1 => this.key
        case 2 => this.value
        case 3 => this.valueType
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    }

    type SuccessType = Boolean
    
    object Result extends ValidatingThriftStructCodec3[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("createOrUpdateScalarField_result")
      val SuccessField: TField = new TField("success", TType.BOOL, 0)
      val SuccessFieldManifest: Manifest[Boolean] = implicitly[Manifest[Boolean]]
      val SvExField: TField = new TField("svEx", TType.STRUCT, 1)
      val SvExFieldManifest: Manifest[modeldb.ServerLogicException] = implicitly[Manifest[modeldb.ServerLogicException]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          SvExField,
          true,
          false,
          SvExFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf ++= validateField(item.svEx)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                field
              }
            },
          svEx =
            {
              val field = original.svEx
              field.map { field =>
                modeldb.ServerLogicException.withoutPassthroughFields(field)
              }
            }
        )
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[Boolean] = _root_.scala.None
        var svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.BOOL =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.BOOL
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 1 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    svEx = _root_.scala.Some(readSvExValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'svEx' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          svEx,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[Boolean] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ): Result =
        new Result(
          success,
          svEx
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Tuple2[Option[Boolean], Option[modeldb.ServerLogicException]]] = _root_.scala.Some(_item.toTuple)
    
    
      @inline private[modeldb] def readSuccessValue(_iprot: TProtocol): Boolean = {
        _iprot.readBool()
      }
    
      @inline private def writeSuccessField(success_item: Boolean, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: Boolean, _oprot: TProtocol): Unit = {
        _oprot.writeBool(success_item)
      }
    
      @inline private[modeldb] def readSvExValue(_iprot: TProtocol): modeldb.ServerLogicException = {
        modeldb.ServerLogicException.decode(_iprot)
      }
    
      @inline private def writeSvExField(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SvExField)
        writeSvExValue(svEx_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSvExValue(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        svEx_item.write(_oprot)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[Boolean],
        val svEx: _root_.scala.Option[modeldb.ServerLogicException],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[Boolean] with ThriftStruct
      with _root_.scala.Product2[Option[Boolean], Option[modeldb.ServerLogicException]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
    
      def this(
        success: _root_.scala.Option[Boolean] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ) = this(
        success,
        svEx,
        Map.empty
      )
    
      def _1: _root_.scala.Option[Boolean] = success
      def _2: _root_.scala.Option[modeldb.ServerLogicException] = svEx
    
      def toTuple: _root_.scala.Tuple2[Option[Boolean], Option[modeldb.ServerLogicException]] = {
        (
          success,
          svEx
        )
      }
    
      def successField: Option[Boolean] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Seq(svEx)
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (svEx.isDefined) writeSvExField(svEx.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[Boolean] = this.success,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = this.svEx,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          svEx,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 2
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case 1 => this.svEx
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Function1[Args,Future[Boolean]]
    type ReqRepFunctionType = Function1[_root_.com.twitter.scrooge.Request[Args],Future[_root_.com.twitter.scrooge.Response[Boolean]]]

    type ServiceIfaceServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ReqRepServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]]

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]] { request: _root_.com.twitter.scrooge.Request[Args] =>
        f(request)
      }

    private[this] val toResult = (res: SuccessType) => Result(Some(res))

    val name: String = "createOrUpdateScalarField"
    val serviceName: String = "ModelDBService"
    val argsCodec = Args
    val responseCodec = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val createOrUpdateScalarField$args = CreateOrUpdateScalarField.Args
  type createOrUpdateScalarField$args = CreateOrUpdateScalarField.Args

  val createOrUpdateScalarField$result = CreateOrUpdateScalarField.Result
  type createOrUpdateScalarField$result = CreateOrUpdateScalarField.Result

  object CreateVectorField extends ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("createVectorField_args")
      val ModelIdField: TField = new TField("modelId", TType.I32, 1)
      val ModelIdFieldManifest: Manifest[Int] = implicitly[Manifest[Int]]
      val VectorNameField: TField = new TField("vectorName", TType.STRING, 2)
      val VectorNameFieldManifest: Manifest[String] = implicitly[Manifest[String]]
      val VectorConfigField: TField = new TField("vectorConfig", TType.MAP, 3)
      val VectorConfigFieldManifest: Manifest[Map[String, String]] = implicitly[Manifest[Map[String, String]]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          ModelIdField,
          false,
          false,
          ModelIdFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          VectorNameField,
          false,
          false,
          VectorNameFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          VectorConfigField,
          false,
          false,
          VectorConfigFieldManifest,
          _root_.scala.Some(implicitly[Manifest[String]]),
          _root_.scala.Some(implicitly[Manifest[String]]),
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.modelId)
        buf ++= validateField(item.vectorName)
        buf ++= validateField(item.vectorConfig)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          modelId =
            {
              val field = original.modelId
              field
            },
          vectorName =
            {
              val field = original.vectorName
              field
            },
          vectorConfig =
            {
              val field = original.vectorConfig
              field.map { case (key, value) =>
                  val newKey = {
                  val field = key
                  field
                }
  
          
                  val newValue = {
                  val field = value
                  field
                }
  
          
                newKey -> newValue
              }
            }
        )
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var modelId: Int = 0
        var vectorName: String = null
        var vectorConfig: Map[String, String] = Map[String, String]()
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.I32 =>
                    modelId = readModelIdValue(_iprot)
                  case _actualType =>
                    val _expectedType = TType.I32
                    throw new TProtocolException(
                      "Received wrong type for field 'modelId' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 2 =>
                _field.`type` match {
                  case TType.STRING =>
                    vectorName = readVectorNameValue(_iprot)
                  case _actualType =>
                    val _expectedType = TType.STRING
                    throw new TProtocolException(
                      "Received wrong type for field 'vectorName' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 3 =>
                _field.`type` match {
                  case TType.MAP =>
                    vectorConfig = readVectorConfigValue(_iprot)
                  case _actualType =>
                    val _expectedType = TType.MAP
                    throw new TProtocolException(
                      "Received wrong type for field 'vectorConfig' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Args(
          modelId,
          vectorName,
          vectorConfig,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        modelId: Int,
        vectorName: String,
        vectorConfig: Map[String, String] = Map[String, String]()
      ): Args =
        new Args(
          modelId,
          vectorName,
          vectorConfig
        )
    
      def unapply(_item: Args): _root_.scala.Option[_root_.scala.Tuple3[Int, String, Map[String, String]]] = _root_.scala.Some(_item.toTuple)
    
    
      @inline private[modeldb] def readModelIdValue(_iprot: TProtocol): Int = {
        _iprot.readI32()
      }
    
      @inline private def writeModelIdField(modelId_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(ModelIdField)
        writeModelIdValue(modelId_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeModelIdValue(modelId_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeI32(modelId_item)
      }
    
      @inline private[modeldb] def readVectorNameValue(_iprot: TProtocol): String = {
        _iprot.readString()
      }
    
      @inline private def writeVectorNameField(vectorName_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(VectorNameField)
        writeVectorNameValue(vectorName_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeVectorNameValue(vectorName_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeString(vectorName_item)
      }
    
      @inline private[modeldb] def readVectorConfigValue(_iprot: TProtocol): Map[String, String] = {
        val _map = _iprot.readMapBegin()
        if (_map.size == 0) {
          _iprot.readMapEnd()
          Map.empty[String, String]
        } else {
          val _rv = new mutable$HashMap[String, String]
          var _i = 0
          while (_i < _map.size) {
            val _key = {
              _iprot.readString()
            }
            val _value = {
              _iprot.readString()
            }
            _rv(_key) = _value
            _i += 1
          }
          _iprot.readMapEnd()
          _rv
        }
      }
    
      @inline private def writeVectorConfigField(vectorConfig_item: Map[String, String], _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(VectorConfigField)
        writeVectorConfigValue(vectorConfig_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeVectorConfigValue(vectorConfig_item: Map[String, String], _oprot: TProtocol): Unit = {
        _oprot.writeMapBegin(new TMap(TType.STRING, TType.STRING, vectorConfig_item.size))
        vectorConfig_item.foreach { case (vectorConfig_item_key, vectorConfig_item_value) =>
          _oprot.writeString(vectorConfig_item_key)
          _oprot.writeString(vectorConfig_item_value)
        }
        _oprot.writeMapEnd()
      }
    
    
    }
    
    class Args(
        val modelId: Int,
        val vectorName: String,
        val vectorConfig: Map[String, String],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product3[Int, String, Map[String, String]]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
    
      def this(
        modelId: Int,
        vectorName: String,
        vectorConfig: Map[String, String] = Map[String, String]()
      ) = this(
        modelId,
        vectorName,
        vectorConfig,
        Map.empty
      )
    
      def _1: Int = modelId
      def _2: String = vectorName
      def _3: Map[String, String] = vectorConfig
    
      def toTuple: _root_.scala.Tuple3[Int, String, Map[String, String]] = {
        (
          modelId,
          vectorName,
          vectorConfig
        )
      }
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        writeModelIdField(modelId, _oprot)
        if (vectorName ne null) writeVectorNameField(vectorName, _oprot)
        if (vectorConfig ne null) writeVectorConfigField(vectorConfig, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        modelId: Int = this.modelId,
        vectorName: String = this.vectorName,
        vectorConfig: Map[String, String] = this.vectorConfig,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          modelId,
          vectorName,
          vectorConfig,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 3
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.modelId
        case 1 => this.vectorName
        case 2 => this.vectorConfig
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    }

    type SuccessType = Boolean
    
    object Result extends ValidatingThriftStructCodec3[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("createVectorField_result")
      val SuccessField: TField = new TField("success", TType.BOOL, 0)
      val SuccessFieldManifest: Manifest[Boolean] = implicitly[Manifest[Boolean]]
      val SvExField: TField = new TField("svEx", TType.STRUCT, 1)
      val SvExFieldManifest: Manifest[modeldb.ServerLogicException] = implicitly[Manifest[modeldb.ServerLogicException]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          SvExField,
          true,
          false,
          SvExFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf ++= validateField(item.svEx)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                field
              }
            },
          svEx =
            {
              val field = original.svEx
              field.map { field =>
                modeldb.ServerLogicException.withoutPassthroughFields(field)
              }
            }
        )
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[Boolean] = _root_.scala.None
        var svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.BOOL =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.BOOL
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 1 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    svEx = _root_.scala.Some(readSvExValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'svEx' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          svEx,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[Boolean] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ): Result =
        new Result(
          success,
          svEx
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Tuple2[Option[Boolean], Option[modeldb.ServerLogicException]]] = _root_.scala.Some(_item.toTuple)
    
    
      @inline private[modeldb] def readSuccessValue(_iprot: TProtocol): Boolean = {
        _iprot.readBool()
      }
    
      @inline private def writeSuccessField(success_item: Boolean, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: Boolean, _oprot: TProtocol): Unit = {
        _oprot.writeBool(success_item)
      }
    
      @inline private[modeldb] def readSvExValue(_iprot: TProtocol): modeldb.ServerLogicException = {
        modeldb.ServerLogicException.decode(_iprot)
      }
    
      @inline private def writeSvExField(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SvExField)
        writeSvExValue(svEx_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSvExValue(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        svEx_item.write(_oprot)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[Boolean],
        val svEx: _root_.scala.Option[modeldb.ServerLogicException],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[Boolean] with ThriftStruct
      with _root_.scala.Product2[Option[Boolean], Option[modeldb.ServerLogicException]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
    
      def this(
        success: _root_.scala.Option[Boolean] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ) = this(
        success,
        svEx,
        Map.empty
      )
    
      def _1: _root_.scala.Option[Boolean] = success
      def _2: _root_.scala.Option[modeldb.ServerLogicException] = svEx
    
      def toTuple: _root_.scala.Tuple2[Option[Boolean], Option[modeldb.ServerLogicException]] = {
        (
          success,
          svEx
        )
      }
    
      def successField: Option[Boolean] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Seq(svEx)
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (svEx.isDefined) writeSvExField(svEx.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[Boolean] = this.success,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = this.svEx,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          svEx,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 2
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case 1 => this.svEx
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Function1[Args,Future[Boolean]]
    type ReqRepFunctionType = Function1[_root_.com.twitter.scrooge.Request[Args],Future[_root_.com.twitter.scrooge.Response[Boolean]]]

    type ServiceIfaceServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ReqRepServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]]

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]] { request: _root_.com.twitter.scrooge.Request[Args] =>
        f(request)
      }

    private[this] val toResult = (res: SuccessType) => Result(Some(res))

    val name: String = "createVectorField"
    val serviceName: String = "ModelDBService"
    val argsCodec = Args
    val responseCodec = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val createVectorField$args = CreateVectorField.Args
  type createVectorField$args = CreateVectorField.Args

  val createVectorField$result = CreateVectorField.Result
  type createVectorField$result = CreateVectorField.Result

  object UpdateVectorField extends ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("updateVectorField_args")
      val ModelIdField: TField = new TField("modelId", TType.I32, 1)
      val ModelIdFieldManifest: Manifest[Int] = implicitly[Manifest[Int]]
      val KeyField: TField = new TField("key", TType.STRING, 2)
      val KeyFieldManifest: Manifest[String] = implicitly[Manifest[String]]
      val ValueIndexField: TField = new TField("valueIndex", TType.I32, 3)
      val ValueIndexFieldManifest: Manifest[Int] = implicitly[Manifest[Int]]
      val ValueField: TField = new TField("value", TType.STRING, 4)
      val ValueFieldManifest: Manifest[String] = implicitly[Manifest[String]]
      val ValueTypeField: TField = new TField("valueType", TType.STRING, 5)
      val ValueTypeFieldManifest: Manifest[String] = implicitly[Manifest[String]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          ModelIdField,
          false,
          false,
          ModelIdFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          KeyField,
          false,
          false,
          KeyFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          ValueIndexField,
          false,
          false,
          ValueIndexFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          ValueField,
          false,
          false,
          ValueFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          ValueTypeField,
          false,
          false,
          ValueTypeFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.modelId)
        buf ++= validateField(item.key)
        buf ++= validateField(item.valueIndex)
        buf ++= validateField(item.value)
        buf ++= validateField(item.valueType)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          modelId =
            {
              val field = original.modelId
              field
            },
          key =
            {
              val field = original.key
              field
            },
          valueIndex =
            {
              val field = original.valueIndex
              field
            },
          value =
            {
              val field = original.value
              field
            },
          valueType =
            {
              val field = original.valueType
              field
            }
        )
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var modelId: Int = 0
        var key: String = null
        var valueIndex: Int = 0
        var value: String = null
        var valueType: String = null
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.I32 =>
                    modelId = readModelIdValue(_iprot)
                  case _actualType =>
                    val _expectedType = TType.I32
                    throw new TProtocolException(
                      "Received wrong type for field 'modelId' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 2 =>
                _field.`type` match {
                  case TType.STRING =>
                    key = readKeyValue(_iprot)
                  case _actualType =>
                    val _expectedType = TType.STRING
                    throw new TProtocolException(
                      "Received wrong type for field 'key' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 3 =>
                _field.`type` match {
                  case TType.I32 =>
                    valueIndex = readValueIndexValue(_iprot)
                  case _actualType =>
                    val _expectedType = TType.I32
                    throw new TProtocolException(
                      "Received wrong type for field 'valueIndex' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 4 =>
                _field.`type` match {
                  case TType.STRING =>
                    value = readValueValue(_iprot)
                  case _actualType =>
                    val _expectedType = TType.STRING
                    throw new TProtocolException(
                      "Received wrong type for field 'value' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 5 =>
                _field.`type` match {
                  case TType.STRING =>
                    valueType = readValueTypeValue(_iprot)
                  case _actualType =>
                    val _expectedType = TType.STRING
                    throw new TProtocolException(
                      "Received wrong type for field 'valueType' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Args(
          modelId,
          key,
          valueIndex,
          value,
          valueType,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        modelId: Int,
        key: String,
        valueIndex: Int,
        value: String,
        valueType: String
      ): Args =
        new Args(
          modelId,
          key,
          valueIndex,
          value,
          valueType
        )
    
      def unapply(_item: Args): _root_.scala.Option[_root_.scala.Tuple5[Int, String, Int, String, String]] = _root_.scala.Some(_item.toTuple)
    
    
      @inline private[modeldb] def readModelIdValue(_iprot: TProtocol): Int = {
        _iprot.readI32()
      }
    
      @inline private def writeModelIdField(modelId_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(ModelIdField)
        writeModelIdValue(modelId_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeModelIdValue(modelId_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeI32(modelId_item)
      }
    
      @inline private[modeldb] def readKeyValue(_iprot: TProtocol): String = {
        _iprot.readString()
      }
    
      @inline private def writeKeyField(key_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(KeyField)
        writeKeyValue(key_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeKeyValue(key_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeString(key_item)
      }
    
      @inline private[modeldb] def readValueIndexValue(_iprot: TProtocol): Int = {
        _iprot.readI32()
      }
    
      @inline private def writeValueIndexField(valueIndex_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(ValueIndexField)
        writeValueIndexValue(valueIndex_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeValueIndexValue(valueIndex_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeI32(valueIndex_item)
      }
    
      @inline private[modeldb] def readValueValue(_iprot: TProtocol): String = {
        _iprot.readString()
      }
    
      @inline private def writeValueField(value_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(ValueField)
        writeValueValue(value_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeValueValue(value_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeString(value_item)
      }
    
      @inline private[modeldb] def readValueTypeValue(_iprot: TProtocol): String = {
        _iprot.readString()
      }
    
      @inline private def writeValueTypeField(valueType_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(ValueTypeField)
        writeValueTypeValue(valueType_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeValueTypeValue(valueType_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeString(valueType_item)
      }
    
    
    }
    
    class Args(
        val modelId: Int,
        val key: String,
        val valueIndex: Int,
        val value: String,
        val valueType: String,
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product5[Int, String, Int, String, String]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
    
      def this(
        modelId: Int,
        key: String,
        valueIndex: Int,
        value: String,
        valueType: String
      ) = this(
        modelId,
        key,
        valueIndex,
        value,
        valueType,
        Map.empty
      )
    
      def _1: Int = modelId
      def _2: String = key
      def _3: Int = valueIndex
      def _4: String = value
      def _5: String = valueType
    
      def toTuple: _root_.scala.Tuple5[Int, String, Int, String, String] = {
        (
          modelId,
          key,
          valueIndex,
          value,
          valueType
        )
      }
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        writeModelIdField(modelId, _oprot)
        if (key ne null) writeKeyField(key, _oprot)
        writeValueIndexField(valueIndex, _oprot)
        if (value ne null) writeValueField(value, _oprot)
        if (valueType ne null) writeValueTypeField(valueType, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        modelId: Int = this.modelId,
        key: String = this.key,
        valueIndex: Int = this.valueIndex,
        value: String = this.value,
        valueType: String = this.valueType,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          modelId,
          key,
          valueIndex,
          value,
          valueType,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 5
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.modelId
        case 1 => this.key
        case 2 => this.valueIndex
        case 3 => this.value
        case 4 => this.valueType
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    }

    type SuccessType = Boolean
    
    object Result extends ValidatingThriftStructCodec3[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("updateVectorField_result")
      val SuccessField: TField = new TField("success", TType.BOOL, 0)
      val SuccessFieldManifest: Manifest[Boolean] = implicitly[Manifest[Boolean]]
      val SvExField: TField = new TField("svEx", TType.STRUCT, 1)
      val SvExFieldManifest: Manifest[modeldb.ServerLogicException] = implicitly[Manifest[modeldb.ServerLogicException]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          SvExField,
          true,
          false,
          SvExFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf ++= validateField(item.svEx)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                field
              }
            },
          svEx =
            {
              val field = original.svEx
              field.map { field =>
                modeldb.ServerLogicException.withoutPassthroughFields(field)
              }
            }
        )
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[Boolean] = _root_.scala.None
        var svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.BOOL =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.BOOL
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 1 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    svEx = _root_.scala.Some(readSvExValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'svEx' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          svEx,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[Boolean] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ): Result =
        new Result(
          success,
          svEx
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Tuple2[Option[Boolean], Option[modeldb.ServerLogicException]]] = _root_.scala.Some(_item.toTuple)
    
    
      @inline private[modeldb] def readSuccessValue(_iprot: TProtocol): Boolean = {
        _iprot.readBool()
      }
    
      @inline private def writeSuccessField(success_item: Boolean, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: Boolean, _oprot: TProtocol): Unit = {
        _oprot.writeBool(success_item)
      }
    
      @inline private[modeldb] def readSvExValue(_iprot: TProtocol): modeldb.ServerLogicException = {
        modeldb.ServerLogicException.decode(_iprot)
      }
    
      @inline private def writeSvExField(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SvExField)
        writeSvExValue(svEx_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSvExValue(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        svEx_item.write(_oprot)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[Boolean],
        val svEx: _root_.scala.Option[modeldb.ServerLogicException],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[Boolean] with ThriftStruct
      with _root_.scala.Product2[Option[Boolean], Option[modeldb.ServerLogicException]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
    
      def this(
        success: _root_.scala.Option[Boolean] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ) = this(
        success,
        svEx,
        Map.empty
      )
    
      def _1: _root_.scala.Option[Boolean] = success
      def _2: _root_.scala.Option[modeldb.ServerLogicException] = svEx
    
      def toTuple: _root_.scala.Tuple2[Option[Boolean], Option[modeldb.ServerLogicException]] = {
        (
          success,
          svEx
        )
      }
    
      def successField: Option[Boolean] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Seq(svEx)
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (svEx.isDefined) writeSvExField(svEx.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[Boolean] = this.success,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = this.svEx,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          svEx,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 2
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case 1 => this.svEx
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Function1[Args,Future[Boolean]]
    type ReqRepFunctionType = Function1[_root_.com.twitter.scrooge.Request[Args],Future[_root_.com.twitter.scrooge.Response[Boolean]]]

    type ServiceIfaceServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ReqRepServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]]

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]] { request: _root_.com.twitter.scrooge.Request[Args] =>
        f(request)
      }

    private[this] val toResult = (res: SuccessType) => Result(Some(res))

    val name: String = "updateVectorField"
    val serviceName: String = "ModelDBService"
    val argsCodec = Args
    val responseCodec = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val updateVectorField$args = UpdateVectorField.Args
  type updateVectorField$args = UpdateVectorField.Args

  val updateVectorField$result = UpdateVectorField.Result
  type updateVectorField$result = UpdateVectorField.Result

  object AppendToVectorField extends ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("appendToVectorField_args")
      val ModelIdField: TField = new TField("modelId", TType.I32, 1)
      val ModelIdFieldManifest: Manifest[Int] = implicitly[Manifest[Int]]
      val VectorNameField: TField = new TField("vectorName", TType.STRING, 2)
      val VectorNameFieldManifest: Manifest[String] = implicitly[Manifest[String]]
      val ValueField: TField = new TField("value", TType.STRING, 3)
      val ValueFieldManifest: Manifest[String] = implicitly[Manifest[String]]
      val ValueTypeField: TField = new TField("valueType", TType.STRING, 4)
      val ValueTypeFieldManifest: Manifest[String] = implicitly[Manifest[String]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          ModelIdField,
          false,
          false,
          ModelIdFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          VectorNameField,
          false,
          false,
          VectorNameFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          ValueField,
          false,
          false,
          ValueFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          ValueTypeField,
          false,
          false,
          ValueTypeFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.modelId)
        buf ++= validateField(item.vectorName)
        buf ++= validateField(item.value)
        buf ++= validateField(item.valueType)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          modelId =
            {
              val field = original.modelId
              field
            },
          vectorName =
            {
              val field = original.vectorName
              field
            },
          value =
            {
              val field = original.value
              field
            },
          valueType =
            {
              val field = original.valueType
              field
            }
        )
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var modelId: Int = 0
        var vectorName: String = null
        var value: String = null
        var valueType: String = null
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.I32 =>
                    modelId = readModelIdValue(_iprot)
                  case _actualType =>
                    val _expectedType = TType.I32
                    throw new TProtocolException(
                      "Received wrong type for field 'modelId' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 2 =>
                _field.`type` match {
                  case TType.STRING =>
                    vectorName = readVectorNameValue(_iprot)
                  case _actualType =>
                    val _expectedType = TType.STRING
                    throw new TProtocolException(
                      "Received wrong type for field 'vectorName' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 3 =>
                _field.`type` match {
                  case TType.STRING =>
                    value = readValueValue(_iprot)
                  case _actualType =>
                    val _expectedType = TType.STRING
                    throw new TProtocolException(
                      "Received wrong type for field 'value' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 4 =>
                _field.`type` match {
                  case TType.STRING =>
                    valueType = readValueTypeValue(_iprot)
                  case _actualType =>
                    val _expectedType = TType.STRING
                    throw new TProtocolException(
                      "Received wrong type for field 'valueType' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Args(
          modelId,
          vectorName,
          value,
          valueType,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        modelId: Int,
        vectorName: String,
        value: String,
        valueType: String
      ): Args =
        new Args(
          modelId,
          vectorName,
          value,
          valueType
        )
    
      def unapply(_item: Args): _root_.scala.Option[_root_.scala.Tuple4[Int, String, String, String]] = _root_.scala.Some(_item.toTuple)
    
    
      @inline private[modeldb] def readModelIdValue(_iprot: TProtocol): Int = {
        _iprot.readI32()
      }
    
      @inline private def writeModelIdField(modelId_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(ModelIdField)
        writeModelIdValue(modelId_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeModelIdValue(modelId_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeI32(modelId_item)
      }
    
      @inline private[modeldb] def readVectorNameValue(_iprot: TProtocol): String = {
        _iprot.readString()
      }
    
      @inline private def writeVectorNameField(vectorName_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(VectorNameField)
        writeVectorNameValue(vectorName_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeVectorNameValue(vectorName_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeString(vectorName_item)
      }
    
      @inline private[modeldb] def readValueValue(_iprot: TProtocol): String = {
        _iprot.readString()
      }
    
      @inline private def writeValueField(value_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(ValueField)
        writeValueValue(value_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeValueValue(value_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeString(value_item)
      }
    
      @inline private[modeldb] def readValueTypeValue(_iprot: TProtocol): String = {
        _iprot.readString()
      }
    
      @inline private def writeValueTypeField(valueType_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(ValueTypeField)
        writeValueTypeValue(valueType_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeValueTypeValue(valueType_item: String, _oprot: TProtocol): Unit = {
        _oprot.writeString(valueType_item)
      }
    
    
    }
    
    class Args(
        val modelId: Int,
        val vectorName: String,
        val value: String,
        val valueType: String,
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product4[Int, String, String, String]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
    
      def this(
        modelId: Int,
        vectorName: String,
        value: String,
        valueType: String
      ) = this(
        modelId,
        vectorName,
        value,
        valueType,
        Map.empty
      )
    
      def _1: Int = modelId
      def _2: String = vectorName
      def _3: String = value
      def _4: String = valueType
    
      def toTuple: _root_.scala.Tuple4[Int, String, String, String] = {
        (
          modelId,
          vectorName,
          value,
          valueType
        )
      }
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        writeModelIdField(modelId, _oprot)
        if (vectorName ne null) writeVectorNameField(vectorName, _oprot)
        if (value ne null) writeValueField(value, _oprot)
        if (valueType ne null) writeValueTypeField(valueType, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        modelId: Int = this.modelId,
        vectorName: String = this.vectorName,
        value: String = this.value,
        valueType: String = this.valueType,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          modelId,
          vectorName,
          value,
          valueType,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 4
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.modelId
        case 1 => this.vectorName
        case 2 => this.value
        case 3 => this.valueType
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    }

    type SuccessType = Boolean
    
    object Result extends ValidatingThriftStructCodec3[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("appendToVectorField_result")
      val SuccessField: TField = new TField("success", TType.BOOL, 0)
      val SuccessFieldManifest: Manifest[Boolean] = implicitly[Manifest[Boolean]]
      val SvExField: TField = new TField("svEx", TType.STRUCT, 1)
      val SvExFieldManifest: Manifest[modeldb.ServerLogicException] = implicitly[Manifest[modeldb.ServerLogicException]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          SvExField,
          true,
          false,
          SvExFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf ++= validateField(item.svEx)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                field
              }
            },
          svEx =
            {
              val field = original.svEx
              field.map { field =>
                modeldb.ServerLogicException.withoutPassthroughFields(field)
              }
            }
        )
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[Boolean] = _root_.scala.None
        var svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.BOOL =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.BOOL
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 1 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    svEx = _root_.scala.Some(readSvExValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'svEx' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          svEx,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[Boolean] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ): Result =
        new Result(
          success,
          svEx
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Tuple2[Option[Boolean], Option[modeldb.ServerLogicException]]] = _root_.scala.Some(_item.toTuple)
    
    
      @inline private[modeldb] def readSuccessValue(_iprot: TProtocol): Boolean = {
        _iprot.readBool()
      }
    
      @inline private def writeSuccessField(success_item: Boolean, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: Boolean, _oprot: TProtocol): Unit = {
        _oprot.writeBool(success_item)
      }
    
      @inline private[modeldb] def readSvExValue(_iprot: TProtocol): modeldb.ServerLogicException = {
        modeldb.ServerLogicException.decode(_iprot)
      }
    
      @inline private def writeSvExField(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SvExField)
        writeSvExValue(svEx_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSvExValue(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        svEx_item.write(_oprot)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[Boolean],
        val svEx: _root_.scala.Option[modeldb.ServerLogicException],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[Boolean] with ThriftStruct
      with _root_.scala.Product2[Option[Boolean], Option[modeldb.ServerLogicException]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
    
      def this(
        success: _root_.scala.Option[Boolean] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ) = this(
        success,
        svEx,
        Map.empty
      )
    
      def _1: _root_.scala.Option[Boolean] = success
      def _2: _root_.scala.Option[modeldb.ServerLogicException] = svEx
    
      def toTuple: _root_.scala.Tuple2[Option[Boolean], Option[modeldb.ServerLogicException]] = {
        (
          success,
          svEx
        )
      }
    
      def successField: Option[Boolean] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Seq(svEx)
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (svEx.isDefined) writeSvExField(svEx.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[Boolean] = this.success,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = this.svEx,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          svEx,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 2
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case 1 => this.svEx
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Function1[Args,Future[Boolean]]
    type ReqRepFunctionType = Function1[_root_.com.twitter.scrooge.Request[Args],Future[_root_.com.twitter.scrooge.Response[Boolean]]]

    type ServiceIfaceServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ReqRepServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]]

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]] { request: _root_.com.twitter.scrooge.Request[Args] =>
        f(request)
      }

    private[this] val toResult = (res: SuccessType) => Result(Some(res))

    val name: String = "appendToVectorField"
    val serviceName: String = "ModelDBService"
    val argsCodec = Args
    val responseCodec = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val appendToVectorField$args = AppendToVectorField.Args
  type appendToVectorField$args = AppendToVectorField.Args

  val appendToVectorField$result = AppendToVectorField.Result
  type appendToVectorField$result = AppendToVectorField.Result

  object GetModel extends ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("getModel_args")
      val ModelIdField: TField = new TField("modelId", TType.I32, 1)
      val ModelIdFieldManifest: Manifest[Int] = implicitly[Manifest[Int]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          ModelIdField,
          false,
          false,
          ModelIdFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.modelId)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          modelId =
            {
              val field = original.modelId
              field
            }
        )
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var modelId: Int = 0
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.I32 =>
                    modelId = readModelIdValue(_iprot)
                  case _actualType =>
                    val _expectedType = TType.I32
                    throw new TProtocolException(
                      "Received wrong type for field 'modelId' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Args(
          modelId,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        modelId: Int
      ): Args =
        new Args(
          modelId
        )
    
      def unapply(_item: Args): _root_.scala.Option[Int] = _root_.scala.Some(_item.modelId)
    
    
      @inline private[modeldb] def readModelIdValue(_iprot: TProtocol): Int = {
        _iprot.readI32()
      }
    
      @inline private def writeModelIdField(modelId_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(ModelIdField)
        writeModelIdValue(modelId_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeModelIdValue(modelId_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeI32(modelId_item)
      }
    
    
    }
    
    class Args(
        val modelId: Int,
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product1[Int]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
    
      def this(
        modelId: Int
      ) = this(
        modelId,
        Map.empty
      )
    
      def _1: Int = modelId
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        writeModelIdField(modelId, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        modelId: Int = this.modelId,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          modelId,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.modelId
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    }

    type SuccessType = modeldb.ModelResponse
    
    object Result extends ValidatingThriftStructCodec3[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("getModel_result")
      val SuccessField: TField = new TField("success", TType.STRUCT, 0)
      val SuccessFieldManifest: Manifest[modeldb.ModelResponse] = implicitly[Manifest[modeldb.ModelResponse]]
      val RnfExField: TField = new TField("rnfEx", TType.STRUCT, 1)
      val RnfExFieldManifest: Manifest[modeldb.ResourceNotFoundException] = implicitly[Manifest[modeldb.ResourceNotFoundException]]
      val SvExField: TField = new TField("svEx", TType.STRUCT, 2)
      val SvExFieldManifest: Manifest[modeldb.ServerLogicException] = implicitly[Manifest[modeldb.ServerLogicException]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          RnfExField,
          true,
          false,
          RnfExFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          SvExField,
          true,
          false,
          SvExFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf ++= validateField(item.rnfEx)
        buf ++= validateField(item.svEx)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                modeldb.ModelResponse.withoutPassthroughFields(field)
              }
            },
          rnfEx =
            {
              val field = original.rnfEx
              field.map { field =>
                modeldb.ResourceNotFoundException.withoutPassthroughFields(field)
              }
            },
          svEx =
            {
              val field = original.svEx
              field.map { field =>
                modeldb.ServerLogicException.withoutPassthroughFields(field)
              }
            }
        )
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[modeldb.ModelResponse] = _root_.scala.None
        var rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException] = _root_.scala.None
        var svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 1 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    rnfEx = _root_.scala.Some(readRnfExValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'rnfEx' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 2 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    svEx = _root_.scala.Some(readSvExValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'svEx' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          rnfEx,
          svEx,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[modeldb.ModelResponse] = _root_.scala.None,
        rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ): Result =
        new Result(
          success,
          rnfEx,
          svEx
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Tuple3[Option[modeldb.ModelResponse], Option[modeldb.ResourceNotFoundException], Option[modeldb.ServerLogicException]]] = _root_.scala.Some(_item.toTuple)
    
    
      @inline private[modeldb] def readSuccessValue(_iprot: TProtocol): modeldb.ModelResponse = {
        modeldb.ModelResponse.decode(_iprot)
      }
    
      @inline private def writeSuccessField(success_item: modeldb.ModelResponse, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: modeldb.ModelResponse, _oprot: TProtocol): Unit = {
        success_item.write(_oprot)
      }
    
      @inline private[modeldb] def readRnfExValue(_iprot: TProtocol): modeldb.ResourceNotFoundException = {
        modeldb.ResourceNotFoundException.decode(_iprot)
      }
    
      @inline private def writeRnfExField(rnfEx_item: modeldb.ResourceNotFoundException, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(RnfExField)
        writeRnfExValue(rnfEx_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeRnfExValue(rnfEx_item: modeldb.ResourceNotFoundException, _oprot: TProtocol): Unit = {
        rnfEx_item.write(_oprot)
      }
    
      @inline private[modeldb] def readSvExValue(_iprot: TProtocol): modeldb.ServerLogicException = {
        modeldb.ServerLogicException.decode(_iprot)
      }
    
      @inline private def writeSvExField(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SvExField)
        writeSvExValue(svEx_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSvExValue(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        svEx_item.write(_oprot)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[modeldb.ModelResponse],
        val rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException],
        val svEx: _root_.scala.Option[modeldb.ServerLogicException],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[modeldb.ModelResponse] with ThriftStruct
      with _root_.scala.Product3[Option[modeldb.ModelResponse], Option[modeldb.ResourceNotFoundException], Option[modeldb.ServerLogicException]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
    
      def this(
        success: _root_.scala.Option[modeldb.ModelResponse] = _root_.scala.None,
        rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ) = this(
        success,
        rnfEx,
        svEx,
        Map.empty
      )
    
      def _1: _root_.scala.Option[modeldb.ModelResponse] = success
      def _2: _root_.scala.Option[modeldb.ResourceNotFoundException] = rnfEx
      def _3: _root_.scala.Option[modeldb.ServerLogicException] = svEx
    
      def toTuple: _root_.scala.Tuple3[Option[modeldb.ModelResponse], Option[modeldb.ResourceNotFoundException], Option[modeldb.ServerLogicException]] = {
        (
          success,
          rnfEx,
          svEx
        )
      }
    
      def successField: Option[modeldb.ModelResponse] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Seq(rnfEx, svEx)
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (rnfEx.isDefined) writeRnfExField(rnfEx.get, _oprot)
        if (svEx.isDefined) writeSvExField(svEx.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[modeldb.ModelResponse] = this.success,
        rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException] = this.rnfEx,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = this.svEx,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          rnfEx,
          svEx,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 3
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case 1 => this.rnfEx
        case 2 => this.svEx
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Function1[Args,Future[modeldb.ModelResponse]]
    type ReqRepFunctionType = Function1[_root_.com.twitter.scrooge.Request[Args],Future[_root_.com.twitter.scrooge.Response[modeldb.ModelResponse]]]

    type ServiceIfaceServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ReqRepServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]]

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]] { request: _root_.com.twitter.scrooge.Request[Args] =>
        f(request)
      }

    private[this] val toResult = (res: SuccessType) => Result(Some(res))

    val name: String = "getModel"
    val serviceName: String = "ModelDBService"
    val argsCodec = Args
    val responseCodec = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val getModel$args = GetModel.Args
  type getModel$args = GetModel.Args

  val getModel$result = GetModel.Result
  type getModel$result = GetModel.Result

  object GetRunsInExperiment extends ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("getRunsInExperiment_args")
      val ExperimentIdField: TField = new TField("experimentId", TType.I32, 1)
      val ExperimentIdFieldManifest: Manifest[Int] = implicitly[Manifest[Int]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          ExperimentIdField,
          false,
          false,
          ExperimentIdFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.experimentId)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          experimentId =
            {
              val field = original.experimentId
              field
            }
        )
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var experimentId: Int = 0
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.I32 =>
                    experimentId = readExperimentIdValue(_iprot)
                  case _actualType =>
                    val _expectedType = TType.I32
                    throw new TProtocolException(
                      "Received wrong type for field 'experimentId' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Args(
          experimentId,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        experimentId: Int
      ): Args =
        new Args(
          experimentId
        )
    
      def unapply(_item: Args): _root_.scala.Option[Int] = _root_.scala.Some(_item.experimentId)
    
    
      @inline private[modeldb] def readExperimentIdValue(_iprot: TProtocol): Int = {
        _iprot.readI32()
      }
    
      @inline private def writeExperimentIdField(experimentId_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(ExperimentIdField)
        writeExperimentIdValue(experimentId_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeExperimentIdValue(experimentId_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeI32(experimentId_item)
      }
    
    
    }
    
    class Args(
        val experimentId: Int,
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product1[Int]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
    
      def this(
        experimentId: Int
      ) = this(
        experimentId,
        Map.empty
      )
    
      def _1: Int = experimentId
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        writeExperimentIdField(experimentId, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        experimentId: Int = this.experimentId,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          experimentId,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.experimentId
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    }

    type SuccessType = Seq[modeldb.ExperimentRun]
    
    object Result extends ValidatingThriftStructCodec3[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("getRunsInExperiment_result")
      val SuccessField: TField = new TField("success", TType.LIST, 0)
      val SuccessFieldManifest: Manifest[Seq[modeldb.ExperimentRun]] = implicitly[Manifest[Seq[modeldb.ExperimentRun]]]
      val SvExField: TField = new TField("svEx", TType.STRUCT, 1)
      val SvExFieldManifest: Manifest[modeldb.ServerLogicException] = implicitly[Manifest[modeldb.ServerLogicException]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.Some(implicitly[Manifest[modeldb.ExperimentRun]]),
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          SvExField,
          true,
          false,
          SvExFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf ++= validateField(item.svEx)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                field.map { field =>
                  modeldb.ExperimentRun.withoutPassthroughFields(field)
                }
              }
            },
          svEx =
            {
              val field = original.svEx
              field.map { field =>
                modeldb.ServerLogicException.withoutPassthroughFields(field)
              }
            }
        )
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[Seq[modeldb.ExperimentRun]] = _root_.scala.None
        var svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.LIST =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.LIST
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 1 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    svEx = _root_.scala.Some(readSvExValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'svEx' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          svEx,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[Seq[modeldb.ExperimentRun]] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ): Result =
        new Result(
          success,
          svEx
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Tuple2[Option[Seq[modeldb.ExperimentRun]], Option[modeldb.ServerLogicException]]] = _root_.scala.Some(_item.toTuple)
    
    
      @inline private[modeldb] def readSuccessValue(_iprot: TProtocol): Seq[modeldb.ExperimentRun] = {
        val _list = _iprot.readListBegin()
        if (_list.size == 0) {
          _iprot.readListEnd()
          Nil
        } else {
          val _rv = new mutable$ArrayBuffer[modeldb.ExperimentRun](_list.size)
          var _i = 0
          while (_i < _list.size) {
            _rv += {
              modeldb.ExperimentRun.decode(_iprot)
            }
            _i += 1
          }
          _iprot.readListEnd()
          _rv
        }
      }
    
      @inline private def writeSuccessField(success_item: Seq[modeldb.ExperimentRun], _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: Seq[modeldb.ExperimentRun], _oprot: TProtocol): Unit = {
        _oprot.writeListBegin(new TList(TType.STRUCT, success_item.size))
        success_item match {
          case _: IndexedSeq[_] =>
            var _i = 0
            val _size = success_item.size
            while (_i < _size) {
              val success_item_element = success_item(_i)
              success_item_element.write(_oprot)
              _i += 1
            }
          case _ =>
            success_item.foreach { success_item_element =>
              success_item_element.write(_oprot)
            }
        }
        _oprot.writeListEnd()
      }
    
      @inline private[modeldb] def readSvExValue(_iprot: TProtocol): modeldb.ServerLogicException = {
        modeldb.ServerLogicException.decode(_iprot)
      }
    
      @inline private def writeSvExField(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SvExField)
        writeSvExValue(svEx_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSvExValue(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        svEx_item.write(_oprot)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[Seq[modeldb.ExperimentRun]],
        val svEx: _root_.scala.Option[modeldb.ServerLogicException],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[Seq[modeldb.ExperimentRun]] with ThriftStruct
      with _root_.scala.Product2[Option[Seq[modeldb.ExperimentRun]], Option[modeldb.ServerLogicException]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
    
      def this(
        success: _root_.scala.Option[Seq[modeldb.ExperimentRun]] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ) = this(
        success,
        svEx,
        Map.empty
      )
    
      def _1: _root_.scala.Option[Seq[modeldb.ExperimentRun]] = success
      def _2: _root_.scala.Option[modeldb.ServerLogicException] = svEx
    
      def toTuple: _root_.scala.Tuple2[Option[Seq[modeldb.ExperimentRun]], Option[modeldb.ServerLogicException]] = {
        (
          success,
          svEx
        )
      }
    
      def successField: Option[Seq[modeldb.ExperimentRun]] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Seq(svEx)
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (svEx.isDefined) writeSvExField(svEx.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[Seq[modeldb.ExperimentRun]] = this.success,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = this.svEx,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          svEx,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 2
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case 1 => this.svEx
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Function1[Args,Future[Seq[modeldb.ExperimentRun]]]
    type ReqRepFunctionType = Function1[_root_.com.twitter.scrooge.Request[Args],Future[_root_.com.twitter.scrooge.Response[Seq[modeldb.ExperimentRun]]]]

    type ServiceIfaceServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ReqRepServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]]

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]] { request: _root_.com.twitter.scrooge.Request[Args] =>
        f(request)
      }

    private[this] val toResult = (res: SuccessType) => Result(Some(res))

    val name: String = "getRunsInExperiment"
    val serviceName: String = "ModelDBService"
    val argsCodec = Args
    val responseCodec = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val getRunsInExperiment$args = GetRunsInExperiment.Args
  type getRunsInExperiment$args = GetRunsInExperiment.Args

  val getRunsInExperiment$result = GetRunsInExperiment.Result
  type getRunsInExperiment$result = GetRunsInExperiment.Result

  object GetRunsAndExperimentsInProject extends ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("getRunsAndExperimentsInProject_args")
      val ProjIdField: TField = new TField("projId", TType.I32, 1)
      val ProjIdFieldManifest: Manifest[Int] = implicitly[Manifest[Int]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          ProjIdField,
          false,
          false,
          ProjIdFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.projId)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          projId =
            {
              val field = original.projId
              field
            }
        )
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var projId: Int = 0
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.I32 =>
                    projId = readProjIdValue(_iprot)
                  case _actualType =>
                    val _expectedType = TType.I32
                    throw new TProtocolException(
                      "Received wrong type for field 'projId' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Args(
          projId,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        projId: Int
      ): Args =
        new Args(
          projId
        )
    
      def unapply(_item: Args): _root_.scala.Option[Int] = _root_.scala.Some(_item.projId)
    
    
      @inline private[modeldb] def readProjIdValue(_iprot: TProtocol): Int = {
        _iprot.readI32()
      }
    
      @inline private def writeProjIdField(projId_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(ProjIdField)
        writeProjIdValue(projId_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeProjIdValue(projId_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeI32(projId_item)
      }
    
    
    }
    
    class Args(
        val projId: Int,
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product1[Int]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
    
      def this(
        projId: Int
      ) = this(
        projId,
        Map.empty
      )
    
      def _1: Int = projId
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        writeProjIdField(projId, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        projId: Int = this.projId,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          projId,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.projId
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    }

    type SuccessType = modeldb.ProjectExperimentsAndRuns
    
    object Result extends ValidatingThriftStructCodec3[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("getRunsAndExperimentsInProject_result")
      val SuccessField: TField = new TField("success", TType.STRUCT, 0)
      val SuccessFieldManifest: Manifest[modeldb.ProjectExperimentsAndRuns] = implicitly[Manifest[modeldb.ProjectExperimentsAndRuns]]
      val SvExField: TField = new TField("svEx", TType.STRUCT, 1)
      val SvExFieldManifest: Manifest[modeldb.ServerLogicException] = implicitly[Manifest[modeldb.ServerLogicException]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          SvExField,
          true,
          false,
          SvExFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf ++= validateField(item.svEx)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                modeldb.ProjectExperimentsAndRuns.withoutPassthroughFields(field)
              }
            },
          svEx =
            {
              val field = original.svEx
              field.map { field =>
                modeldb.ServerLogicException.withoutPassthroughFields(field)
              }
            }
        )
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[modeldb.ProjectExperimentsAndRuns] = _root_.scala.None
        var svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 1 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    svEx = _root_.scala.Some(readSvExValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'svEx' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          svEx,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[modeldb.ProjectExperimentsAndRuns] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ): Result =
        new Result(
          success,
          svEx
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Tuple2[Option[modeldb.ProjectExperimentsAndRuns], Option[modeldb.ServerLogicException]]] = _root_.scala.Some(_item.toTuple)
    
    
      @inline private[modeldb] def readSuccessValue(_iprot: TProtocol): modeldb.ProjectExperimentsAndRuns = {
        modeldb.ProjectExperimentsAndRuns.decode(_iprot)
      }
    
      @inline private def writeSuccessField(success_item: modeldb.ProjectExperimentsAndRuns, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: modeldb.ProjectExperimentsAndRuns, _oprot: TProtocol): Unit = {
        success_item.write(_oprot)
      }
    
      @inline private[modeldb] def readSvExValue(_iprot: TProtocol): modeldb.ServerLogicException = {
        modeldb.ServerLogicException.decode(_iprot)
      }
    
      @inline private def writeSvExField(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SvExField)
        writeSvExValue(svEx_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSvExValue(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        svEx_item.write(_oprot)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[modeldb.ProjectExperimentsAndRuns],
        val svEx: _root_.scala.Option[modeldb.ServerLogicException],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[modeldb.ProjectExperimentsAndRuns] with ThriftStruct
      with _root_.scala.Product2[Option[modeldb.ProjectExperimentsAndRuns], Option[modeldb.ServerLogicException]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
    
      def this(
        success: _root_.scala.Option[modeldb.ProjectExperimentsAndRuns] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ) = this(
        success,
        svEx,
        Map.empty
      )
    
      def _1: _root_.scala.Option[modeldb.ProjectExperimentsAndRuns] = success
      def _2: _root_.scala.Option[modeldb.ServerLogicException] = svEx
    
      def toTuple: _root_.scala.Tuple2[Option[modeldb.ProjectExperimentsAndRuns], Option[modeldb.ServerLogicException]] = {
        (
          success,
          svEx
        )
      }
    
      def successField: Option[modeldb.ProjectExperimentsAndRuns] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Seq(svEx)
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (svEx.isDefined) writeSvExField(svEx.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[modeldb.ProjectExperimentsAndRuns] = this.success,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = this.svEx,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          svEx,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 2
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case 1 => this.svEx
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Function1[Args,Future[modeldb.ProjectExperimentsAndRuns]]
    type ReqRepFunctionType = Function1[_root_.com.twitter.scrooge.Request[Args],Future[_root_.com.twitter.scrooge.Response[modeldb.ProjectExperimentsAndRuns]]]

    type ServiceIfaceServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ReqRepServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]]

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]] { request: _root_.com.twitter.scrooge.Request[Args] =>
        f(request)
      }

    private[this] val toResult = (res: SuccessType) => Result(Some(res))

    val name: String = "getRunsAndExperimentsInProject"
    val serviceName: String = "ModelDBService"
    val argsCodec = Args
    val responseCodec = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val getRunsAndExperimentsInProject$args = GetRunsAndExperimentsInProject.Args
  type getRunsAndExperimentsInProject$args = GetRunsAndExperimentsInProject.Args

  val getRunsAndExperimentsInProject$result = GetRunsAndExperimentsInProject.Result
  type getRunsAndExperimentsInProject$result = GetRunsAndExperimentsInProject.Result

  object GetProjectOverviews extends ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("getProjectOverviews_args")
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
        )
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Args(
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
      ): Args =
        new Args(
        )
    
      def unapply(_item: Args): Boolean = true
    
    
    
    }
    
    class Args(
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
    
      def this(
      ) = this(
        Map.empty
      )
    
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 0
    
      override def productElement(n: Int): Any = n match {
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    }

    type SuccessType = Seq[modeldb.ProjectOverviewResponse]
    
    object Result extends ValidatingThriftStructCodec3[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("getProjectOverviews_result")
      val SuccessField: TField = new TField("success", TType.LIST, 0)
      val SuccessFieldManifest: Manifest[Seq[modeldb.ProjectOverviewResponse]] = implicitly[Manifest[Seq[modeldb.ProjectOverviewResponse]]]
      val SvExField: TField = new TField("svEx", TType.STRUCT, 1)
      val SvExFieldManifest: Manifest[modeldb.ServerLogicException] = implicitly[Manifest[modeldb.ServerLogicException]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.Some(implicitly[Manifest[modeldb.ProjectOverviewResponse]]),
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          SvExField,
          true,
          false,
          SvExFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf ++= validateField(item.svEx)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                field.map { field =>
                  modeldb.ProjectOverviewResponse.withoutPassthroughFields(field)
                }
              }
            },
          svEx =
            {
              val field = original.svEx
              field.map { field =>
                modeldb.ServerLogicException.withoutPassthroughFields(field)
              }
            }
        )
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[Seq[modeldb.ProjectOverviewResponse]] = _root_.scala.None
        var svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.LIST =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.LIST
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 1 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    svEx = _root_.scala.Some(readSvExValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'svEx' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          svEx,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[Seq[modeldb.ProjectOverviewResponse]] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ): Result =
        new Result(
          success,
          svEx
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Tuple2[Option[Seq[modeldb.ProjectOverviewResponse]], Option[modeldb.ServerLogicException]]] = _root_.scala.Some(_item.toTuple)
    
    
      @inline private[modeldb] def readSuccessValue(_iprot: TProtocol): Seq[modeldb.ProjectOverviewResponse] = {
        val _list = _iprot.readListBegin()
        if (_list.size == 0) {
          _iprot.readListEnd()
          Nil
        } else {
          val _rv = new mutable$ArrayBuffer[modeldb.ProjectOverviewResponse](_list.size)
          var _i = 0
          while (_i < _list.size) {
            _rv += {
              modeldb.ProjectOverviewResponse.decode(_iprot)
            }
            _i += 1
          }
          _iprot.readListEnd()
          _rv
        }
      }
    
      @inline private def writeSuccessField(success_item: Seq[modeldb.ProjectOverviewResponse], _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: Seq[modeldb.ProjectOverviewResponse], _oprot: TProtocol): Unit = {
        _oprot.writeListBegin(new TList(TType.STRUCT, success_item.size))
        success_item match {
          case _: IndexedSeq[_] =>
            var _i = 0
            val _size = success_item.size
            while (_i < _size) {
              val success_item_element = success_item(_i)
              success_item_element.write(_oprot)
              _i += 1
            }
          case _ =>
            success_item.foreach { success_item_element =>
              success_item_element.write(_oprot)
            }
        }
        _oprot.writeListEnd()
      }
    
      @inline private[modeldb] def readSvExValue(_iprot: TProtocol): modeldb.ServerLogicException = {
        modeldb.ServerLogicException.decode(_iprot)
      }
    
      @inline private def writeSvExField(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SvExField)
        writeSvExValue(svEx_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSvExValue(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        svEx_item.write(_oprot)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[Seq[modeldb.ProjectOverviewResponse]],
        val svEx: _root_.scala.Option[modeldb.ServerLogicException],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[Seq[modeldb.ProjectOverviewResponse]] with ThriftStruct
      with _root_.scala.Product2[Option[Seq[modeldb.ProjectOverviewResponse]], Option[modeldb.ServerLogicException]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
    
      def this(
        success: _root_.scala.Option[Seq[modeldb.ProjectOverviewResponse]] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ) = this(
        success,
        svEx,
        Map.empty
      )
    
      def _1: _root_.scala.Option[Seq[modeldb.ProjectOverviewResponse]] = success
      def _2: _root_.scala.Option[modeldb.ServerLogicException] = svEx
    
      def toTuple: _root_.scala.Tuple2[Option[Seq[modeldb.ProjectOverviewResponse]], Option[modeldb.ServerLogicException]] = {
        (
          success,
          svEx
        )
      }
    
      def successField: Option[Seq[modeldb.ProjectOverviewResponse]] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Seq(svEx)
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (svEx.isDefined) writeSvExField(svEx.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[Seq[modeldb.ProjectOverviewResponse]] = this.success,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = this.svEx,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          svEx,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 2
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case 1 => this.svEx
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Function1[Args,Future[Seq[modeldb.ProjectOverviewResponse]]]
    type ReqRepFunctionType = Function1[_root_.com.twitter.scrooge.Request[Args],Future[_root_.com.twitter.scrooge.Response[Seq[modeldb.ProjectOverviewResponse]]]]

    type ServiceIfaceServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ReqRepServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]]

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]] { request: _root_.com.twitter.scrooge.Request[Args] =>
        f(request)
      }

    private[this] val toResult = (res: SuccessType) => Result(Some(res))

    val name: String = "getProjectOverviews"
    val serviceName: String = "ModelDBService"
    val argsCodec = Args
    val responseCodec = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val getProjectOverviews$args = GetProjectOverviews.Args
  type getProjectOverviews$args = GetProjectOverviews.Args

  val getProjectOverviews$result = GetProjectOverviews.Result
  type getProjectOverviews$result = GetProjectOverviews.Result

  object GetExperimentRunDetails extends ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("getExperimentRunDetails_args")
      val ExperimentRunIdField: TField = new TField("experimentRunId", TType.I32, 1)
      val ExperimentRunIdFieldManifest: Manifest[Int] = implicitly[Manifest[Int]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          ExperimentRunIdField,
          false,
          false,
          ExperimentRunIdFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.experimentRunId)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          experimentRunId =
            {
              val field = original.experimentRunId
              field
            }
        )
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var experimentRunId: Int = 0
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.I32 =>
                    experimentRunId = readExperimentRunIdValue(_iprot)
                  case _actualType =>
                    val _expectedType = TType.I32
                    throw new TProtocolException(
                      "Received wrong type for field 'experimentRunId' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Args(
          experimentRunId,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        experimentRunId: Int
      ): Args =
        new Args(
          experimentRunId
        )
    
      def unapply(_item: Args): _root_.scala.Option[Int] = _root_.scala.Some(_item.experimentRunId)
    
    
      @inline private[modeldb] def readExperimentRunIdValue(_iprot: TProtocol): Int = {
        _iprot.readI32()
      }
    
      @inline private def writeExperimentRunIdField(experimentRunId_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(ExperimentRunIdField)
        writeExperimentRunIdValue(experimentRunId_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeExperimentRunIdValue(experimentRunId_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeI32(experimentRunId_item)
      }
    
    
    }
    
    class Args(
        val experimentRunId: Int,
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product1[Int]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
    
      def this(
        experimentRunId: Int
      ) = this(
        experimentRunId,
        Map.empty
      )
    
      def _1: Int = experimentRunId
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        writeExperimentRunIdField(experimentRunId, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        experimentRunId: Int = this.experimentRunId,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          experimentRunId,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.experimentRunId
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    }

    type SuccessType = modeldb.ExperimentRunDetailsResponse
    
    object Result extends ValidatingThriftStructCodec3[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("getExperimentRunDetails_result")
      val SuccessField: TField = new TField("success", TType.STRUCT, 0)
      val SuccessFieldManifest: Manifest[modeldb.ExperimentRunDetailsResponse] = implicitly[Manifest[modeldb.ExperimentRunDetailsResponse]]
      val SvExField: TField = new TField("svEx", TType.STRUCT, 1)
      val SvExFieldManifest: Manifest[modeldb.ServerLogicException] = implicitly[Manifest[modeldb.ServerLogicException]]
      val RnfExField: TField = new TField("rnfEx", TType.STRUCT, 2)
      val RnfExFieldManifest: Manifest[modeldb.ResourceNotFoundException] = implicitly[Manifest[modeldb.ResourceNotFoundException]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          SvExField,
          true,
          false,
          SvExFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          RnfExField,
          true,
          false,
          RnfExFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf ++= validateField(item.svEx)
        buf ++= validateField(item.rnfEx)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                modeldb.ExperimentRunDetailsResponse.withoutPassthroughFields(field)
              }
            },
          svEx =
            {
              val field = original.svEx
              field.map { field =>
                modeldb.ServerLogicException.withoutPassthroughFields(field)
              }
            },
          rnfEx =
            {
              val field = original.rnfEx
              field.map { field =>
                modeldb.ResourceNotFoundException.withoutPassthroughFields(field)
              }
            }
        )
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[modeldb.ExperimentRunDetailsResponse] = _root_.scala.None
        var svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
        var rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 1 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    svEx = _root_.scala.Some(readSvExValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'svEx' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 2 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    rnfEx = _root_.scala.Some(readRnfExValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'rnfEx' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          svEx,
          rnfEx,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[modeldb.ExperimentRunDetailsResponse] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None,
        rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException] = _root_.scala.None
      ): Result =
        new Result(
          success,
          svEx,
          rnfEx
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Tuple3[Option[modeldb.ExperimentRunDetailsResponse], Option[modeldb.ServerLogicException], Option[modeldb.ResourceNotFoundException]]] = _root_.scala.Some(_item.toTuple)
    
    
      @inline private[modeldb] def readSuccessValue(_iprot: TProtocol): modeldb.ExperimentRunDetailsResponse = {
        modeldb.ExperimentRunDetailsResponse.decode(_iprot)
      }
    
      @inline private def writeSuccessField(success_item: modeldb.ExperimentRunDetailsResponse, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: modeldb.ExperimentRunDetailsResponse, _oprot: TProtocol): Unit = {
        success_item.write(_oprot)
      }
    
      @inline private[modeldb] def readSvExValue(_iprot: TProtocol): modeldb.ServerLogicException = {
        modeldb.ServerLogicException.decode(_iprot)
      }
    
      @inline private def writeSvExField(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SvExField)
        writeSvExValue(svEx_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSvExValue(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        svEx_item.write(_oprot)
      }
    
      @inline private[modeldb] def readRnfExValue(_iprot: TProtocol): modeldb.ResourceNotFoundException = {
        modeldb.ResourceNotFoundException.decode(_iprot)
      }
    
      @inline private def writeRnfExField(rnfEx_item: modeldb.ResourceNotFoundException, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(RnfExField)
        writeRnfExValue(rnfEx_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeRnfExValue(rnfEx_item: modeldb.ResourceNotFoundException, _oprot: TProtocol): Unit = {
        rnfEx_item.write(_oprot)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[modeldb.ExperimentRunDetailsResponse],
        val svEx: _root_.scala.Option[modeldb.ServerLogicException],
        val rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[modeldb.ExperimentRunDetailsResponse] with ThriftStruct
      with _root_.scala.Product3[Option[modeldb.ExperimentRunDetailsResponse], Option[modeldb.ServerLogicException], Option[modeldb.ResourceNotFoundException]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
    
      def this(
        success: _root_.scala.Option[modeldb.ExperimentRunDetailsResponse] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None,
        rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException] = _root_.scala.None
      ) = this(
        success,
        svEx,
        rnfEx,
        Map.empty
      )
    
      def _1: _root_.scala.Option[modeldb.ExperimentRunDetailsResponse] = success
      def _2: _root_.scala.Option[modeldb.ServerLogicException] = svEx
      def _3: _root_.scala.Option[modeldb.ResourceNotFoundException] = rnfEx
    
      def toTuple: _root_.scala.Tuple3[Option[modeldb.ExperimentRunDetailsResponse], Option[modeldb.ServerLogicException], Option[modeldb.ResourceNotFoundException]] = {
        (
          success,
          svEx,
          rnfEx
        )
      }
    
      def successField: Option[modeldb.ExperimentRunDetailsResponse] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Seq(svEx, rnfEx)
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (svEx.isDefined) writeSvExField(svEx.get, _oprot)
        if (rnfEx.isDefined) writeRnfExField(rnfEx.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[modeldb.ExperimentRunDetailsResponse] = this.success,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = this.svEx,
        rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException] = this.rnfEx,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          svEx,
          rnfEx,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 3
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case 1 => this.svEx
        case 2 => this.rnfEx
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Function1[Args,Future[modeldb.ExperimentRunDetailsResponse]]
    type ReqRepFunctionType = Function1[_root_.com.twitter.scrooge.Request[Args],Future[_root_.com.twitter.scrooge.Response[modeldb.ExperimentRunDetailsResponse]]]

    type ServiceIfaceServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ReqRepServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]]

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]] { request: _root_.com.twitter.scrooge.Request[Args] =>
        f(request)
      }

    private[this] val toResult = (res: SuccessType) => Result(Some(res))

    val name: String = "getExperimentRunDetails"
    val serviceName: String = "ModelDBService"
    val argsCodec = Args
    val responseCodec = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val getExperimentRunDetails$args = GetExperimentRunDetails.Args
  type getExperimentRunDetails$args = GetExperimentRunDetails.Args

  val getExperimentRunDetails$result = GetExperimentRunDetails.Result
  type getExperimentRunDetails$result = GetExperimentRunDetails.Result

  object OriginalFeatures extends ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("originalFeatures_args")
      val ModelIdField: TField = new TField("modelId", TType.I32, 1)
      val ModelIdFieldManifest: Manifest[Int] = implicitly[Manifest[Int]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          ModelIdField,
          false,
          false,
          ModelIdFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.modelId)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          modelId =
            {
              val field = original.modelId
              field
            }
        )
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var modelId: Int = 0
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.I32 =>
                    modelId = readModelIdValue(_iprot)
                  case _actualType =>
                    val _expectedType = TType.I32
                    throw new TProtocolException(
                      "Received wrong type for field 'modelId' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Args(
          modelId,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        modelId: Int
      ): Args =
        new Args(
          modelId
        )
    
      def unapply(_item: Args): _root_.scala.Option[Int] = _root_.scala.Some(_item.modelId)
    
    
      @inline private[modeldb] def readModelIdValue(_iprot: TProtocol): Int = {
        _iprot.readI32()
      }
    
      @inline private def writeModelIdField(modelId_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(ModelIdField)
        writeModelIdValue(modelId_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeModelIdValue(modelId_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeI32(modelId_item)
      }
    
    
    }
    
    class Args(
        val modelId: Int,
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product1[Int]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
    
      def this(
        modelId: Int
      ) = this(
        modelId,
        Map.empty
      )
    
      def _1: Int = modelId
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        writeModelIdField(modelId, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        modelId: Int = this.modelId,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          modelId,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.modelId
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    }

    type SuccessType = Seq[String]
    
    object Result extends ValidatingThriftStructCodec3[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("originalFeatures_result")
      val SuccessField: TField = new TField("success", TType.LIST, 0)
      val SuccessFieldManifest: Manifest[Seq[String]] = implicitly[Manifest[Seq[String]]]
      val RnfExField: TField = new TField("rnfEx", TType.STRUCT, 1)
      val RnfExFieldManifest: Manifest[modeldb.ResourceNotFoundException] = implicitly[Manifest[modeldb.ResourceNotFoundException]]
      val SvExField: TField = new TField("svEx", TType.STRUCT, 2)
      val SvExFieldManifest: Manifest[modeldb.ServerLogicException] = implicitly[Manifest[modeldb.ServerLogicException]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.Some(implicitly[Manifest[String]]),
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          RnfExField,
          true,
          false,
          RnfExFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          SvExField,
          true,
          false,
          SvExFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf ++= validateField(item.rnfEx)
        buf ++= validateField(item.svEx)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                field.map { field =>
                  field
                }
              }
            },
          rnfEx =
            {
              val field = original.rnfEx
              field.map { field =>
                modeldb.ResourceNotFoundException.withoutPassthroughFields(field)
              }
            },
          svEx =
            {
              val field = original.svEx
              field.map { field =>
                modeldb.ServerLogicException.withoutPassthroughFields(field)
              }
            }
        )
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[Seq[String]] = _root_.scala.None
        var rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException] = _root_.scala.None
        var svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.LIST =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.LIST
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 1 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    rnfEx = _root_.scala.Some(readRnfExValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'rnfEx' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 2 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    svEx = _root_.scala.Some(readSvExValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'svEx' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          rnfEx,
          svEx,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[Seq[String]] = _root_.scala.None,
        rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ): Result =
        new Result(
          success,
          rnfEx,
          svEx
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Tuple3[Option[Seq[String]], Option[modeldb.ResourceNotFoundException], Option[modeldb.ServerLogicException]]] = _root_.scala.Some(_item.toTuple)
    
    
      @inline private[modeldb] def readSuccessValue(_iprot: TProtocol): Seq[String] = {
        val _list = _iprot.readListBegin()
        if (_list.size == 0) {
          _iprot.readListEnd()
          Nil
        } else {
          val _rv = new mutable$ArrayBuffer[String](_list.size)
          var _i = 0
          while (_i < _list.size) {
            _rv += {
              _iprot.readString()
            }
            _i += 1
          }
          _iprot.readListEnd()
          _rv
        }
      }
    
      @inline private def writeSuccessField(success_item: Seq[String], _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: Seq[String], _oprot: TProtocol): Unit = {
        _oprot.writeListBegin(new TList(TType.STRING, success_item.size))
        success_item match {
          case _: IndexedSeq[_] =>
            var _i = 0
            val _size = success_item.size
            while (_i < _size) {
              val success_item_element = success_item(_i)
              _oprot.writeString(success_item_element)
              _i += 1
            }
          case _ =>
            success_item.foreach { success_item_element =>
              _oprot.writeString(success_item_element)
            }
        }
        _oprot.writeListEnd()
      }
    
      @inline private[modeldb] def readRnfExValue(_iprot: TProtocol): modeldb.ResourceNotFoundException = {
        modeldb.ResourceNotFoundException.decode(_iprot)
      }
    
      @inline private def writeRnfExField(rnfEx_item: modeldb.ResourceNotFoundException, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(RnfExField)
        writeRnfExValue(rnfEx_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeRnfExValue(rnfEx_item: modeldb.ResourceNotFoundException, _oprot: TProtocol): Unit = {
        rnfEx_item.write(_oprot)
      }
    
      @inline private[modeldb] def readSvExValue(_iprot: TProtocol): modeldb.ServerLogicException = {
        modeldb.ServerLogicException.decode(_iprot)
      }
    
      @inline private def writeSvExField(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SvExField)
        writeSvExValue(svEx_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSvExValue(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        svEx_item.write(_oprot)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[Seq[String]],
        val rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException],
        val svEx: _root_.scala.Option[modeldb.ServerLogicException],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[Seq[String]] with ThriftStruct
      with _root_.scala.Product3[Option[Seq[String]], Option[modeldb.ResourceNotFoundException], Option[modeldb.ServerLogicException]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
    
      def this(
        success: _root_.scala.Option[Seq[String]] = _root_.scala.None,
        rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ) = this(
        success,
        rnfEx,
        svEx,
        Map.empty
      )
    
      def _1: _root_.scala.Option[Seq[String]] = success
      def _2: _root_.scala.Option[modeldb.ResourceNotFoundException] = rnfEx
      def _3: _root_.scala.Option[modeldb.ServerLogicException] = svEx
    
      def toTuple: _root_.scala.Tuple3[Option[Seq[String]], Option[modeldb.ResourceNotFoundException], Option[modeldb.ServerLogicException]] = {
        (
          success,
          rnfEx,
          svEx
        )
      }
    
      def successField: Option[Seq[String]] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Seq(rnfEx, svEx)
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (rnfEx.isDefined) writeRnfExField(rnfEx.get, _oprot)
        if (svEx.isDefined) writeSvExField(svEx.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[Seq[String]] = this.success,
        rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException] = this.rnfEx,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = this.svEx,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          rnfEx,
          svEx,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 3
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case 1 => this.rnfEx
        case 2 => this.svEx
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Function1[Args,Future[Seq[String]]]
    type ReqRepFunctionType = Function1[_root_.com.twitter.scrooge.Request[Args],Future[_root_.com.twitter.scrooge.Response[Seq[String]]]]

    type ServiceIfaceServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ReqRepServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]]

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]] { request: _root_.com.twitter.scrooge.Request[Args] =>
        f(request)
      }

    private[this] val toResult = (res: SuccessType) => Result(Some(res))

    val name: String = "originalFeatures"
    val serviceName: String = "ModelDBService"
    val argsCodec = Args
    val responseCodec = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val originalFeatures$args = OriginalFeatures.Args
  type originalFeatures$args = OriginalFeatures.Args

  val originalFeatures$result = OriginalFeatures.Result
  type originalFeatures$result = OriginalFeatures.Result

  object StoreTreeModel extends ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("storeTreeModel_args")
      val ModelIdField: TField = new TField("modelId", TType.I32, 1)
      val ModelIdFieldManifest: Manifest[Int] = implicitly[Manifest[Int]]
      val ModelField: TField = new TField("model", TType.STRUCT, 2)
      val ModelFieldManifest: Manifest[modeldb.TreeModel] = implicitly[Manifest[modeldb.TreeModel]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          ModelIdField,
          false,
          false,
          ModelIdFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          ModelField,
          false,
          false,
          ModelFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.modelId)
        buf ++= validateField(item.model)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          modelId =
            {
              val field = original.modelId
              field
            },
          model =
            {
              val field = original.model
              modeldb.TreeModel.withoutPassthroughFields(field)
            }
        )
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var modelId: Int = 0
        var model: modeldb.TreeModel = null
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.I32 =>
                    modelId = readModelIdValue(_iprot)
                  case _actualType =>
                    val _expectedType = TType.I32
                    throw new TProtocolException(
                      "Received wrong type for field 'modelId' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 2 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    model = readModelValue(_iprot)
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'model' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Args(
          modelId,
          model,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        modelId: Int,
        model: modeldb.TreeModel
      ): Args =
        new Args(
          modelId,
          model
        )
    
      def unapply(_item: Args): _root_.scala.Option[_root_.scala.Tuple2[Int, modeldb.TreeModel]] = _root_.scala.Some(_item.toTuple)
    
    
      @inline private[modeldb] def readModelIdValue(_iprot: TProtocol): Int = {
        _iprot.readI32()
      }
    
      @inline private def writeModelIdField(modelId_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(ModelIdField)
        writeModelIdValue(modelId_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeModelIdValue(modelId_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeI32(modelId_item)
      }
    
      @inline private[modeldb] def readModelValue(_iprot: TProtocol): modeldb.TreeModel = {
        modeldb.TreeModel.decode(_iprot)
      }
    
      @inline private def writeModelField(model_item: modeldb.TreeModel, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(ModelField)
        writeModelValue(model_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeModelValue(model_item: modeldb.TreeModel, _oprot: TProtocol): Unit = {
        model_item.write(_oprot)
      }
    
    
    }
    
    class Args(
        val modelId: Int,
        val model: modeldb.TreeModel,
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product2[Int, modeldb.TreeModel]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
    
      def this(
        modelId: Int,
        model: modeldb.TreeModel
      ) = this(
        modelId,
        model,
        Map.empty
      )
    
      def _1: Int = modelId
      def _2: modeldb.TreeModel = model
    
      def toTuple: _root_.scala.Tuple2[Int, modeldb.TreeModel] = {
        (
          modelId,
          model
        )
      }
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        writeModelIdField(modelId, _oprot)
        if (model ne null) writeModelField(model, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        modelId: Int = this.modelId,
        model: modeldb.TreeModel = this.model,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          modelId,
          model,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 2
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.modelId
        case 1 => this.model
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    }

    type SuccessType = Boolean
    
    object Result extends ValidatingThriftStructCodec3[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("storeTreeModel_result")
      val SuccessField: TField = new TField("success", TType.BOOL, 0)
      val SuccessFieldManifest: Manifest[Boolean] = implicitly[Manifest[Boolean]]
      val RnfExField: TField = new TField("rnfEx", TType.STRUCT, 1)
      val RnfExFieldManifest: Manifest[modeldb.ResourceNotFoundException] = implicitly[Manifest[modeldb.ResourceNotFoundException]]
      val SvExField: TField = new TField("svEx", TType.STRUCT, 2)
      val SvExFieldManifest: Manifest[modeldb.ServerLogicException] = implicitly[Manifest[modeldb.ServerLogicException]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          RnfExField,
          true,
          false,
          RnfExFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          SvExField,
          true,
          false,
          SvExFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf ++= validateField(item.rnfEx)
        buf ++= validateField(item.svEx)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                field
              }
            },
          rnfEx =
            {
              val field = original.rnfEx
              field.map { field =>
                modeldb.ResourceNotFoundException.withoutPassthroughFields(field)
              }
            },
          svEx =
            {
              val field = original.svEx
              field.map { field =>
                modeldb.ServerLogicException.withoutPassthroughFields(field)
              }
            }
        )
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[Boolean] = _root_.scala.None
        var rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException] = _root_.scala.None
        var svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.BOOL =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.BOOL
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 1 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    rnfEx = _root_.scala.Some(readRnfExValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'rnfEx' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 2 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    svEx = _root_.scala.Some(readSvExValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'svEx' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          rnfEx,
          svEx,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[Boolean] = _root_.scala.None,
        rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ): Result =
        new Result(
          success,
          rnfEx,
          svEx
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Tuple3[Option[Boolean], Option[modeldb.ResourceNotFoundException], Option[modeldb.ServerLogicException]]] = _root_.scala.Some(_item.toTuple)
    
    
      @inline private[modeldb] def readSuccessValue(_iprot: TProtocol): Boolean = {
        _iprot.readBool()
      }
    
      @inline private def writeSuccessField(success_item: Boolean, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: Boolean, _oprot: TProtocol): Unit = {
        _oprot.writeBool(success_item)
      }
    
      @inline private[modeldb] def readRnfExValue(_iprot: TProtocol): modeldb.ResourceNotFoundException = {
        modeldb.ResourceNotFoundException.decode(_iprot)
      }
    
      @inline private def writeRnfExField(rnfEx_item: modeldb.ResourceNotFoundException, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(RnfExField)
        writeRnfExValue(rnfEx_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeRnfExValue(rnfEx_item: modeldb.ResourceNotFoundException, _oprot: TProtocol): Unit = {
        rnfEx_item.write(_oprot)
      }
    
      @inline private[modeldb] def readSvExValue(_iprot: TProtocol): modeldb.ServerLogicException = {
        modeldb.ServerLogicException.decode(_iprot)
      }
    
      @inline private def writeSvExField(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SvExField)
        writeSvExValue(svEx_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSvExValue(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        svEx_item.write(_oprot)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[Boolean],
        val rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException],
        val svEx: _root_.scala.Option[modeldb.ServerLogicException],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[Boolean] with ThriftStruct
      with _root_.scala.Product3[Option[Boolean], Option[modeldb.ResourceNotFoundException], Option[modeldb.ServerLogicException]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
    
      def this(
        success: _root_.scala.Option[Boolean] = _root_.scala.None,
        rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ) = this(
        success,
        rnfEx,
        svEx,
        Map.empty
      )
    
      def _1: _root_.scala.Option[Boolean] = success
      def _2: _root_.scala.Option[modeldb.ResourceNotFoundException] = rnfEx
      def _3: _root_.scala.Option[modeldb.ServerLogicException] = svEx
    
      def toTuple: _root_.scala.Tuple3[Option[Boolean], Option[modeldb.ResourceNotFoundException], Option[modeldb.ServerLogicException]] = {
        (
          success,
          rnfEx,
          svEx
        )
      }
    
      def successField: Option[Boolean] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Seq(rnfEx, svEx)
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (rnfEx.isDefined) writeRnfExField(rnfEx.get, _oprot)
        if (svEx.isDefined) writeSvExField(svEx.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[Boolean] = this.success,
        rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException] = this.rnfEx,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = this.svEx,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          rnfEx,
          svEx,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 3
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case 1 => this.rnfEx
        case 2 => this.svEx
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Function1[Args,Future[Boolean]]
    type ReqRepFunctionType = Function1[_root_.com.twitter.scrooge.Request[Args],Future[_root_.com.twitter.scrooge.Response[Boolean]]]

    type ServiceIfaceServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ReqRepServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]]

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]] { request: _root_.com.twitter.scrooge.Request[Args] =>
        f(request)
      }

    private[this] val toResult = (res: SuccessType) => Result(Some(res))

    val name: String = "storeTreeModel"
    val serviceName: String = "ModelDBService"
    val argsCodec = Args
    val responseCodec = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val storeTreeModel$args = StoreTreeModel.Args
  type storeTreeModel$args = StoreTreeModel.Args

  val storeTreeModel$result = StoreTreeModel.Result
  type storeTreeModel$result = StoreTreeModel.Result

  object StorePipelineTransformEvent extends ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("storePipelineTransformEvent_args")
      val TeField: TField = new TField("te", TType.LIST, 1)
      val TeFieldManifest: Manifest[Seq[modeldb.TransformEvent]] = implicitly[Manifest[Seq[modeldb.TransformEvent]]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          TeField,
          false,
          false,
          TeFieldManifest,
          _root_.scala.None,
          _root_.scala.Some(implicitly[Manifest[modeldb.TransformEvent]]),
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.te)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          te =
            {
              val field = original.te
              field.map { field =>
                modeldb.TransformEvent.withoutPassthroughFields(field)
              }
            }
        )
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var te: Seq[modeldb.TransformEvent] = Seq[modeldb.TransformEvent]()
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.LIST =>
                    te = readTeValue(_iprot)
                  case _actualType =>
                    val _expectedType = TType.LIST
                    throw new TProtocolException(
                      "Received wrong type for field 'te' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Args(
          te,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        te: Seq[modeldb.TransformEvent] = Seq[modeldb.TransformEvent]()
      ): Args =
        new Args(
          te
        )
    
      def unapply(_item: Args): _root_.scala.Option[Seq[modeldb.TransformEvent]] = _root_.scala.Some(_item.te)
    
    
      @inline private[modeldb] def readTeValue(_iprot: TProtocol): Seq[modeldb.TransformEvent] = {
        val _list = _iprot.readListBegin()
        if (_list.size == 0) {
          _iprot.readListEnd()
          Nil
        } else {
          val _rv = new mutable$ArrayBuffer[modeldb.TransformEvent](_list.size)
          var _i = 0
          while (_i < _list.size) {
            _rv += {
              modeldb.TransformEvent.decode(_iprot)
            }
            _i += 1
          }
          _iprot.readListEnd()
          _rv
        }
      }
    
      @inline private def writeTeField(te_item: Seq[modeldb.TransformEvent], _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(TeField)
        writeTeValue(te_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeTeValue(te_item: Seq[modeldb.TransformEvent], _oprot: TProtocol): Unit = {
        _oprot.writeListBegin(new TList(TType.STRUCT, te_item.size))
        te_item match {
          case _: IndexedSeq[_] =>
            var _i = 0
            val _size = te_item.size
            while (_i < _size) {
              val te_item_element = te_item(_i)
              te_item_element.write(_oprot)
              _i += 1
            }
          case _ =>
            te_item.foreach { te_item_element =>
              te_item_element.write(_oprot)
            }
        }
        _oprot.writeListEnd()
      }
    
    
    }
    
    class Args(
        val te: Seq[modeldb.TransformEvent],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product1[Seq[modeldb.TransformEvent]]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
    
      def this(
        te: Seq[modeldb.TransformEvent] = Seq[modeldb.TransformEvent]()
      ) = this(
        te,
        Map.empty
      )
    
      def _1: Seq[modeldb.TransformEvent] = te
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        if (te ne null) writeTeField(te, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        te: Seq[modeldb.TransformEvent] = this.te,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          te,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.te
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    }

    type SuccessType = Seq[modeldb.TransformEventResponse]
    
    object Result extends ValidatingThriftStructCodec3[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("storePipelineTransformEvent_result")
      val SuccessField: TField = new TField("success", TType.LIST, 0)
      val SuccessFieldManifest: Manifest[Seq[modeldb.TransformEventResponse]] = implicitly[Manifest[Seq[modeldb.TransformEventResponse]]]
      val IerExField: TField = new TField("ierEx", TType.STRUCT, 1)
      val IerExFieldManifest: Manifest[modeldb.InvalidExperimentRunException] = implicitly[Manifest[modeldb.InvalidExperimentRunException]]
      val SvExField: TField = new TField("svEx", TType.STRUCT, 2)
      val SvExFieldManifest: Manifest[modeldb.ServerLogicException] = implicitly[Manifest[modeldb.ServerLogicException]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.Some(implicitly[Manifest[modeldb.TransformEventResponse]]),
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          IerExField,
          true,
          false,
          IerExFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          SvExField,
          true,
          false,
          SvExFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf ++= validateField(item.ierEx)
        buf ++= validateField(item.svEx)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                field.map { field =>
                  modeldb.TransformEventResponse.withoutPassthroughFields(field)
                }
              }
            },
          ierEx =
            {
              val field = original.ierEx
              field.map { field =>
                modeldb.InvalidExperimentRunException.withoutPassthroughFields(field)
              }
            },
          svEx =
            {
              val field = original.svEx
              field.map { field =>
                modeldb.ServerLogicException.withoutPassthroughFields(field)
              }
            }
        )
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[Seq[modeldb.TransformEventResponse]] = _root_.scala.None
        var ierEx: _root_.scala.Option[modeldb.InvalidExperimentRunException] = _root_.scala.None
        var svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.LIST =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.LIST
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 1 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    ierEx = _root_.scala.Some(readIerExValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'ierEx' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 2 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    svEx = _root_.scala.Some(readSvExValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'svEx' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          ierEx,
          svEx,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[Seq[modeldb.TransformEventResponse]] = _root_.scala.None,
        ierEx: _root_.scala.Option[modeldb.InvalidExperimentRunException] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ): Result =
        new Result(
          success,
          ierEx,
          svEx
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Tuple3[Option[Seq[modeldb.TransformEventResponse]], Option[modeldb.InvalidExperimentRunException], Option[modeldb.ServerLogicException]]] = _root_.scala.Some(_item.toTuple)
    
    
      @inline private[modeldb] def readSuccessValue(_iprot: TProtocol): Seq[modeldb.TransformEventResponse] = {
        val _list = _iprot.readListBegin()
        if (_list.size == 0) {
          _iprot.readListEnd()
          Nil
        } else {
          val _rv = new mutable$ArrayBuffer[modeldb.TransformEventResponse](_list.size)
          var _i = 0
          while (_i < _list.size) {
            _rv += {
              modeldb.TransformEventResponse.decode(_iprot)
            }
            _i += 1
          }
          _iprot.readListEnd()
          _rv
        }
      }
    
      @inline private def writeSuccessField(success_item: Seq[modeldb.TransformEventResponse], _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: Seq[modeldb.TransformEventResponse], _oprot: TProtocol): Unit = {
        _oprot.writeListBegin(new TList(TType.STRUCT, success_item.size))
        success_item match {
          case _: IndexedSeq[_] =>
            var _i = 0
            val _size = success_item.size
            while (_i < _size) {
              val success_item_element = success_item(_i)
              success_item_element.write(_oprot)
              _i += 1
            }
          case _ =>
            success_item.foreach { success_item_element =>
              success_item_element.write(_oprot)
            }
        }
        _oprot.writeListEnd()
      }
    
      @inline private[modeldb] def readIerExValue(_iprot: TProtocol): modeldb.InvalidExperimentRunException = {
        modeldb.InvalidExperimentRunException.decode(_iprot)
      }
    
      @inline private def writeIerExField(ierEx_item: modeldb.InvalidExperimentRunException, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(IerExField)
        writeIerExValue(ierEx_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeIerExValue(ierEx_item: modeldb.InvalidExperimentRunException, _oprot: TProtocol): Unit = {
        ierEx_item.write(_oprot)
      }
    
      @inline private[modeldb] def readSvExValue(_iprot: TProtocol): modeldb.ServerLogicException = {
        modeldb.ServerLogicException.decode(_iprot)
      }
    
      @inline private def writeSvExField(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SvExField)
        writeSvExValue(svEx_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSvExValue(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        svEx_item.write(_oprot)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[Seq[modeldb.TransformEventResponse]],
        val ierEx: _root_.scala.Option[modeldb.InvalidExperimentRunException],
        val svEx: _root_.scala.Option[modeldb.ServerLogicException],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[Seq[modeldb.TransformEventResponse]] with ThriftStruct
      with _root_.scala.Product3[Option[Seq[modeldb.TransformEventResponse]], Option[modeldb.InvalidExperimentRunException], Option[modeldb.ServerLogicException]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
    
      def this(
        success: _root_.scala.Option[Seq[modeldb.TransformEventResponse]] = _root_.scala.None,
        ierEx: _root_.scala.Option[modeldb.InvalidExperimentRunException] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ) = this(
        success,
        ierEx,
        svEx,
        Map.empty
      )
    
      def _1: _root_.scala.Option[Seq[modeldb.TransformEventResponse]] = success
      def _2: _root_.scala.Option[modeldb.InvalidExperimentRunException] = ierEx
      def _3: _root_.scala.Option[modeldb.ServerLogicException] = svEx
    
      def toTuple: _root_.scala.Tuple3[Option[Seq[modeldb.TransformEventResponse]], Option[modeldb.InvalidExperimentRunException], Option[modeldb.ServerLogicException]] = {
        (
          success,
          ierEx,
          svEx
        )
      }
    
      def successField: Option[Seq[modeldb.TransformEventResponse]] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Seq(ierEx, svEx)
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (ierEx.isDefined) writeIerExField(ierEx.get, _oprot)
        if (svEx.isDefined) writeSvExField(svEx.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[Seq[modeldb.TransformEventResponse]] = this.success,
        ierEx: _root_.scala.Option[modeldb.InvalidExperimentRunException] = this.ierEx,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = this.svEx,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          ierEx,
          svEx,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 3
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case 1 => this.ierEx
        case 2 => this.svEx
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Function1[Args,Future[Seq[modeldb.TransformEventResponse]]]
    type ReqRepFunctionType = Function1[_root_.com.twitter.scrooge.Request[Args],Future[_root_.com.twitter.scrooge.Response[Seq[modeldb.TransformEventResponse]]]]

    type ServiceIfaceServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ReqRepServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]]

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]] { request: _root_.com.twitter.scrooge.Request[Args] =>
        f(request)
      }

    private[this] val toResult = (res: SuccessType) => Result(Some(res))

    val name: String = "storePipelineTransformEvent"
    val serviceName: String = "ModelDBService"
    val argsCodec = Args
    val responseCodec = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val storePipelineTransformEvent$args = StorePipelineTransformEvent.Args
  type storePipelineTransformEvent$args = StorePipelineTransformEvent.Args

  val storePipelineTransformEvent$result = StorePipelineTransformEvent.Result
  type storePipelineTransformEvent$result = StorePipelineTransformEvent.Result

  object ComputeModelAncestry extends ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("computeModelAncestry_args")
      val ModelIdField: TField = new TField("modelId", TType.I32, 1)
      val ModelIdFieldManifest: Manifest[Int] = implicitly[Manifest[Int]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          ModelIdField,
          false,
          false,
          ModelIdFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.modelId)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          modelId =
            {
              val field = original.modelId
              field
            }
        )
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var modelId: Int = 0
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.I32 =>
                    modelId = readModelIdValue(_iprot)
                  case _actualType =>
                    val _expectedType = TType.I32
                    throw new TProtocolException(
                      "Received wrong type for field 'modelId' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Args(
          modelId,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        modelId: Int
      ): Args =
        new Args(
          modelId
        )
    
      def unapply(_item: Args): _root_.scala.Option[Int] = _root_.scala.Some(_item.modelId)
    
    
      @inline private[modeldb] def readModelIdValue(_iprot: TProtocol): Int = {
        _iprot.readI32()
      }
    
      @inline private def writeModelIdField(modelId_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(ModelIdField)
        writeModelIdValue(modelId_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeModelIdValue(modelId_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeI32(modelId_item)
      }
    
    
    }
    
    class Args(
        val modelId: Int,
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product1[Int]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
    
      def this(
        modelId: Int
      ) = this(
        modelId,
        Map.empty
      )
    
      def _1: Int = modelId
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        writeModelIdField(modelId, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        modelId: Int = this.modelId,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          modelId,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.modelId
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    }

    type SuccessType = modeldb.ModelAncestryResponse
    
    object Result extends ValidatingThriftStructCodec3[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("computeModelAncestry_result")
      val SuccessField: TField = new TField("success", TType.STRUCT, 0)
      val SuccessFieldManifest: Manifest[modeldb.ModelAncestryResponse] = implicitly[Manifest[modeldb.ModelAncestryResponse]]
      val RnfExField: TField = new TField("rnfEx", TType.STRUCT, 1)
      val RnfExFieldManifest: Manifest[modeldb.ResourceNotFoundException] = implicitly[Manifest[modeldb.ResourceNotFoundException]]
      val SvExField: TField = new TField("svEx", TType.STRUCT, 2)
      val SvExFieldManifest: Manifest[modeldb.ServerLogicException] = implicitly[Manifest[modeldb.ServerLogicException]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          RnfExField,
          true,
          false,
          RnfExFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          SvExField,
          true,
          false,
          SvExFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf ++= validateField(item.rnfEx)
        buf ++= validateField(item.svEx)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                modeldb.ModelAncestryResponse.withoutPassthroughFields(field)
              }
            },
          rnfEx =
            {
              val field = original.rnfEx
              field.map { field =>
                modeldb.ResourceNotFoundException.withoutPassthroughFields(field)
              }
            },
          svEx =
            {
              val field = original.svEx
              field.map { field =>
                modeldb.ServerLogicException.withoutPassthroughFields(field)
              }
            }
        )
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[modeldb.ModelAncestryResponse] = _root_.scala.None
        var rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException] = _root_.scala.None
        var svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 1 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    rnfEx = _root_.scala.Some(readRnfExValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'rnfEx' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 2 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    svEx = _root_.scala.Some(readSvExValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'svEx' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          rnfEx,
          svEx,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[modeldb.ModelAncestryResponse] = _root_.scala.None,
        rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ): Result =
        new Result(
          success,
          rnfEx,
          svEx
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Tuple3[Option[modeldb.ModelAncestryResponse], Option[modeldb.ResourceNotFoundException], Option[modeldb.ServerLogicException]]] = _root_.scala.Some(_item.toTuple)
    
    
      @inline private[modeldb] def readSuccessValue(_iprot: TProtocol): modeldb.ModelAncestryResponse = {
        modeldb.ModelAncestryResponse.decode(_iprot)
      }
    
      @inline private def writeSuccessField(success_item: modeldb.ModelAncestryResponse, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: modeldb.ModelAncestryResponse, _oprot: TProtocol): Unit = {
        success_item.write(_oprot)
      }
    
      @inline private[modeldb] def readRnfExValue(_iprot: TProtocol): modeldb.ResourceNotFoundException = {
        modeldb.ResourceNotFoundException.decode(_iprot)
      }
    
      @inline private def writeRnfExField(rnfEx_item: modeldb.ResourceNotFoundException, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(RnfExField)
        writeRnfExValue(rnfEx_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeRnfExValue(rnfEx_item: modeldb.ResourceNotFoundException, _oprot: TProtocol): Unit = {
        rnfEx_item.write(_oprot)
      }
    
      @inline private[modeldb] def readSvExValue(_iprot: TProtocol): modeldb.ServerLogicException = {
        modeldb.ServerLogicException.decode(_iprot)
      }
    
      @inline private def writeSvExField(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SvExField)
        writeSvExValue(svEx_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSvExValue(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        svEx_item.write(_oprot)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[modeldb.ModelAncestryResponse],
        val rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException],
        val svEx: _root_.scala.Option[modeldb.ServerLogicException],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[modeldb.ModelAncestryResponse] with ThriftStruct
      with _root_.scala.Product3[Option[modeldb.ModelAncestryResponse], Option[modeldb.ResourceNotFoundException], Option[modeldb.ServerLogicException]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
    
      def this(
        success: _root_.scala.Option[modeldb.ModelAncestryResponse] = _root_.scala.None,
        rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ) = this(
        success,
        rnfEx,
        svEx,
        Map.empty
      )
    
      def _1: _root_.scala.Option[modeldb.ModelAncestryResponse] = success
      def _2: _root_.scala.Option[modeldb.ResourceNotFoundException] = rnfEx
      def _3: _root_.scala.Option[modeldb.ServerLogicException] = svEx
    
      def toTuple: _root_.scala.Tuple3[Option[modeldb.ModelAncestryResponse], Option[modeldb.ResourceNotFoundException], Option[modeldb.ServerLogicException]] = {
        (
          success,
          rnfEx,
          svEx
        )
      }
    
      def successField: Option[modeldb.ModelAncestryResponse] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Seq(rnfEx, svEx)
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (rnfEx.isDefined) writeRnfExField(rnfEx.get, _oprot)
        if (svEx.isDefined) writeSvExField(svEx.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[modeldb.ModelAncestryResponse] = this.success,
        rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException] = this.rnfEx,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = this.svEx,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          rnfEx,
          svEx,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 3
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case 1 => this.rnfEx
        case 2 => this.svEx
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Function1[Args,Future[modeldb.ModelAncestryResponse]]
    type ReqRepFunctionType = Function1[_root_.com.twitter.scrooge.Request[Args],Future[_root_.com.twitter.scrooge.Response[modeldb.ModelAncestryResponse]]]

    type ServiceIfaceServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ReqRepServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]]

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]] { request: _root_.com.twitter.scrooge.Request[Args] =>
        f(request)
      }

    private[this] val toResult = (res: SuccessType) => Result(Some(res))

    val name: String = "computeModelAncestry"
    val serviceName: String = "ModelDBService"
    val argsCodec = Args
    val responseCodec = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val computeModelAncestry$args = ComputeModelAncestry.Args
  type computeModelAncestry$args = ComputeModelAncestry.Args

  val computeModelAncestry$result = ComputeModelAncestry.Result
  type computeModelAncestry$result = ComputeModelAncestry.Result

  object ExtractPipeline extends ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("extractPipeline_args")
      val ModelIdField: TField = new TField("modelId", TType.I32, 1)
      val ModelIdFieldManifest: Manifest[Int] = implicitly[Manifest[Int]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          ModelIdField,
          false,
          false,
          ModelIdFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.modelId)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          modelId =
            {
              val field = original.modelId
              field
            }
        )
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var modelId: Int = 0
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.I32 =>
                    modelId = readModelIdValue(_iprot)
                  case _actualType =>
                    val _expectedType = TType.I32
                    throw new TProtocolException(
                      "Received wrong type for field 'modelId' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Args(
          modelId,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        modelId: Int
      ): Args =
        new Args(
          modelId
        )
    
      def unapply(_item: Args): _root_.scala.Option[Int] = _root_.scala.Some(_item.modelId)
    
    
      @inline private[modeldb] def readModelIdValue(_iprot: TProtocol): Int = {
        _iprot.readI32()
      }
    
      @inline private def writeModelIdField(modelId_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(ModelIdField)
        writeModelIdValue(modelId_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeModelIdValue(modelId_item: Int, _oprot: TProtocol): Unit = {
        _oprot.writeI32(modelId_item)
      }
    
    
    }
    
    class Args(
        val modelId: Int,
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product1[Int]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
    
      def this(
        modelId: Int
      ) = this(
        modelId,
        Map.empty
      )
    
      def _1: Int = modelId
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        writeModelIdField(modelId, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        modelId: Int = this.modelId,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          modelId,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.modelId
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    }

    type SuccessType = modeldb.ExtractedPipelineResponse
    
    object Result extends ValidatingThriftStructCodec3[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("extractPipeline_result")
      val SuccessField: TField = new TField("success", TType.STRUCT, 0)
      val SuccessFieldManifest: Manifest[modeldb.ExtractedPipelineResponse] = implicitly[Manifest[modeldb.ExtractedPipelineResponse]]
      val RnfExField: TField = new TField("rnfEx", TType.STRUCT, 1)
      val RnfExFieldManifest: Manifest[modeldb.ResourceNotFoundException] = implicitly[Manifest[modeldb.ResourceNotFoundException]]
      val SvExField: TField = new TField("svEx", TType.STRUCT, 2)
      val SvExFieldManifest: Manifest[modeldb.ServerLogicException] = implicitly[Manifest[modeldb.ServerLogicException]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          RnfExField,
          true,
          false,
          RnfExFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        ),
        new ThriftStructFieldInfo(
          SvExField,
          true,
          false,
          SvExFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf ++= validateField(item.rnfEx)
        buf ++= validateField(item.svEx)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                modeldb.ExtractedPipelineResponse.withoutPassthroughFields(field)
              }
            },
          rnfEx =
            {
              val field = original.rnfEx
              field.map { field =>
                modeldb.ResourceNotFoundException.withoutPassthroughFields(field)
              }
            },
          svEx =
            {
              val field = original.svEx
              field.map { field =>
                modeldb.ServerLogicException.withoutPassthroughFields(field)
              }
            }
        )
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[modeldb.ExtractedPipelineResponse] = _root_.scala.None
        var rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException] = _root_.scala.None
        var svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 1 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    rnfEx = _root_.scala.Some(readRnfExValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'rnfEx' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case 2 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    svEx = _root_.scala.Some(readSvExValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'svEx' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          rnfEx,
          svEx,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[modeldb.ExtractedPipelineResponse] = _root_.scala.None,
        rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ): Result =
        new Result(
          success,
          rnfEx,
          svEx
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Tuple3[Option[modeldb.ExtractedPipelineResponse], Option[modeldb.ResourceNotFoundException], Option[modeldb.ServerLogicException]]] = _root_.scala.Some(_item.toTuple)
    
    
      @inline private[modeldb] def readSuccessValue(_iprot: TProtocol): modeldb.ExtractedPipelineResponse = {
        modeldb.ExtractedPipelineResponse.decode(_iprot)
      }
    
      @inline private def writeSuccessField(success_item: modeldb.ExtractedPipelineResponse, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: modeldb.ExtractedPipelineResponse, _oprot: TProtocol): Unit = {
        success_item.write(_oprot)
      }
    
      @inline private[modeldb] def readRnfExValue(_iprot: TProtocol): modeldb.ResourceNotFoundException = {
        modeldb.ResourceNotFoundException.decode(_iprot)
      }
    
      @inline private def writeRnfExField(rnfEx_item: modeldb.ResourceNotFoundException, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(RnfExField)
        writeRnfExValue(rnfEx_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeRnfExValue(rnfEx_item: modeldb.ResourceNotFoundException, _oprot: TProtocol): Unit = {
        rnfEx_item.write(_oprot)
      }
    
      @inline private[modeldb] def readSvExValue(_iprot: TProtocol): modeldb.ServerLogicException = {
        modeldb.ServerLogicException.decode(_iprot)
      }
    
      @inline private def writeSvExField(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SvExField)
        writeSvExValue(svEx_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSvExValue(svEx_item: modeldb.ServerLogicException, _oprot: TProtocol): Unit = {
        svEx_item.write(_oprot)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[modeldb.ExtractedPipelineResponse],
        val rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException],
        val svEx: _root_.scala.Option[modeldb.ServerLogicException],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[modeldb.ExtractedPipelineResponse] with ThriftStruct
      with _root_.scala.Product3[Option[modeldb.ExtractedPipelineResponse], Option[modeldb.ResourceNotFoundException], Option[modeldb.ServerLogicException]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
    
      def this(
        success: _root_.scala.Option[modeldb.ExtractedPipelineResponse] = _root_.scala.None,
        rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException] = _root_.scala.None,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = _root_.scala.None
      ) = this(
        success,
        rnfEx,
        svEx,
        Map.empty
      )
    
      def _1: _root_.scala.Option[modeldb.ExtractedPipelineResponse] = success
      def _2: _root_.scala.Option[modeldb.ResourceNotFoundException] = rnfEx
      def _3: _root_.scala.Option[modeldb.ServerLogicException] = svEx
    
      def toTuple: _root_.scala.Tuple3[Option[modeldb.ExtractedPipelineResponse], Option[modeldb.ResourceNotFoundException], Option[modeldb.ServerLogicException]] = {
        (
          success,
          rnfEx,
          svEx
        )
      }
    
      def successField: Option[modeldb.ExtractedPipelineResponse] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Seq(rnfEx, svEx)
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (rnfEx.isDefined) writeRnfExField(rnfEx.get, _oprot)
        if (svEx.isDefined) writeSvExField(svEx.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[modeldb.ExtractedPipelineResponse] = this.success,
        rnfEx: _root_.scala.Option[modeldb.ResourceNotFoundException] = this.rnfEx,
        svEx: _root_.scala.Option[modeldb.ServerLogicException] = this.svEx,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          rnfEx,
          svEx,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result])
    
      override def hashCode: Int = {
        var hash = _root_.scala.runtime.ScalaRunTime._hashCode(this)
        hash
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 3
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case 1 => this.rnfEx
        case 2 => this.svEx
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Function1[Args,Future[modeldb.ExtractedPipelineResponse]]
    type ReqRepFunctionType = Function1[_root_.com.twitter.scrooge.Request[Args],Future[_root_.com.twitter.scrooge.Response[modeldb.ExtractedPipelineResponse]]]

    type ServiceIfaceServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[Args, SuccessType]
    type ReqRepServicePerEndpointServiceType = _root_.com.twitter.finagle.Service[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]]

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk { args: Args =>
        f(args)
      }

    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType =
      _root_.com.twitter.finagle.Service.mk[_root_.com.twitter.scrooge.Request[Args], _root_.com.twitter.scrooge.Response[SuccessType]] { request: _root_.com.twitter.scrooge.Request[Args] =>
        f(request)
      }

    private[this] val toResult = (res: SuccessType) => Result(Some(res))

    val name: String = "extractPipeline"
    val serviceName: String = "ModelDBService"
    val argsCodec = Args
    val responseCodec = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val extractPipeline$args = ExtractPipeline.Args
  type extractPipeline$args = ExtractPipeline.Args

  val extractPipeline$result = ExtractPipeline.Result
  type extractPipeline$result = ExtractPipeline.Result


  trait MethodPerEndpoint
    extends ModelDBService[Future] {
    
    def testConnection(): Future[Int]
    
    def storeDataFrame(df: modeldb.DataFrame, experimentRunId: Int): Future[Int]
    
    def pathForTransformer(transformerId: Int): Future[String]
    
    def storeFitEvent(fe: modeldb.FitEvent): Future[modeldb.FitEventResponse]
    
    def storeMetricEvent(me: modeldb.MetricEvent): Future[modeldb.MetricEventResponse]
    
    def getFilePath(t: modeldb.Transformer, experimentRunId: Int, filename: String): Future[String]
    
    def storeTransformEvent(te: modeldb.TransformEvent): Future[modeldb.TransformEventResponse]
    
    def storeRandomSplitEvent(rse: modeldb.RandomSplitEvent): Future[modeldb.RandomSplitEventResponse]
    
    def storePipelineEvent(pipelineEvent: modeldb.PipelineEvent): Future[modeldb.PipelineEventResponse]
    
    def storeCrossValidationEvent(cve: modeldb.CrossValidationEvent): Future[modeldb.CrossValidationEventResponse]
    
    def storeGridSearchCrossValidationEvent(gscve: modeldb.GridSearchCrossValidationEvent): Future[modeldb.GridSearchCrossValidationEventResponse]
    
    def storeAnnotationEvent(ae: modeldb.AnnotationEvent): Future[modeldb.AnnotationEventResponse]
    
    def storeProjectEvent(pr: modeldb.ProjectEvent): Future[modeldb.ProjectEventResponse]
    
    def storeExperimentEvent(er: modeldb.ExperimentEvent): Future[modeldb.ExperimentEventResponse]
    
    def storeExperimentRunEvent(er: modeldb.ExperimentRunEvent): Future[modeldb.ExperimentRunEventResponse]
    
    def storeLinearModel(modelId: Int, model: modeldb.LinearModel): Future[Boolean]
    
    def getDataFrameAncestry(dataFrameId: Int): Future[modeldb.DataFrameAncestry]
    
    def getCommonAncestor(dfId1: Int, dfId2: Int): Future[modeldb.CommonAncestor]
    
    def getCommonAncestorForModels(modelId1: Int, modelId2: Int): Future[modeldb.CommonAncestor]
    
    def getTrainingRowsCount(modelId: Int): Future[Int]
    
    def getTrainingRowsCounts(modelIds: Seq[Int] = Seq[Int]()): Future[Seq[Int]]
    
    def compareHyperparameters(modelId1: Int, modelId2: Int): Future[modeldb.CompareHyperParametersResponse]
    
    def compareFeatures(modelId1: Int, modelId2: Int): Future[modeldb.CompareFeaturesResponse]
    
    def groupByProblemType(modelIds: Seq[Int] = Seq[Int]()): Future[Map[modeldb.ProblemType, Seq[Int]]]
    
    def similarModels(modelId: Int, compMetrics: Seq[modeldb.ModelCompMetric] = Seq[modeldb.ModelCompMetric](), numModels: Int): Future[Seq[Int]]
    
    def linearModelFeatureImportances(modelId: Int): Future[Seq[String]]
    
    def compareLinearModelFeatureImportances(model1Id: Int, model2Id: Int): Future[Seq[modeldb.FeatureImportanceComparison]]
    
    def iterationsUntilConvergence(modelIds: Seq[Int] = Seq[Int](), tolerance: Double): Future[Seq[Int]]
    
    def rankModels(modelIds: Seq[Int] = Seq[Int](), metric: modeldb.ModelRankMetric): Future[Seq[Int]]
    
    def confidenceIntervals(modelId: Int, sigLevel: Double): Future[Seq[modeldb.ConfidenceInterval]]
    
    def modelsWithFeatures(featureNames: Seq[String] = Seq[String]()): Future[Seq[Int]]
    
    def modelsDerivedFromDataFrame(dfId: Int): Future[Seq[Int]]
    
    def getProjectIds(keyValuePairs: Map[String, String] = Map[String, String]()): Future[Seq[Int]]
    
    def getModelIds(keyValuePairs: Map[String, String] = Map[String, String]()): Future[Seq[Int]]
    
    def updateProject(projectId: Int, key: String, value: String): Future[Boolean]
    
    def createOrUpdateScalarField(modelId: Int, key: String, value: String, valueType: String): Future[Boolean]
    
    def createVectorField(modelId: Int, vectorName: String, vectorConfig: Map[String, String] = Map[String, String]()): Future[Boolean]
    
    def updateVectorField(modelId: Int, key: String, valueIndex: Int, value: String, valueType: String): Future[Boolean]
    
    def appendToVectorField(modelId: Int, vectorName: String, value: String, valueType: String): Future[Boolean]
    
    def getModel(modelId: Int): Future[modeldb.ModelResponse]
    
    def getRunsInExperiment(experimentId: Int): Future[Seq[modeldb.ExperimentRun]]
    
    def getRunsAndExperimentsInProject(projId: Int): Future[modeldb.ProjectExperimentsAndRuns]
    
    def getProjectOverviews(): Future[Seq[modeldb.ProjectOverviewResponse]]
    
    def getExperimentRunDetails(experimentRunId: Int): Future[modeldb.ExperimentRunDetailsResponse]
    
    def originalFeatures(modelId: Int): Future[Seq[String]]
    
    def storeTreeModel(modelId: Int, model: modeldb.TreeModel): Future[Boolean]
    
    def storePipelineTransformEvent(te: Seq[modeldb.TransformEvent] = Seq[modeldb.TransformEvent]()): Future[Seq[modeldb.TransformEventResponse]]
    
    def computeModelAncestry(modelId: Int): Future[modeldb.ModelAncestryResponse]
    
    def extractPipeline(modelId: Int): Future[modeldb.ExtractedPipelineResponse]
  }

  object MethodPerEndpoint {

    def apply(servicePerEndpoint: ServicePerEndpoint): MethodPerEndpoint = {
      new MethodPerEndpointImpl(servicePerEndpoint) {}
    }

    /**
     * Use `MethodPerEndpoint.apply()` instead of this constructor.
     */
    class MethodPerEndpointImpl protected (servicePerEndpoint: ServicePerEndpoint)
      extends MethodPerEndpoint {
        def testConnection(): Future[Int] =
          servicePerEndpoint.testConnection(self.TestConnection.Args())
        def storeDataFrame(df: modeldb.DataFrame, experimentRunId: Int): Future[Int] =
          servicePerEndpoint.storeDataFrame(self.StoreDataFrame.Args(df, experimentRunId))
        def pathForTransformer(transformerId: Int): Future[String] =
          servicePerEndpoint.pathForTransformer(self.PathForTransformer.Args(transformerId))
        def storeFitEvent(fe: modeldb.FitEvent): Future[modeldb.FitEventResponse] =
          servicePerEndpoint.storeFitEvent(self.StoreFitEvent.Args(fe))
        def storeMetricEvent(me: modeldb.MetricEvent): Future[modeldb.MetricEventResponse] =
          servicePerEndpoint.storeMetricEvent(self.StoreMetricEvent.Args(me))
        def getFilePath(t: modeldb.Transformer, experimentRunId: Int, filename: String): Future[String] =
          servicePerEndpoint.getFilePath(self.GetFilePath.Args(t, experimentRunId, filename))
        def storeTransformEvent(te: modeldb.TransformEvent): Future[modeldb.TransformEventResponse] =
          servicePerEndpoint.storeTransformEvent(self.StoreTransformEvent.Args(te))
        def storeRandomSplitEvent(rse: modeldb.RandomSplitEvent): Future[modeldb.RandomSplitEventResponse] =
          servicePerEndpoint.storeRandomSplitEvent(self.StoreRandomSplitEvent.Args(rse))
        def storePipelineEvent(pipelineEvent: modeldb.PipelineEvent): Future[modeldb.PipelineEventResponse] =
          servicePerEndpoint.storePipelineEvent(self.StorePipelineEvent.Args(pipelineEvent))
        def storeCrossValidationEvent(cve: modeldb.CrossValidationEvent): Future[modeldb.CrossValidationEventResponse] =
          servicePerEndpoint.storeCrossValidationEvent(self.StoreCrossValidationEvent.Args(cve))
        def storeGridSearchCrossValidationEvent(gscve: modeldb.GridSearchCrossValidationEvent): Future[modeldb.GridSearchCrossValidationEventResponse] =
          servicePerEndpoint.storeGridSearchCrossValidationEvent(self.StoreGridSearchCrossValidationEvent.Args(gscve))
        def storeAnnotationEvent(ae: modeldb.AnnotationEvent): Future[modeldb.AnnotationEventResponse] =
          servicePerEndpoint.storeAnnotationEvent(self.StoreAnnotationEvent.Args(ae))
        def storeProjectEvent(pr: modeldb.ProjectEvent): Future[modeldb.ProjectEventResponse] =
          servicePerEndpoint.storeProjectEvent(self.StoreProjectEvent.Args(pr))
        def storeExperimentEvent(er: modeldb.ExperimentEvent): Future[modeldb.ExperimentEventResponse] =
          servicePerEndpoint.storeExperimentEvent(self.StoreExperimentEvent.Args(er))
        def storeExperimentRunEvent(er: modeldb.ExperimentRunEvent): Future[modeldb.ExperimentRunEventResponse] =
          servicePerEndpoint.storeExperimentRunEvent(self.StoreExperimentRunEvent.Args(er))
        def storeLinearModel(modelId: Int, model: modeldb.LinearModel): Future[Boolean] =
          servicePerEndpoint.storeLinearModel(self.StoreLinearModel.Args(modelId, model))
        def getDataFrameAncestry(dataFrameId: Int): Future[modeldb.DataFrameAncestry] =
          servicePerEndpoint.getDataFrameAncestry(self.GetDataFrameAncestry.Args(dataFrameId))
        def getCommonAncestor(dfId1: Int, dfId2: Int): Future[modeldb.CommonAncestor] =
          servicePerEndpoint.getCommonAncestor(self.GetCommonAncestor.Args(dfId1, dfId2))
        def getCommonAncestorForModels(modelId1: Int, modelId2: Int): Future[modeldb.CommonAncestor] =
          servicePerEndpoint.getCommonAncestorForModels(self.GetCommonAncestorForModels.Args(modelId1, modelId2))
        def getTrainingRowsCount(modelId: Int): Future[Int] =
          servicePerEndpoint.getTrainingRowsCount(self.GetTrainingRowsCount.Args(modelId))
        def getTrainingRowsCounts(modelIds: Seq[Int] = Seq[Int]()): Future[Seq[Int]] =
          servicePerEndpoint.getTrainingRowsCounts(self.GetTrainingRowsCounts.Args(modelIds))
        def compareHyperparameters(modelId1: Int, modelId2: Int): Future[modeldb.CompareHyperParametersResponse] =
          servicePerEndpoint.compareHyperparameters(self.CompareHyperparameters.Args(modelId1, modelId2))
        def compareFeatures(modelId1: Int, modelId2: Int): Future[modeldb.CompareFeaturesResponse] =
          servicePerEndpoint.compareFeatures(self.CompareFeatures.Args(modelId1, modelId2))
        def groupByProblemType(modelIds: Seq[Int] = Seq[Int]()): Future[Map[modeldb.ProblemType, Seq[Int]]] =
          servicePerEndpoint.groupByProblemType(self.GroupByProblemType.Args(modelIds))
        def similarModels(modelId: Int, compMetrics: Seq[modeldb.ModelCompMetric] = Seq[modeldb.ModelCompMetric](), numModels: Int): Future[Seq[Int]] =
          servicePerEndpoint.similarModels(self.SimilarModels.Args(modelId, compMetrics, numModels))
        def linearModelFeatureImportances(modelId: Int): Future[Seq[String]] =
          servicePerEndpoint.linearModelFeatureImportances(self.LinearModelFeatureImportances.Args(modelId))
        def compareLinearModelFeatureImportances(model1Id: Int, model2Id: Int): Future[Seq[modeldb.FeatureImportanceComparison]] =
          servicePerEndpoint.compareLinearModelFeatureImportances(self.CompareLinearModelFeatureImportances.Args(model1Id, model2Id))
        def iterationsUntilConvergence(modelIds: Seq[Int] = Seq[Int](), tolerance: Double): Future[Seq[Int]] =
          servicePerEndpoint.iterationsUntilConvergence(self.IterationsUntilConvergence.Args(modelIds, tolerance))
        def rankModels(modelIds: Seq[Int] = Seq[Int](), metric: modeldb.ModelRankMetric): Future[Seq[Int]] =
          servicePerEndpoint.rankModels(self.RankModels.Args(modelIds, metric))
        def confidenceIntervals(modelId: Int, sigLevel: Double): Future[Seq[modeldb.ConfidenceInterval]] =
          servicePerEndpoint.confidenceIntervals(self.ConfidenceIntervals.Args(modelId, sigLevel))
        def modelsWithFeatures(featureNames: Seq[String] = Seq[String]()): Future[Seq[Int]] =
          servicePerEndpoint.modelsWithFeatures(self.ModelsWithFeatures.Args(featureNames))
        def modelsDerivedFromDataFrame(dfId: Int): Future[Seq[Int]] =
          servicePerEndpoint.modelsDerivedFromDataFrame(self.ModelsDerivedFromDataFrame.Args(dfId))
        def getProjectIds(keyValuePairs: Map[String, String] = Map[String, String]()): Future[Seq[Int]] =
          servicePerEndpoint.getProjectIds(self.GetProjectIds.Args(keyValuePairs))
        def getModelIds(keyValuePairs: Map[String, String] = Map[String, String]()): Future[Seq[Int]] =
          servicePerEndpoint.getModelIds(self.GetModelIds.Args(keyValuePairs))
        def updateProject(projectId: Int, key: String, value: String): Future[Boolean] =
          servicePerEndpoint.updateProject(self.UpdateProject.Args(projectId, key, value))
        def createOrUpdateScalarField(modelId: Int, key: String, value: String, valueType: String): Future[Boolean] =
          servicePerEndpoint.createOrUpdateScalarField(self.CreateOrUpdateScalarField.Args(modelId, key, value, valueType))
        def createVectorField(modelId: Int, vectorName: String, vectorConfig: Map[String, String] = Map[String, String]()): Future[Boolean] =
          servicePerEndpoint.createVectorField(self.CreateVectorField.Args(modelId, vectorName, vectorConfig))
        def updateVectorField(modelId: Int, key: String, valueIndex: Int, value: String, valueType: String): Future[Boolean] =
          servicePerEndpoint.updateVectorField(self.UpdateVectorField.Args(modelId, key, valueIndex, value, valueType))
        def appendToVectorField(modelId: Int, vectorName: String, value: String, valueType: String): Future[Boolean] =
          servicePerEndpoint.appendToVectorField(self.AppendToVectorField.Args(modelId, vectorName, value, valueType))
        def getModel(modelId: Int): Future[modeldb.ModelResponse] =
          servicePerEndpoint.getModel(self.GetModel.Args(modelId))
        def getRunsInExperiment(experimentId: Int): Future[Seq[modeldb.ExperimentRun]] =
          servicePerEndpoint.getRunsInExperiment(self.GetRunsInExperiment.Args(experimentId))
        def getRunsAndExperimentsInProject(projId: Int): Future[modeldb.ProjectExperimentsAndRuns] =
          servicePerEndpoint.getRunsAndExperimentsInProject(self.GetRunsAndExperimentsInProject.Args(projId))
        def getProjectOverviews(): Future[Seq[modeldb.ProjectOverviewResponse]] =
          servicePerEndpoint.getProjectOverviews(self.GetProjectOverviews.Args())
        def getExperimentRunDetails(experimentRunId: Int): Future[modeldb.ExperimentRunDetailsResponse] =
          servicePerEndpoint.getExperimentRunDetails(self.GetExperimentRunDetails.Args(experimentRunId))
        def originalFeatures(modelId: Int): Future[Seq[String]] =
          servicePerEndpoint.originalFeatures(self.OriginalFeatures.Args(modelId))
        def storeTreeModel(modelId: Int, model: modeldb.TreeModel): Future[Boolean] =
          servicePerEndpoint.storeTreeModel(self.StoreTreeModel.Args(modelId, model))
        def storePipelineTransformEvent(te: Seq[modeldb.TransformEvent] = Seq[modeldb.TransformEvent]()): Future[Seq[modeldb.TransformEventResponse]] =
          servicePerEndpoint.storePipelineTransformEvent(self.StorePipelineTransformEvent.Args(te))
        def computeModelAncestry(modelId: Int): Future[modeldb.ModelAncestryResponse] =
          servicePerEndpoint.computeModelAncestry(self.ComputeModelAncestry.Args(modelId))
        def extractPipeline(modelId: Int): Future[modeldb.ExtractedPipelineResponse] =
          servicePerEndpoint.extractPipeline(self.ExtractPipeline.Args(modelId))

        override def asClosable: _root_.com.twitter.util.Closable =
          servicePerEndpoint.asClosable
    }
  }

  object ReqRepMethodPerEndpoint {

    def apply(servicePerEndpoint: ReqRepServicePerEndpoint): MethodPerEndpoint =
      new ReqRepMethodPerEndpointImpl(servicePerEndpoint) { }

    /**
     * Use `ReqRepMethodPerEndpoint.apply()` instead of this constructor.
     */
    class ReqRepMethodPerEndpointImpl protected (servicePerEndpoint: ReqRepServicePerEndpoint)
      extends MethodPerEndpoint {

        def testConnection(): Future[Int] = {
          val requestCtx = _root_.com.twitter.finagle.context.Contexts.local.getOrElse(_root_.com.twitter.finagle.thrift.Headers.Request.Key, () => _root_.com.twitter.finagle.thrift.Headers.Request.newValues)
          val scroogeRequest = _root_.com.twitter.scrooge.Request(requestCtx.values, self.TestConnection.Args())
          servicePerEndpoint.testConnection(scroogeRequest).transform(_root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint.transformResult(_))
        }
        def storeDataFrame(df: modeldb.DataFrame, experimentRunId: Int): Future[Int] = {
          val requestCtx = _root_.com.twitter.finagle.context.Contexts.local.getOrElse(_root_.com.twitter.finagle.thrift.Headers.Request.Key, () => _root_.com.twitter.finagle.thrift.Headers.Request.newValues)
          val scroogeRequest = _root_.com.twitter.scrooge.Request(requestCtx.values, self.StoreDataFrame.Args(df, experimentRunId))
          servicePerEndpoint.storeDataFrame(scroogeRequest).transform(_root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint.transformResult(_))
        }
        def pathForTransformer(transformerId: Int): Future[String] = {
          val requestCtx = _root_.com.twitter.finagle.context.Contexts.local.getOrElse(_root_.com.twitter.finagle.thrift.Headers.Request.Key, () => _root_.com.twitter.finagle.thrift.Headers.Request.newValues)
          val scroogeRequest = _root_.com.twitter.scrooge.Request(requestCtx.values, self.PathForTransformer.Args(transformerId))
          servicePerEndpoint.pathForTransformer(scroogeRequest).transform(_root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint.transformResult(_))
        }
        def storeFitEvent(fe: modeldb.FitEvent): Future[modeldb.FitEventResponse] = {
          val requestCtx = _root_.com.twitter.finagle.context.Contexts.local.getOrElse(_root_.com.twitter.finagle.thrift.Headers.Request.Key, () => _root_.com.twitter.finagle.thrift.Headers.Request.newValues)
          val scroogeRequest = _root_.com.twitter.scrooge.Request(requestCtx.values, self.StoreFitEvent.Args(fe))
          servicePerEndpoint.storeFitEvent(scroogeRequest).transform(_root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint.transformResult(_))
        }
        def storeMetricEvent(me: modeldb.MetricEvent): Future[modeldb.MetricEventResponse] = {
          val requestCtx = _root_.com.twitter.finagle.context.Contexts.local.getOrElse(_root_.com.twitter.finagle.thrift.Headers.Request.Key, () => _root_.com.twitter.finagle.thrift.Headers.Request.newValues)
          val scroogeRequest = _root_.com.twitter.scrooge.Request(requestCtx.values, self.StoreMetricEvent.Args(me))
          servicePerEndpoint.storeMetricEvent(scroogeRequest).transform(_root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint.transformResult(_))
        }
        def getFilePath(t: modeldb.Transformer, experimentRunId: Int, filename: String): Future[String] = {
          val requestCtx = _root_.com.twitter.finagle.context.Contexts.local.getOrElse(_root_.com.twitter.finagle.thrift.Headers.Request.Key, () => _root_.com.twitter.finagle.thrift.Headers.Request.newValues)
          val scroogeRequest = _root_.com.twitter.scrooge.Request(requestCtx.values, self.GetFilePath.Args(t, experimentRunId, filename))
          servicePerEndpoint.getFilePath(scroogeRequest).transform(_root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint.transformResult(_))
        }
        def storeTransformEvent(te: modeldb.TransformEvent): Future[modeldb.TransformEventResponse] = {
          val requestCtx = _root_.com.twitter.finagle.context.Contexts.local.getOrElse(_root_.com.twitter.finagle.thrift.Headers.Request.Key, () => _root_.com.twitter.finagle.thrift.Headers.Request.newValues)
          val scroogeRequest = _root_.com.twitter.scrooge.Request(requestCtx.values, self.StoreTransformEvent.Args(te))
          servicePerEndpoint.storeTransformEvent(scroogeRequest).transform(_root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint.transformResult(_))
        }
        def storeRandomSplitEvent(rse: modeldb.RandomSplitEvent): Future[modeldb.RandomSplitEventResponse] = {
          val requestCtx = _root_.com.twitter.finagle.context.Contexts.local.getOrElse(_root_.com.twitter.finagle.thrift.Headers.Request.Key, () => _root_.com.twitter.finagle.thrift.Headers.Request.newValues)
          val scroogeRequest = _root_.com.twitter.scrooge.Request(requestCtx.values, self.StoreRandomSplitEvent.Args(rse))
          servicePerEndpoint.storeRandomSplitEvent(scroogeRequest).transform(_root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint.transformResult(_))
        }
        def storePipelineEvent(pipelineEvent: modeldb.PipelineEvent): Future[modeldb.PipelineEventResponse] = {
          val requestCtx = _root_.com.twitter.finagle.context.Contexts.local.getOrElse(_root_.com.twitter.finagle.thrift.Headers.Request.Key, () => _root_.com.twitter.finagle.thrift.Headers.Request.newValues)
          val scroogeRequest = _root_.com.twitter.scrooge.Request(requestCtx.values, self.StorePipelineEvent.Args(pipelineEvent))
          servicePerEndpoint.storePipelineEvent(scroogeRequest).transform(_root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint.transformResult(_))
        }
        def storeCrossValidationEvent(cve: modeldb.CrossValidationEvent): Future[modeldb.CrossValidationEventResponse] = {
          val requestCtx = _root_.com.twitter.finagle.context.Contexts.local.getOrElse(_root_.com.twitter.finagle.thrift.Headers.Request.Key, () => _root_.com.twitter.finagle.thrift.Headers.Request.newValues)
          val scroogeRequest = _root_.com.twitter.scrooge.Request(requestCtx.values, self.StoreCrossValidationEvent.Args(cve))
          servicePerEndpoint.storeCrossValidationEvent(scroogeRequest).transform(_root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint.transformResult(_))
        }
        def storeGridSearchCrossValidationEvent(gscve: modeldb.GridSearchCrossValidationEvent): Future[modeldb.GridSearchCrossValidationEventResponse] = {
          val requestCtx = _root_.com.twitter.finagle.context.Contexts.local.getOrElse(_root_.com.twitter.finagle.thrift.Headers.Request.Key, () => _root_.com.twitter.finagle.thrift.Headers.Request.newValues)
          val scroogeRequest = _root_.com.twitter.scrooge.Request(requestCtx.values, self.StoreGridSearchCrossValidationEvent.Args(gscve))
          servicePerEndpoint.storeGridSearchCrossValidationEvent(scroogeRequest).transform(_root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint.transformResult(_))
        }
        def storeAnnotationEvent(ae: modeldb.AnnotationEvent): Future[modeldb.AnnotationEventResponse] = {
          val requestCtx = _root_.com.twitter.finagle.context.Contexts.local.getOrElse(_root_.com.twitter.finagle.thrift.Headers.Request.Key, () => _root_.com.twitter.finagle.thrift.Headers.Request.newValues)
          val scroogeRequest = _root_.com.twitter.scrooge.Request(requestCtx.values, self.StoreAnnotationEvent.Args(ae))
          servicePerEndpoint.storeAnnotationEvent(scroogeRequest).transform(_root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint.transformResult(_))
        }
        def storeProjectEvent(pr: modeldb.ProjectEvent): Future[modeldb.ProjectEventResponse] = {
          val requestCtx = _root_.com.twitter.finagle.context.Contexts.local.getOrElse(_root_.com.twitter.finagle.thrift.Headers.Request.Key, () => _root_.com.twitter.finagle.thrift.Headers.Request.newValues)
          val scroogeRequest = _root_.com.twitter.scrooge.Request(requestCtx.values, self.StoreProjectEvent.Args(pr))
          servicePerEndpoint.storeProjectEvent(scroogeRequest).transform(_root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint.transformResult(_))
        }
        def storeExperimentEvent(er: modeldb.ExperimentEvent): Future[modeldb.ExperimentEventResponse] = {
          val requestCtx = _root_.com.twitter.finagle.context.Contexts.local.getOrElse(_root_.com.twitter.finagle.thrift.Headers.Request.Key, () => _root_.com.twitter.finagle.thrift.Headers.Request.newValues)
          val scroogeRequest = _root_.com.twitter.scrooge.Request(requestCtx.values, self.StoreExperimentEvent.Args(er))
          servicePerEndpoint.storeExperimentEvent(scroogeRequest).transform(_root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint.transformResult(_))
        }
        def storeExperimentRunEvent(er: modeldb.ExperimentRunEvent): Future[modeldb.ExperimentRunEventResponse] = {
          val requestCtx = _root_.com.twitter.finagle.context.Contexts.local.getOrElse(_root_.com.twitter.finagle.thrift.Headers.Request.Key, () => _root_.com.twitter.finagle.thrift.Headers.Request.newValues)
          val scroogeRequest = _root_.com.twitter.scrooge.Request(requestCtx.values, self.StoreExperimentRunEvent.Args(er))
          servicePerEndpoint.storeExperimentRunEvent(scroogeRequest).transform(_root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint.transformResult(_))
        }
        def storeLinearModel(modelId: Int, model: modeldb.LinearModel): Future[Boolean] = {
          val requestCtx = _root_.com.twitter.finagle.context.Contexts.local.getOrElse(_root_.com.twitter.finagle.thrift.Headers.Request.Key, () => _root_.com.twitter.finagle.thrift.Headers.Request.newValues)
          val scroogeRequest = _root_.com.twitter.scrooge.Request(requestCtx.values, self.StoreLinearModel.Args(modelId, model))
          servicePerEndpoint.storeLinearModel(scroogeRequest).transform(_root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint.transformResult(_))
        }
        def getDataFrameAncestry(dataFrameId: Int): Future[modeldb.DataFrameAncestry] = {
          val requestCtx = _root_.com.twitter.finagle.context.Contexts.local.getOrElse(_root_.com.twitter.finagle.thrift.Headers.Request.Key, () => _root_.com.twitter.finagle.thrift.Headers.Request.newValues)
          val scroogeRequest = _root_.com.twitter.scrooge.Request(requestCtx.values, self.GetDataFrameAncestry.Args(dataFrameId))
          servicePerEndpoint.getDataFrameAncestry(scroogeRequest).transform(_root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint.transformResult(_))
        }
        def getCommonAncestor(dfId1: Int, dfId2: Int): Future[modeldb.CommonAncestor] = {
          val requestCtx = _root_.com.twitter.finagle.context.Contexts.local.getOrElse(_root_.com.twitter.finagle.thrift.Headers.Request.Key, () => _root_.com.twitter.finagle.thrift.Headers.Request.newValues)
          val scroogeRequest = _root_.com.twitter.scrooge.Request(requestCtx.values, self.GetCommonAncestor.Args(dfId1, dfId2))
          servicePerEndpoint.getCommonAncestor(scroogeRequest).transform(_root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint.transformResult(_))
        }
        def getCommonAncestorForModels(modelId1: Int, modelId2: Int): Future[modeldb.CommonAncestor] = {
          val requestCtx = _root_.com.twitter.finagle.context.Contexts.local.getOrElse(_root_.com.twitter.finagle.thrift.Headers.Request.Key, () => _root_.com.twitter.finagle.thrift.Headers.Request.newValues)
          val scroogeRequest = _root_.com.twitter.scrooge.Request(requestCtx.values, self.GetCommonAncestorForModels.Args(modelId1, modelId2))
          servicePerEndpoint.getCommonAncestorForModels(scroogeRequest).transform(_root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint.transformResult(_))
        }
        def getTrainingRowsCount(modelId: Int): Future[Int] = {
          val requestCtx = _root_.com.twitter.finagle.context.Contexts.local.getOrElse(_root_.com.twitter.finagle.thrift.Headers.Request.Key, () => _root_.com.twitter.finagle.thrift.Headers.Request.newValues)
          val scroogeRequest = _root_.com.twitter.scrooge.Request(requestCtx.values, self.GetTrainingRowsCount.Args(modelId))
          servicePerEndpoint.getTrainingRowsCount(scroogeRequest).transform(_root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint.transformResult(_))
        }
        def getTrainingRowsCounts(modelIds: Seq[Int] = Seq[Int]()): Future[Seq[Int]] = {
          val requestCtx = _root_.com.twitter.finagle.context.Contexts.local.getOrElse(_root_.com.twitter.finagle.thrift.Headers.Request.Key, () => _root_.com.twitter.finagle.thrift.Headers.Request.newValues)
          val scroogeRequest = _root_.com.twitter.scrooge.Request(requestCtx.values, self.GetTrainingRowsCounts.Args(modelIds))
          servicePerEndpoint.getTrainingRowsCounts(scroogeRequest).transform(_root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint.transformResult(_))
        }
        def compareHyperparameters(modelId1: Int, modelId2: Int): Future[modeldb.CompareHyperParametersResponse] = {
          val requestCtx = _root_.com.twitter.finagle.context.Contexts.local.getOrElse(_root_.com.twitter.finagle.thrift.Headers.Request.Key, () => _root_.com.twitter.finagle.thrift.Headers.Request.newValues)
          val scroogeRequest = _root_.com.twitter.scrooge.Request(requestCtx.values, self.CompareHyperparameters.Args(modelId1, modelId2))
          servicePerEndpoint.compareHyperparameters(scroogeRequest).transform(_root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint.transformResult(_))
        }
        def compareFeatures(modelId1: Int, modelId2: Int): Future[modeldb.CompareFeaturesResponse] = {
          val requestCtx = _root_.com.twitter.finagle.context.Contexts.local.getOrElse(_root_.com.twitter.finagle.thrift.Headers.Request.Key, () => _root_.com.twitter.finagle.thrift.Headers.Request.newValues)
          val scroogeRequest = _root_.com.twitter.scrooge.Request(requestCtx.values, self.CompareFeatures.Args(modelId1, modelId2))
          servicePerEndpoint.compareFeatures(scroogeRequest).transform(_root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint.transformResult(_))
        }
        def groupByProblemType(modelIds: Seq[Int] = Seq[Int]()): Future[Map[modeldb.ProblemType, Seq[Int]]] = {
          val requestCtx = _root_.com.twitter.finagle.context.Contexts.local.getOrElse(_root_.com.twitter.finagle.thrift.Headers.Request.Key, () => _root_.com.twitter.finagle.thrift.Headers.Request.newValues)
          val scroogeRequest = _root_.com.twitter.scrooge.Request(requestCtx.values, self.GroupByProblemType.Args(modelIds))
          servicePerEndpoint.groupByProblemType(scroogeRequest).transform(_root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint.transformResult(_))
        }
        def similarModels(modelId: Int, compMetrics: Seq[modeldb.ModelCompMetric] = Seq[modeldb.ModelCompMetric](), numModels: Int): Future[Seq[Int]] = {
          val requestCtx = _root_.com.twitter.finagle.context.Contexts.local.getOrElse(_root_.com.twitter.finagle.thrift.Headers.Request.Key, () => _root_.com.twitter.finagle.thrift.Headers.Request.newValues)
          val scroogeRequest = _root_.com.twitter.scrooge.Request(requestCtx.values, self.SimilarModels.Args(modelId, compMetrics, numModels))
          servicePerEndpoint.similarModels(scroogeRequest).transform(_root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint.transformResult(_))
        }
        def linearModelFeatureImportances(modelId: Int): Future[Seq[String]] = {
          val requestCtx = _root_.com.twitter.finagle.context.Contexts.local.getOrElse(_root_.com.twitter.finagle.thrift.Headers.Request.Key, () => _root_.com.twitter.finagle.thrift.Headers.Request.newValues)
          val scroogeRequest = _root_.com.twitter.scrooge.Request(requestCtx.values, self.LinearModelFeatureImportances.Args(modelId))
          servicePerEndpoint.linearModelFeatureImportances(scroogeRequest).transform(_root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint.transformResult(_))
        }
        def compareLinearModelFeatureImportances(model1Id: Int, model2Id: Int): Future[Seq[modeldb.FeatureImportanceComparison]] = {
          val requestCtx = _root_.com.twitter.finagle.context.Contexts.local.getOrElse(_root_.com.twitter.finagle.thrift.Headers.Request.Key, () => _root_.com.twitter.finagle.thrift.Headers.Request.newValues)
          val scroogeRequest = _root_.com.twitter.scrooge.Request(requestCtx.values, self.CompareLinearModelFeatureImportances.Args(model1Id, model2Id))
          servicePerEndpoint.compareLinearModelFeatureImportances(scroogeRequest).transform(_root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint.transformResult(_))
        }
        def iterationsUntilConvergence(modelIds: Seq[Int] = Seq[Int](), tolerance: Double): Future[Seq[Int]] = {
          val requestCtx = _root_.com.twitter.finagle.context.Contexts.local.getOrElse(_root_.com.twitter.finagle.thrift.Headers.Request.Key, () => _root_.com.twitter.finagle.thrift.Headers.Request.newValues)
          val scroogeRequest = _root_.com.twitter.scrooge.Request(requestCtx.values, self.IterationsUntilConvergence.Args(modelIds, tolerance))
          servicePerEndpoint.iterationsUntilConvergence(scroogeRequest).transform(_root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint.transformResult(_))
        }
        def rankModels(modelIds: Seq[Int] = Seq[Int](), metric: modeldb.ModelRankMetric): Future[Seq[Int]] = {
          val requestCtx = _root_.com.twitter.finagle.context.Contexts.local.getOrElse(_root_.com.twitter.finagle.thrift.Headers.Request.Key, () => _root_.com.twitter.finagle.thrift.Headers.Request.newValues)
          val scroogeRequest = _root_.com.twitter.scrooge.Request(requestCtx.values, self.RankModels.Args(modelIds, metric))
          servicePerEndpoint.rankModels(scroogeRequest).transform(_root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint.transformResult(_))
        }
        def confidenceIntervals(modelId: Int, sigLevel: Double): Future[Seq[modeldb.ConfidenceInterval]] = {
          val requestCtx = _root_.com.twitter.finagle.context.Contexts.local.getOrElse(_root_.com.twitter.finagle.thrift.Headers.Request.Key, () => _root_.com.twitter.finagle.thrift.Headers.Request.newValues)
          val scroogeRequest = _root_.com.twitter.scrooge.Request(requestCtx.values, self.ConfidenceIntervals.Args(modelId, sigLevel))
          servicePerEndpoint.confidenceIntervals(scroogeRequest).transform(_root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint.transformResult(_))
        }
        def modelsWithFeatures(featureNames: Seq[String] = Seq[String]()): Future[Seq[Int]] = {
          val requestCtx = _root_.com.twitter.finagle.context.Contexts.local.getOrElse(_root_.com.twitter.finagle.thrift.Headers.Request.Key, () => _root_.com.twitter.finagle.thrift.Headers.Request.newValues)
          val scroogeRequest = _root_.com.twitter.scrooge.Request(requestCtx.values, self.ModelsWithFeatures.Args(featureNames))
          servicePerEndpoint.modelsWithFeatures(scroogeRequest).transform(_root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint.transformResult(_))
        }
        def modelsDerivedFromDataFrame(dfId: Int): Future[Seq[Int]] = {
          val requestCtx = _root_.com.twitter.finagle.context.Contexts.local.getOrElse(_root_.com.twitter.finagle.thrift.Headers.Request.Key, () => _root_.com.twitter.finagle.thrift.Headers.Request.newValues)
          val scroogeRequest = _root_.com.twitter.scrooge.Request(requestCtx.values, self.ModelsDerivedFromDataFrame.Args(dfId))
          servicePerEndpoint.modelsDerivedFromDataFrame(scroogeRequest).transform(_root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint.transformResult(_))
        }
        def getProjectIds(keyValuePairs: Map[String, String] = Map[String, String]()): Future[Seq[Int]] = {
          val requestCtx = _root_.com.twitter.finagle.context.Contexts.local.getOrElse(_root_.com.twitter.finagle.thrift.Headers.Request.Key, () => _root_.com.twitter.finagle.thrift.Headers.Request.newValues)
          val scroogeRequest = _root_.com.twitter.scrooge.Request(requestCtx.values, self.GetProjectIds.Args(keyValuePairs))
          servicePerEndpoint.getProjectIds(scroogeRequest).transform(_root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint.transformResult(_))
        }
        def getModelIds(keyValuePairs: Map[String, String] = Map[String, String]()): Future[Seq[Int]] = {
          val requestCtx = _root_.com.twitter.finagle.context.Contexts.local.getOrElse(_root_.com.twitter.finagle.thrift.Headers.Request.Key, () => _root_.com.twitter.finagle.thrift.Headers.Request.newValues)
          val scroogeRequest = _root_.com.twitter.scrooge.Request(requestCtx.values, self.GetModelIds.Args(keyValuePairs))
          servicePerEndpoint.getModelIds(scroogeRequest).transform(_root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint.transformResult(_))
        }
        def updateProject(projectId: Int, key: String, value: String): Future[Boolean] = {
          val requestCtx = _root_.com.twitter.finagle.context.Contexts.local.getOrElse(_root_.com.twitter.finagle.thrift.Headers.Request.Key, () => _root_.com.twitter.finagle.thrift.Headers.Request.newValues)
          val scroogeRequest = _root_.com.twitter.scrooge.Request(requestCtx.values, self.UpdateProject.Args(projectId, key, value))
          servicePerEndpoint.updateProject(scroogeRequest).transform(_root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint.transformResult(_))
        }
        def createOrUpdateScalarField(modelId: Int, key: String, value: String, valueType: String): Future[Boolean] = {
          val requestCtx = _root_.com.twitter.finagle.context.Contexts.local.getOrElse(_root_.com.twitter.finagle.thrift.Headers.Request.Key, () => _root_.com.twitter.finagle.thrift.Headers.Request.newValues)
          val scroogeRequest = _root_.com.twitter.scrooge.Request(requestCtx.values, self.CreateOrUpdateScalarField.Args(modelId, key, value, valueType))
          servicePerEndpoint.createOrUpdateScalarField(scroogeRequest).transform(_root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint.transformResult(_))
        }
        def createVectorField(modelId: Int, vectorName: String, vectorConfig: Map[String, String] = Map[String, String]()): Future[Boolean] = {
          val requestCtx = _root_.com.twitter.finagle.context.Contexts.local.getOrElse(_root_.com.twitter.finagle.thrift.Headers.Request.Key, () => _root_.com.twitter.finagle.thrift.Headers.Request.newValues)
          val scroogeRequest = _root_.com.twitter.scrooge.Request(requestCtx.values, self.CreateVectorField.Args(modelId, vectorName, vectorConfig))
          servicePerEndpoint.createVectorField(scroogeRequest).transform(_root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint.transformResult(_))
        }
        def updateVectorField(modelId: Int, key: String, valueIndex: Int, value: String, valueType: String): Future[Boolean] = {
          val requestCtx = _root_.com.twitter.finagle.context.Contexts.local.getOrElse(_root_.com.twitter.finagle.thrift.Headers.Request.Key, () => _root_.com.twitter.finagle.thrift.Headers.Request.newValues)
          val scroogeRequest = _root_.com.twitter.scrooge.Request(requestCtx.values, self.UpdateVectorField.Args(modelId, key, valueIndex, value, valueType))
          servicePerEndpoint.updateVectorField(scroogeRequest).transform(_root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint.transformResult(_))
        }
        def appendToVectorField(modelId: Int, vectorName: String, value: String, valueType: String): Future[Boolean] = {
          val requestCtx = _root_.com.twitter.finagle.context.Contexts.local.getOrElse(_root_.com.twitter.finagle.thrift.Headers.Request.Key, () => _root_.com.twitter.finagle.thrift.Headers.Request.newValues)
          val scroogeRequest = _root_.com.twitter.scrooge.Request(requestCtx.values, self.AppendToVectorField.Args(modelId, vectorName, value, valueType))
          servicePerEndpoint.appendToVectorField(scroogeRequest).transform(_root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint.transformResult(_))
        }
        def getModel(modelId: Int): Future[modeldb.ModelResponse] = {
          val requestCtx = _root_.com.twitter.finagle.context.Contexts.local.getOrElse(_root_.com.twitter.finagle.thrift.Headers.Request.Key, () => _root_.com.twitter.finagle.thrift.Headers.Request.newValues)
          val scroogeRequest = _root_.com.twitter.scrooge.Request(requestCtx.values, self.GetModel.Args(modelId))
          servicePerEndpoint.getModel(scroogeRequest).transform(_root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint.transformResult(_))
        }
        def getRunsInExperiment(experimentId: Int): Future[Seq[modeldb.ExperimentRun]] = {
          val requestCtx = _root_.com.twitter.finagle.context.Contexts.local.getOrElse(_root_.com.twitter.finagle.thrift.Headers.Request.Key, () => _root_.com.twitter.finagle.thrift.Headers.Request.newValues)
          val scroogeRequest = _root_.com.twitter.scrooge.Request(requestCtx.values, self.GetRunsInExperiment.Args(experimentId))
          servicePerEndpoint.getRunsInExperiment(scroogeRequest).transform(_root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint.transformResult(_))
        }
        def getRunsAndExperimentsInProject(projId: Int): Future[modeldb.ProjectExperimentsAndRuns] = {
          val requestCtx = _root_.com.twitter.finagle.context.Contexts.local.getOrElse(_root_.com.twitter.finagle.thrift.Headers.Request.Key, () => _root_.com.twitter.finagle.thrift.Headers.Request.newValues)
          val scroogeRequest = _root_.com.twitter.scrooge.Request(requestCtx.values, self.GetRunsAndExperimentsInProject.Args(projId))
          servicePerEndpoint.getRunsAndExperimentsInProject(scroogeRequest).transform(_root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint.transformResult(_))
        }
        def getProjectOverviews(): Future[Seq[modeldb.ProjectOverviewResponse]] = {
          val requestCtx = _root_.com.twitter.finagle.context.Contexts.local.getOrElse(_root_.com.twitter.finagle.thrift.Headers.Request.Key, () => _root_.com.twitter.finagle.thrift.Headers.Request.newValues)
          val scroogeRequest = _root_.com.twitter.scrooge.Request(requestCtx.values, self.GetProjectOverviews.Args())
          servicePerEndpoint.getProjectOverviews(scroogeRequest).transform(_root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint.transformResult(_))
        }
        def getExperimentRunDetails(experimentRunId: Int): Future[modeldb.ExperimentRunDetailsResponse] = {
          val requestCtx = _root_.com.twitter.finagle.context.Contexts.local.getOrElse(_root_.com.twitter.finagle.thrift.Headers.Request.Key, () => _root_.com.twitter.finagle.thrift.Headers.Request.newValues)
          val scroogeRequest = _root_.com.twitter.scrooge.Request(requestCtx.values, self.GetExperimentRunDetails.Args(experimentRunId))
          servicePerEndpoint.getExperimentRunDetails(scroogeRequest).transform(_root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint.transformResult(_))
        }
        def originalFeatures(modelId: Int): Future[Seq[String]] = {
          val requestCtx = _root_.com.twitter.finagle.context.Contexts.local.getOrElse(_root_.com.twitter.finagle.thrift.Headers.Request.Key, () => _root_.com.twitter.finagle.thrift.Headers.Request.newValues)
          val scroogeRequest = _root_.com.twitter.scrooge.Request(requestCtx.values, self.OriginalFeatures.Args(modelId))
          servicePerEndpoint.originalFeatures(scroogeRequest).transform(_root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint.transformResult(_))
        }
        def storeTreeModel(modelId: Int, model: modeldb.TreeModel): Future[Boolean] = {
          val requestCtx = _root_.com.twitter.finagle.context.Contexts.local.getOrElse(_root_.com.twitter.finagle.thrift.Headers.Request.Key, () => _root_.com.twitter.finagle.thrift.Headers.Request.newValues)
          val scroogeRequest = _root_.com.twitter.scrooge.Request(requestCtx.values, self.StoreTreeModel.Args(modelId, model))
          servicePerEndpoint.storeTreeModel(scroogeRequest).transform(_root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint.transformResult(_))
        }
        def storePipelineTransformEvent(te: Seq[modeldb.TransformEvent] = Seq[modeldb.TransformEvent]()): Future[Seq[modeldb.TransformEventResponse]] = {
          val requestCtx = _root_.com.twitter.finagle.context.Contexts.local.getOrElse(_root_.com.twitter.finagle.thrift.Headers.Request.Key, () => _root_.com.twitter.finagle.thrift.Headers.Request.newValues)
          val scroogeRequest = _root_.com.twitter.scrooge.Request(requestCtx.values, self.StorePipelineTransformEvent.Args(te))
          servicePerEndpoint.storePipelineTransformEvent(scroogeRequest).transform(_root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint.transformResult(_))
        }
        def computeModelAncestry(modelId: Int): Future[modeldb.ModelAncestryResponse] = {
          val requestCtx = _root_.com.twitter.finagle.context.Contexts.local.getOrElse(_root_.com.twitter.finagle.thrift.Headers.Request.Key, () => _root_.com.twitter.finagle.thrift.Headers.Request.newValues)
          val scroogeRequest = _root_.com.twitter.scrooge.Request(requestCtx.values, self.ComputeModelAncestry.Args(modelId))
          servicePerEndpoint.computeModelAncestry(scroogeRequest).transform(_root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint.transformResult(_))
        }
        def extractPipeline(modelId: Int): Future[modeldb.ExtractedPipelineResponse] = {
          val requestCtx = _root_.com.twitter.finagle.context.Contexts.local.getOrElse(_root_.com.twitter.finagle.thrift.Headers.Request.Key, () => _root_.com.twitter.finagle.thrift.Headers.Request.newValues)
          val scroogeRequest = _root_.com.twitter.scrooge.Request(requestCtx.values, self.ExtractPipeline.Args(modelId))
          servicePerEndpoint.extractPipeline(scroogeRequest).transform(_root_.com.twitter.finagle.thrift.service.ThriftReqRepServicePerEndpoint.transformResult(_))
        }

        override def asClosable: _root_.com.twitter.util.Closable =
          servicePerEndpoint.asClosable
    }
  }

  @deprecated("Use MethodPerEndpoint", "2017-11-07")
  class MethodIface(serviceIface: BaseServiceIface)
    extends FutureIface {
    def testConnection(): Future[Int] =
      serviceIface.testConnection(self.TestConnection.Args())
    def storeDataFrame(df: modeldb.DataFrame, experimentRunId: Int): Future[Int] =
      serviceIface.storeDataFrame(self.StoreDataFrame.Args(df, experimentRunId))
    def pathForTransformer(transformerId: Int): Future[String] =
      serviceIface.pathForTransformer(self.PathForTransformer.Args(transformerId))
    def storeFitEvent(fe: modeldb.FitEvent): Future[modeldb.FitEventResponse] =
      serviceIface.storeFitEvent(self.StoreFitEvent.Args(fe))
    def storeMetricEvent(me: modeldb.MetricEvent): Future[modeldb.MetricEventResponse] =
      serviceIface.storeMetricEvent(self.StoreMetricEvent.Args(me))
    def getFilePath(t: modeldb.Transformer, experimentRunId: Int, filename: String): Future[String] =
      serviceIface.getFilePath(self.GetFilePath.Args(t, experimentRunId, filename))
    def storeTransformEvent(te: modeldb.TransformEvent): Future[modeldb.TransformEventResponse] =
      serviceIface.storeTransformEvent(self.StoreTransformEvent.Args(te))
    def storeRandomSplitEvent(rse: modeldb.RandomSplitEvent): Future[modeldb.RandomSplitEventResponse] =
      serviceIface.storeRandomSplitEvent(self.StoreRandomSplitEvent.Args(rse))
    def storePipelineEvent(pipelineEvent: modeldb.PipelineEvent): Future[modeldb.PipelineEventResponse] =
      serviceIface.storePipelineEvent(self.StorePipelineEvent.Args(pipelineEvent))
    def storeCrossValidationEvent(cve: modeldb.CrossValidationEvent): Future[modeldb.CrossValidationEventResponse] =
      serviceIface.storeCrossValidationEvent(self.StoreCrossValidationEvent.Args(cve))
    def storeGridSearchCrossValidationEvent(gscve: modeldb.GridSearchCrossValidationEvent): Future[modeldb.GridSearchCrossValidationEventResponse] =
      serviceIface.storeGridSearchCrossValidationEvent(self.StoreGridSearchCrossValidationEvent.Args(gscve))
    def storeAnnotationEvent(ae: modeldb.AnnotationEvent): Future[modeldb.AnnotationEventResponse] =
      serviceIface.storeAnnotationEvent(self.StoreAnnotationEvent.Args(ae))
    def storeProjectEvent(pr: modeldb.ProjectEvent): Future[modeldb.ProjectEventResponse] =
      serviceIface.storeProjectEvent(self.StoreProjectEvent.Args(pr))
    def storeExperimentEvent(er: modeldb.ExperimentEvent): Future[modeldb.ExperimentEventResponse] =
      serviceIface.storeExperimentEvent(self.StoreExperimentEvent.Args(er))
    def storeExperimentRunEvent(er: modeldb.ExperimentRunEvent): Future[modeldb.ExperimentRunEventResponse] =
      serviceIface.storeExperimentRunEvent(self.StoreExperimentRunEvent.Args(er))
    def storeLinearModel(modelId: Int, model: modeldb.LinearModel): Future[Boolean] =
      serviceIface.storeLinearModel(self.StoreLinearModel.Args(modelId, model))
    def getDataFrameAncestry(dataFrameId: Int): Future[modeldb.DataFrameAncestry] =
      serviceIface.getDataFrameAncestry(self.GetDataFrameAncestry.Args(dataFrameId))
    def getCommonAncestor(dfId1: Int, dfId2: Int): Future[modeldb.CommonAncestor] =
      serviceIface.getCommonAncestor(self.GetCommonAncestor.Args(dfId1, dfId2))
    def getCommonAncestorForModels(modelId1: Int, modelId2: Int): Future[modeldb.CommonAncestor] =
      serviceIface.getCommonAncestorForModels(self.GetCommonAncestorForModels.Args(modelId1, modelId2))
    def getTrainingRowsCount(modelId: Int): Future[Int] =
      serviceIface.getTrainingRowsCount(self.GetTrainingRowsCount.Args(modelId))
    def getTrainingRowsCounts(modelIds: Seq[Int] = Seq[Int]()): Future[Seq[Int]] =
      serviceIface.getTrainingRowsCounts(self.GetTrainingRowsCounts.Args(modelIds))
    def compareHyperparameters(modelId1: Int, modelId2: Int): Future[modeldb.CompareHyperParametersResponse] =
      serviceIface.compareHyperparameters(self.CompareHyperparameters.Args(modelId1, modelId2))
    def compareFeatures(modelId1: Int, modelId2: Int): Future[modeldb.CompareFeaturesResponse] =
      serviceIface.compareFeatures(self.CompareFeatures.Args(modelId1, modelId2))
    def groupByProblemType(modelIds: Seq[Int] = Seq[Int]()): Future[Map[modeldb.ProblemType, Seq[Int]]] =
      serviceIface.groupByProblemType(self.GroupByProblemType.Args(modelIds))
    def similarModels(modelId: Int, compMetrics: Seq[modeldb.ModelCompMetric] = Seq[modeldb.ModelCompMetric](), numModels: Int): Future[Seq[Int]] =
      serviceIface.similarModels(self.SimilarModels.Args(modelId, compMetrics, numModels))
    def linearModelFeatureImportances(modelId: Int): Future[Seq[String]] =
      serviceIface.linearModelFeatureImportances(self.LinearModelFeatureImportances.Args(modelId))
    def compareLinearModelFeatureImportances(model1Id: Int, model2Id: Int): Future[Seq[modeldb.FeatureImportanceComparison]] =
      serviceIface.compareLinearModelFeatureImportances(self.CompareLinearModelFeatureImportances.Args(model1Id, model2Id))
    def iterationsUntilConvergence(modelIds: Seq[Int] = Seq[Int](), tolerance: Double): Future[Seq[Int]] =
      serviceIface.iterationsUntilConvergence(self.IterationsUntilConvergence.Args(modelIds, tolerance))
    def rankModels(modelIds: Seq[Int] = Seq[Int](), metric: modeldb.ModelRankMetric): Future[Seq[Int]] =
      serviceIface.rankModels(self.RankModels.Args(modelIds, metric))
    def confidenceIntervals(modelId: Int, sigLevel: Double): Future[Seq[modeldb.ConfidenceInterval]] =
      serviceIface.confidenceIntervals(self.ConfidenceIntervals.Args(modelId, sigLevel))
    def modelsWithFeatures(featureNames: Seq[String] = Seq[String]()): Future[Seq[Int]] =
      serviceIface.modelsWithFeatures(self.ModelsWithFeatures.Args(featureNames))
    def modelsDerivedFromDataFrame(dfId: Int): Future[Seq[Int]] =
      serviceIface.modelsDerivedFromDataFrame(self.ModelsDerivedFromDataFrame.Args(dfId))
    def getProjectIds(keyValuePairs: Map[String, String] = Map[String, String]()): Future[Seq[Int]] =
      serviceIface.getProjectIds(self.GetProjectIds.Args(keyValuePairs))
    def getModelIds(keyValuePairs: Map[String, String] = Map[String, String]()): Future[Seq[Int]] =
      serviceIface.getModelIds(self.GetModelIds.Args(keyValuePairs))
    def updateProject(projectId: Int, key: String, value: String): Future[Boolean] =
      serviceIface.updateProject(self.UpdateProject.Args(projectId, key, value))
    def createOrUpdateScalarField(modelId: Int, key: String, value: String, valueType: String): Future[Boolean] =
      serviceIface.createOrUpdateScalarField(self.CreateOrUpdateScalarField.Args(modelId, key, value, valueType))
    def createVectorField(modelId: Int, vectorName: String, vectorConfig: Map[String, String] = Map[String, String]()): Future[Boolean] =
      serviceIface.createVectorField(self.CreateVectorField.Args(modelId, vectorName, vectorConfig))
    def updateVectorField(modelId: Int, key: String, valueIndex: Int, value: String, valueType: String): Future[Boolean] =
      serviceIface.updateVectorField(self.UpdateVectorField.Args(modelId, key, valueIndex, value, valueType))
    def appendToVectorField(modelId: Int, vectorName: String, value: String, valueType: String): Future[Boolean] =
      serviceIface.appendToVectorField(self.AppendToVectorField.Args(modelId, vectorName, value, valueType))
    def getModel(modelId: Int): Future[modeldb.ModelResponse] =
      serviceIface.getModel(self.GetModel.Args(modelId))
    def getRunsInExperiment(experimentId: Int): Future[Seq[modeldb.ExperimentRun]] =
      serviceIface.getRunsInExperiment(self.GetRunsInExperiment.Args(experimentId))
    def getRunsAndExperimentsInProject(projId: Int): Future[modeldb.ProjectExperimentsAndRuns] =
      serviceIface.getRunsAndExperimentsInProject(self.GetRunsAndExperimentsInProject.Args(projId))
    def getProjectOverviews(): Future[Seq[modeldb.ProjectOverviewResponse]] =
      serviceIface.getProjectOverviews(self.GetProjectOverviews.Args())
    def getExperimentRunDetails(experimentRunId: Int): Future[modeldb.ExperimentRunDetailsResponse] =
      serviceIface.getExperimentRunDetails(self.GetExperimentRunDetails.Args(experimentRunId))
    def originalFeatures(modelId: Int): Future[Seq[String]] =
      serviceIface.originalFeatures(self.OriginalFeatures.Args(modelId))
    def storeTreeModel(modelId: Int, model: modeldb.TreeModel): Future[Boolean] =
      serviceIface.storeTreeModel(self.StoreTreeModel.Args(modelId, model))
    def storePipelineTransformEvent(te: Seq[modeldb.TransformEvent] = Seq[modeldb.TransformEvent]()): Future[Seq[modeldb.TransformEventResponse]] =
      serviceIface.storePipelineTransformEvent(self.StorePipelineTransformEvent.Args(te))
    def computeModelAncestry(modelId: Int): Future[modeldb.ModelAncestryResponse] =
      serviceIface.computeModelAncestry(self.ComputeModelAncestry.Args(modelId))
    def extractPipeline(modelId: Int): Future[modeldb.ExtractedPipelineResponse] =
      serviceIface.extractPipeline(self.ExtractPipeline.Args(modelId))
  }

  implicit object MethodPerEndpointBuilder
    extends _root_.com.twitter.finagle.thrift.service.MethodPerEndpointBuilder[ServicePerEndpoint, MethodPerEndpoint] {
    def methodPerEndpoint(servicePerEndpoint: ServicePerEndpoint): MethodPerEndpoint =
      MethodPerEndpoint(servicePerEndpoint)
  }

  @deprecated("Use MethodPerEndpointBuilder", "2018-01-12")
  implicit object ThriftServiceBuilder
    extends _root_.com.twitter.finagle.thrift.service.ThriftServiceBuilder[ServicePerEndpoint, ModelDBService[Future]] {
    def build(servicePerEndpoint: ServicePerEndpoint): MethodPerEndpoint =
      MethodPerEndpoint(servicePerEndpoint)
  }

  implicit object ReqRepMethodPerEndpointBuilder
    extends _root_.com.twitter.finagle.thrift.service.ReqRepMethodPerEndpointBuilder[ReqRepServicePerEndpoint, MethodPerEndpoint] {
    def methodPerEndpoint(servicePerEndpoint: ReqRepServicePerEndpoint): MethodPerEndpoint =
      ReqRepMethodPerEndpoint(servicePerEndpoint)
  }

  @deprecated("Use ReqRepMethodPerEndpointBuilder", "2018-01-12")
  implicit object ReqRepThriftServiceBuilder
    extends _root_.com.twitter.finagle.thrift.service.ReqRepThriftServiceBuilder[ReqRepServicePerEndpoint, ModelDBService[Future]] {
    def build(servicePerEndpoint: ReqRepServicePerEndpoint): MethodPerEndpoint =
      ReqRepMethodPerEndpoint(servicePerEndpoint)
  }

  @deprecated("Use MethodPerEndpointBuilder", "2017-11-07")
  implicit object MethodIfaceBuilder
    extends com.twitter.finagle.thrift.MethodIfaceBuilder[ServiceIface, ModelDBService[Future]] {
    def newMethodIface(serviceIface: ServiceIface): MethodIface =
      new MethodIface(serviceIface)
  }

  @deprecated("Use MethodPerEndpoint", "2017-11-07")
  trait FutureIface
    extends ModelDBService[Future] {
    
    def testConnection(): Future[Int]
    
    def storeDataFrame(df: modeldb.DataFrame, experimentRunId: Int): Future[Int]
    
    def pathForTransformer(transformerId: Int): Future[String]
    
    def storeFitEvent(fe: modeldb.FitEvent): Future[modeldb.FitEventResponse]
    
    def storeMetricEvent(me: modeldb.MetricEvent): Future[modeldb.MetricEventResponse]
    
    def getFilePath(t: modeldb.Transformer, experimentRunId: Int, filename: String): Future[String]
    
    def storeTransformEvent(te: modeldb.TransformEvent): Future[modeldb.TransformEventResponse]
    
    def storeRandomSplitEvent(rse: modeldb.RandomSplitEvent): Future[modeldb.RandomSplitEventResponse]
    
    def storePipelineEvent(pipelineEvent: modeldb.PipelineEvent): Future[modeldb.PipelineEventResponse]
    
    def storeCrossValidationEvent(cve: modeldb.CrossValidationEvent): Future[modeldb.CrossValidationEventResponse]
    
    def storeGridSearchCrossValidationEvent(gscve: modeldb.GridSearchCrossValidationEvent): Future[modeldb.GridSearchCrossValidationEventResponse]
    
    def storeAnnotationEvent(ae: modeldb.AnnotationEvent): Future[modeldb.AnnotationEventResponse]
    
    def storeProjectEvent(pr: modeldb.ProjectEvent): Future[modeldb.ProjectEventResponse]
    
    def storeExperimentEvent(er: modeldb.ExperimentEvent): Future[modeldb.ExperimentEventResponse]
    
    def storeExperimentRunEvent(er: modeldb.ExperimentRunEvent): Future[modeldb.ExperimentRunEventResponse]
    
    def storeLinearModel(modelId: Int, model: modeldb.LinearModel): Future[Boolean]
    
    def getDataFrameAncestry(dataFrameId: Int): Future[modeldb.DataFrameAncestry]
    
    def getCommonAncestor(dfId1: Int, dfId2: Int): Future[modeldb.CommonAncestor]
    
    def getCommonAncestorForModels(modelId1: Int, modelId2: Int): Future[modeldb.CommonAncestor]
    
    def getTrainingRowsCount(modelId: Int): Future[Int]
    
    def getTrainingRowsCounts(modelIds: Seq[Int] = Seq[Int]()): Future[Seq[Int]]
    
    def compareHyperparameters(modelId1: Int, modelId2: Int): Future[modeldb.CompareHyperParametersResponse]
    
    def compareFeatures(modelId1: Int, modelId2: Int): Future[modeldb.CompareFeaturesResponse]
    
    def groupByProblemType(modelIds: Seq[Int] = Seq[Int]()): Future[Map[modeldb.ProblemType, Seq[Int]]]
    
    def similarModels(modelId: Int, compMetrics: Seq[modeldb.ModelCompMetric] = Seq[modeldb.ModelCompMetric](), numModels: Int): Future[Seq[Int]]
    
    def linearModelFeatureImportances(modelId: Int): Future[Seq[String]]
    
    def compareLinearModelFeatureImportances(model1Id: Int, model2Id: Int): Future[Seq[modeldb.FeatureImportanceComparison]]
    
    def iterationsUntilConvergence(modelIds: Seq[Int] = Seq[Int](), tolerance: Double): Future[Seq[Int]]
    
    def rankModels(modelIds: Seq[Int] = Seq[Int](), metric: modeldb.ModelRankMetric): Future[Seq[Int]]
    
    def confidenceIntervals(modelId: Int, sigLevel: Double): Future[Seq[modeldb.ConfidenceInterval]]
    
    def modelsWithFeatures(featureNames: Seq[String] = Seq[String]()): Future[Seq[Int]]
    
    def modelsDerivedFromDataFrame(dfId: Int): Future[Seq[Int]]
    
    def getProjectIds(keyValuePairs: Map[String, String] = Map[String, String]()): Future[Seq[Int]]
    
    def getModelIds(keyValuePairs: Map[String, String] = Map[String, String]()): Future[Seq[Int]]
    
    def updateProject(projectId: Int, key: String, value: String): Future[Boolean]
    
    def createOrUpdateScalarField(modelId: Int, key: String, value: String, valueType: String): Future[Boolean]
    
    def createVectorField(modelId: Int, vectorName: String, vectorConfig: Map[String, String] = Map[String, String]()): Future[Boolean]
    
    def updateVectorField(modelId: Int, key: String, valueIndex: Int, value: String, valueType: String): Future[Boolean]
    
    def appendToVectorField(modelId: Int, vectorName: String, value: String, valueType: String): Future[Boolean]
    
    def getModel(modelId: Int): Future[modeldb.ModelResponse]
    
    def getRunsInExperiment(experimentId: Int): Future[Seq[modeldb.ExperimentRun]]
    
    def getRunsAndExperimentsInProject(projId: Int): Future[modeldb.ProjectExperimentsAndRuns]
    
    def getProjectOverviews(): Future[Seq[modeldb.ProjectOverviewResponse]]
    
    def getExperimentRunDetails(experimentRunId: Int): Future[modeldb.ExperimentRunDetailsResponse]
    
    def originalFeatures(modelId: Int): Future[Seq[String]]
    
    def storeTreeModel(modelId: Int, model: modeldb.TreeModel): Future[Boolean]
    
    def storePipelineTransformEvent(te: Seq[modeldb.TransformEvent] = Seq[modeldb.TransformEvent]()): Future[Seq[modeldb.TransformEventResponse]]
    
    def computeModelAncestry(modelId: Int): Future[modeldb.ModelAncestryResponse]
    
    def extractPipeline(modelId: Int): Future[modeldb.ExtractedPipelineResponse]
  }

  class FinagledClient(
      service: com.twitter.finagle.Service[ThriftClientRequest, Array[Byte]],
      clientParam: RichClientParam)
    extends ModelDBService$FinagleClient(service, clientParam)
    with FutureIface
    with MethodPerEndpoint {

    @deprecated("Use com.twitter.finagle.thrift.RichClientParam", "2017-08-16")
    def this(
      service: com.twitter.finagle.Service[ThriftClientRequest, Array[Byte]],
      protocolFactory: org.apache.thrift.protocol.TProtocolFactory = Protocols.binaryFactory(),
      serviceName: String = "ModelDBService",
      stats: com.twitter.finagle.stats.StatsReceiver = com.twitter.finagle.stats.NullStatsReceiver,
      responseClassifier: ctfs.ResponseClassifier = ctfs.ResponseClassifier.Default
    ) = this(
      service,
      RichClientParam(
        protocolFactory,
        serviceName,
        clientStats = stats,
        responseClassifier = responseClassifier
      )
    )

    @deprecated("Use com.twitter.finagle.thrift.RichClientParam", "2017-08-16")
    def this(
      service: com.twitter.finagle.Service[ThriftClientRequest, Array[Byte]],
      protocolFactory: org.apache.thrift.protocol.TProtocolFactory,
      serviceName: String,
      stats: com.twitter.finagle.stats.StatsReceiver
    ) = this(
      service,
      RichClientParam(
        protocolFactory,
        serviceName,
        clientStats = stats
      )
    )
  }

  class FinagledService(
      iface: ModelDBService[Future],
      serverParam: RichServerParam)
    extends ModelDBService$FinagleService(iface, serverParam) {

    @deprecated("Use com.twitter.finagle.thrift.RichServerParam", "2017-08-16")
    def this(
      iface: ModelDBService[Future],
      protocolFactory: org.apache.thrift.protocol.TProtocolFactory,
      serviceName: String = "ModelDBService"
    ) = this(iface, RichServerParam(protocolFactory, serviceName))
  }

  class Filter(serverParam: RichServerParam) {
    private[this] def protocolFactory: TProtocolFactory = serverParam.restrictedProtocolFactory

    private[this] def serviceName: String = serverParam.serviceName
    private[this] def responseClassifier: ctfs.ResponseClassifier = serverParam.responseClassifier
    private[this] def stats: StatsReceiver = serverParam.serverStats
    private[this] def perEndpointStats: Boolean = serverParam.perEndpointStats && !stats.isNull
    private[this] def maxReusableBufferSize: Int = serverParam.maxThriftBufferSize

    private[this] val tlReusableBuffer = TReusableBuffer(maxThriftBufferSize = maxReusableBufferSize)

    private[modeldb] def exception(name: String, seqid: Int, code: Int, message: String): Buf = {
      val x = new TApplicationException(code, message)
      val memoryBuffer = tlReusableBuffer.get()
      try {
        val oprot = protocolFactory.getProtocol(memoryBuffer)

        oprot.writeMessageBegin(new TMessage(name, TMessageType.EXCEPTION, seqid))
        x.write(oprot)
        oprot.writeMessageEnd()
        oprot.getTransport().flush()

        // make a copy of the array of bytes to construct a new buffer because memoryBuffer is reusable
        Buf.ByteArray.Shared(memoryBuffer.getArray(), 0, memoryBuffer.length())
      } finally {
        tlReusableBuffer.reset()
      }
    }

    private def reply(name: String, seqid: Int, result: ThriftStruct): Buf = {
      val memoryBuffer = tlReusableBuffer.get()
      try {
        val oprot = protocolFactory.getProtocol(memoryBuffer)

        oprot.writeMessageBegin(new TMessage(name, TMessageType.REPLY, seqid))
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.getTransport().flush()

        // make a copy of the array of bytes to construct a new buffer because memoryBuffer is reusable
        Buf.ByteArray.Shared(memoryBuffer.getArray(), 0, memoryBuffer.length())
      } finally {
        tlReusableBuffer.reset()
      }
    }

    private object ThriftMethodStats {
      def apply(stats: StatsReceiver): ThriftMethodStats =
        ThriftMethodStats(
          stats.counter("requests"),
          stats.counter("success"),
          stats.counter("failures"),
          stats.scope("failures")
        )
    }

    private case class ThriftMethodStats(
      requestsCounter: Counter,
      successCounter: Counter,
      failuresCounter: Counter,
      failuresScope: StatsReceiver
    )

    private def missingResult(name: String): TApplicationException = {
      new TApplicationException(
        TApplicationException.MISSING_RESULT,
        name + " failed: unknown result"
      )
    }

    private def setServiceName(ex: Throwable): Throwable =
      if (this.serviceName == "") ex
      else {
        ex match {
          case se: SourcedException =>
            se.serviceName = this.serviceName
            se
          case _ => ex
        }
      }

    private def recordRequest(method: ThriftMethod): Unit = {
      if (perEndpointStats) {
        val methodStats = ThriftMethodStats((if (serviceName != "") stats.scope(serviceName) else stats).scope(method.name))
        methodStats.requestsCounter.incr()
      }
    }

    private def recordResponse(reqRep: ctfs.ReqRep, method: ThriftMethod): Unit = {
      ServerToReqRep.setCtx(reqRep)
      if (perEndpointStats) {
        val methodStats = ThriftMethodStats((if (serviceName != "") stats.scope(serviceName) else stats).scope(method.name))
        val responseClass = responseClassifier.applyOrElse(reqRep, ctfs.ResponseClassifier.Default)
        responseClass match {
          case ctfs.ResponseClass.Successful(_) =>
            methodStats.successCounter.incr()
          case ctfs.ResponseClass.Failed(_) =>
            methodStats.failuresCounter.incr()
            reqRep.response match {
              case Throw(ex) =>
                methodStats.failuresScope.counter(Throwables.mkString(ex): _*).incr()
              case _ =>
            }
        }
      }
    }

    final protected def perMethodStatsFilter(
      method: ThriftMethod
    ): finagle$Filter[(TProtocol, Int), Array[Byte], (TProtocol, Int), RichResponse[method.Args, method.Result]] = {
      new finagle$Filter[(TProtocol, Int), Array[Byte], (TProtocol, Int), RichResponse[method.Args, method.Result]] {
        def apply(
          req: (TProtocol, Int),
          service: finagle$Service[(TProtocol, Int), RichResponse[method.Args, method.Result]]
        ): Future[Array[Byte]] = {
          recordRequest(method)
          service(req).transform {
            case Return(value) =>
              value match {
                case SuccessfulResponse(args, _, result) =>
                  recordResponse(ctfs.ReqRep(args, _root_.com.twitter.util.Return(result.successField.get)), method)
                case ProtocolExceptionResponse(args, _, exp) =>
                  recordResponse(ctfs.ReqRep(args, _root_.com.twitter.util.Throw(exp)), method)
                case ThriftExceptionResponse(args, _, ex) =>
                  val rep = ex match {
                    case exp: ThriftException => setServiceName(exp)
                    case _ => missingResult(serviceName)
                  }
                  recordResponse(ctfs.ReqRep(args, _root_.com.twitter.util.Throw(rep)), method)
              }
              Future.value(Buf.ByteArray.Owned.extract(value.response))
            case t @ Throw(_) =>
              recordResponse(ctfs.ReqRep(req, t), method)
              Future.const(t.cast[Array[Byte]])
          }
        }
      }
    }
    // ---- end boilerplate.

    val testConnection: finagle$Filter[(TProtocol, Int), Array[Byte], TestConnection.Args, TestConnection.SuccessType] = {
      val statsFilter: finagle$Filter[(TProtocol, Int), Array[Byte], (TProtocol, Int), RichResponse[TestConnection.Args, TestConnection.Result]] = perMethodStatsFilter(TestConnection)
    
      val protocolExnFilter = new SimpleFilter[(TProtocol, Int), RichResponse[TestConnection.Args, TestConnection.Result]] {
        def apply(
          request: (TProtocol, Int),
          service: finagle$Service[(TProtocol, Int), RichResponse[TestConnection.Args, TestConnection.Result]]
        ): Future[RichResponse[TestConnection.Args, TestConnection.Result]] = {
          val iprot = request._1
          val seqid = request._2
          val res = service(request)
          res.transform {
            case _root_.com.twitter.util.Throw(e: TProtocolException) =>
              iprot.readMessageEnd()
              Future.value(
                ProtocolExceptionResponse(
                  null,
                  exception("testConnection", seqid, TApplicationException.PROTOCOL_ERROR, e.getMessage),
                  new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage)))
            case _ =>
              res
          }
        }
      }
    
      val serdeFilter = new finagle$Filter[(TProtocol, Int), RichResponse[TestConnection.Args, TestConnection.Result], TestConnection.Args, TestConnection.SuccessType] {
        def apply(
          request: (TProtocol, Int),
          service: finagle$Service[TestConnection.Args, TestConnection.SuccessType]
        ): Future[RichResponse[TestConnection.Args, TestConnection.Result]] = {
          val iprot = request._1
          val seqid = request._2
          val args = TestConnection.Args.decode(iprot)
          iprot.readMessageEnd()
          val res = service(args)
          res.transform {
            case _root_.com.twitter.util.Return(value) =>
              val methodResult = TestConnection.Result(success = Some(value))
              Future.value(
                SuccessfulResponse(
                  args,
                  reply("testConnection", seqid, methodResult),
                  methodResult))
            case t @ _root_.com.twitter.util.Throw(_) =>
              Future.const(t.cast[RichResponse[TestConnection.Args, TestConnection.Result]])
          }
        }
      }
    
      statsFilter.andThen(protocolExnFilter).andThen(serdeFilter)
    }
    val storeDataFrame: finagle$Filter[(TProtocol, Int), Array[Byte], StoreDataFrame.Args, StoreDataFrame.SuccessType] = {
      val statsFilter: finagle$Filter[(TProtocol, Int), Array[Byte], (TProtocol, Int), RichResponse[StoreDataFrame.Args, StoreDataFrame.Result]] = perMethodStatsFilter(StoreDataFrame)
    
      val protocolExnFilter = new SimpleFilter[(TProtocol, Int), RichResponse[StoreDataFrame.Args, StoreDataFrame.Result]] {
        def apply(
          request: (TProtocol, Int),
          service: finagle$Service[(TProtocol, Int), RichResponse[StoreDataFrame.Args, StoreDataFrame.Result]]
        ): Future[RichResponse[StoreDataFrame.Args, StoreDataFrame.Result]] = {
          val iprot = request._1
          val seqid = request._2
          val res = service(request)
          res.transform {
            case _root_.com.twitter.util.Throw(e: TProtocolException) =>
              iprot.readMessageEnd()
              Future.value(
                ProtocolExceptionResponse(
                  null,
                  exception("storeDataFrame", seqid, TApplicationException.PROTOCOL_ERROR, e.getMessage),
                  new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage)))
            case _ =>
              res
          }
        }
      }
    
      val serdeFilter = new finagle$Filter[(TProtocol, Int), RichResponse[StoreDataFrame.Args, StoreDataFrame.Result], StoreDataFrame.Args, StoreDataFrame.SuccessType] {
        def apply(
          request: (TProtocol, Int),
          service: finagle$Service[StoreDataFrame.Args, StoreDataFrame.SuccessType]
        ): Future[RichResponse[StoreDataFrame.Args, StoreDataFrame.Result]] = {
          val iprot = request._1
          val seqid = request._2
          val args = StoreDataFrame.Args.decode(iprot)
          iprot.readMessageEnd()
          val res = service(args)
          res.transform {
            case _root_.com.twitter.util.Return(value) =>
              val methodResult = StoreDataFrame.Result(success = Some(value))
              Future.value(
                SuccessfulResponse(
                  args,
                  reply("storeDataFrame", seqid, methodResult),
                  methodResult))
            case _root_.com.twitter.util.Throw(e: modeldb.InvalidExperimentRunException) => {
              Future.value(
                ThriftExceptionResponse(
                  args,
                  reply("storeDataFrame", seqid, StoreDataFrame.Result(ierEx = Some(e))),
                  e))
            }
            case _root_.com.twitter.util.Throw(e: modeldb.ServerLogicException) => {
              Future.value(
                ThriftExceptionResponse(
                  args,
                  reply("storeDataFrame", seqid, StoreDataFrame.Result(svEx = Some(e))),
                  e))
            }
            case t @ _root_.com.twitter.util.Throw(_) =>
              Future.const(t.cast[RichResponse[StoreDataFrame.Args, StoreDataFrame.Result]])
          }
        }
      }
    
      statsFilter.andThen(protocolExnFilter).andThen(serdeFilter)
    }
    val pathForTransformer: finagle$Filter[(TProtocol, Int), Array[Byte], PathForTransformer.Args, PathForTransformer.SuccessType] = {
      val statsFilter: finagle$Filter[(TProtocol, Int), Array[Byte], (TProtocol, Int), RichResponse[PathForTransformer.Args, PathForTransformer.Result]] = perMethodStatsFilter(PathForTransformer)
    
      val protocolExnFilter = new SimpleFilter[(TProtocol, Int), RichResponse[PathForTransformer.Args, PathForTransformer.Result]] {
        def apply(
          request: (TProtocol, Int),
          service: finagle$Service[(TProtocol, Int), RichResponse[PathForTransformer.Args, PathForTransformer.Result]]
        ): Future[RichResponse[PathForTransformer.Args, PathForTransformer.Result]] = {
          val iprot = request._1
          val seqid = request._2
          val res = service(request)
          res.transform {
            case _root_.com.twitter.util.Throw(e: TProtocolException) =>
              iprot.readMessageEnd()
              Future.value(
                ProtocolExceptionResponse(
                  null,
                  exception("pathForTransformer", seqid, TApplicationException.PROTOCOL_ERROR, e.getMessage),
                  new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage)))
            case _ =>
              res
          }
        }
      }
    
      val serdeFilter = new finagle$Filter[(TProtocol, Int), RichResponse[PathForTransformer.Args, PathForTransformer.Result], PathForTransformer.Args, PathForTransformer.SuccessType] {
        def apply(
          request: (TProtocol, Int),
          service: finagle$Service[PathForTransformer.Args, PathForTransformer.SuccessType]
        ): Future[RichResponse[PathForTransformer.Args, PathForTransformer.Result]] = {
          val iprot = request._1
          val seqid = request._2
          val args = PathForTransformer.Args.decode(iprot)
          iprot.readMessageEnd()
          val res = service(args)
          res.transform {
            case _root_.com.twitter.util.Return(value) =>
              val methodResult = PathForTransformer.Result(success = Some(value))
              Future.value(
                SuccessfulResponse(
                  args,
                  reply("pathForTransformer", seqid, methodResult),
                  methodResult))
            case _root_.com.twitter.util.Throw(e: modeldb.ResourceNotFoundException) => {
              Future.value(
                ThriftExceptionResponse(
                  args,
                  reply("pathForTransformer", seqid, PathForTransformer.Result(rnfEx = Some(e))),
                  e))
            }
            case _root_.com.twitter.util.Throw(e: modeldb.InvalidFieldException) => {
              Future.value(
                ThriftExceptionResponse(
                  args,
                  reply("pathForTransformer", seqid, PathForTransformer.Result(efEx = Some(e))),
                  e))
            }
            case _root_.com.twitter.util.Throw(e: modeldb.ServerLogicException) => {
              Future.value(
                ThriftExceptionResponse(
                  args,
                  reply("pathForTransformer", seqid, PathForTransformer.Result(svEx = Some(e))),
                  e))
            }
            case t @ _root_.com.twitter.util.Throw(_) =>
              Future.const(t.cast[RichResponse[PathForTransformer.Args, PathForTransformer.Result]])
          }
        }
      }
    
      statsFilter.andThen(protocolExnFilter).andThen(serdeFilter)
    }
    val storeFitEvent: finagle$Filter[(TProtocol, Int), Array[Byte], StoreFitEvent.Args, StoreFitEvent.SuccessType] = {
      val statsFilter: finagle$Filter[(TProtocol, Int), Array[Byte], (TProtocol, Int), RichResponse[StoreFitEvent.Args, StoreFitEvent.Result]] = perMethodStatsFilter(StoreFitEvent)
    
      val protocolExnFilter = new SimpleFilter[(TProtocol, Int), RichResponse[StoreFitEvent.Args, StoreFitEvent.Result]] {
        def apply(
          request: (TProtocol, Int),
          service: finagle$Service[(TProtocol, Int), RichResponse[StoreFitEvent.Args, StoreFitEvent.Result]]
        ): Future[RichResponse[StoreFitEvent.Args, StoreFitEvent.Result]] = {
          val iprot = request._1
          val seqid = request._2
          val res = service(request)
          res.transform {
            case _root_.com.twitter.util.Throw(e: TProtocolException) =>
              iprot.readMessageEnd()
              Future.value(
                ProtocolExceptionResponse(
                  null,
                  exception("storeFitEvent", seqid, TApplicationException.PROTOCOL_ERROR, e.getMessage),
                  new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage)))
            case _ =>
              res
          }
        }
      }
    
      val serdeFilter = new finagle$Filter[(TProtocol, Int), RichResponse[StoreFitEvent.Args, StoreFitEvent.Result], StoreFitEvent.Args, StoreFitEvent.SuccessType] {
        def apply(
          request: (TProtocol, Int),
          service: finagle$Service[StoreFitEvent.Args, StoreFitEvent.SuccessType]
        ): Future[RichResponse[StoreFitEvent.Args, StoreFitEvent.Result]] = {
          val iprot = request._1
          val seqid = request._2
          val args = StoreFitEvent.Args.decode(iprot)
          iprot.readMessageEnd()
          val res = service(args)
          res.transform {
            case _root_.com.twitter.util.Return(value) =>
              val methodResult = StoreFitEvent.Result(success = Some(value))
              Future.value(
                SuccessfulResponse(
                  args,
                  reply("storeFitEvent", seqid, methodResult),
                  methodResult))
            case _root_.com.twitter.util.Throw(e: modeldb.InvalidExperimentRunException) => {
              Future.value(
                ThriftExceptionResponse(
                  args,
                  reply("storeFitEvent", seqid, StoreFitEvent.Result(ierEx = Some(e))),
                  e))
            }
            case _root_.com.twitter.util.Throw(e: modeldb.ServerLogicException) => {
              Future.value(
                ThriftExceptionResponse(
                  args,
                  reply("storeFitEvent", seqid, StoreFitEvent.Result(svEx = Some(e))),
                  e))
            }
            case t @ _root_.com.twitter.util.Throw(_) =>
              Future.const(t.cast[RichResponse[StoreFitEvent.Args, StoreFitEvent.Result]])
          }
        }
      }
    
      statsFilter.andThen(protocolExnFilter).andThen(serdeFilter)
    }
    val storeMetricEvent: finagle$Filter[(TProtocol, Int), Array[Byte], StoreMetricEvent.Args, StoreMetricEvent.SuccessType] = {
      val statsFilter: finagle$Filter[(TProtocol, Int), Array[Byte], (TProtocol, Int), RichResponse[StoreMetricEvent.Args, StoreMetricEvent.Result]] = perMethodStatsFilter(StoreMetricEvent)
    
      val protocolExnFilter = new SimpleFilter[(TProtocol, Int), RichResponse[StoreMetricEvent.Args, StoreMetricEvent.Result]] {
        def apply(
          request: (TProtocol, Int),
          service: finagle$Service[(TProtocol, Int), RichResponse[StoreMetricEvent.Args, StoreMetricEvent.Result]]
        ): Future[RichResponse[StoreMetricEvent.Args, StoreMetricEvent.Result]] = {
          val iprot = request._1
          val seqid = request._2
          val res = service(request)
          res.transform {
            case _root_.com.twitter.util.Throw(e: TProtocolException) =>
              iprot.readMessageEnd()
              Future.value(
                ProtocolExceptionResponse(
                  null,
                  exception("storeMetricEvent", seqid, TApplicationException.PROTOCOL_ERROR, e.getMessage),
                  new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage)))
            case _ =>
              res
          }
        }
      }
    
      val serdeFilter = new finagle$Filter[(TProtocol, Int), RichResponse[StoreMetricEvent.Args, StoreMetricEvent.Result], StoreMetricEvent.Args, StoreMetricEvent.SuccessType] {
        def apply(
          request: (TProtocol, Int),
          service: finagle$Service[StoreMetricEvent.Args, StoreMetricEvent.SuccessType]
        ): Future[RichResponse[StoreMetricEvent.Args, StoreMetricEvent.Result]] = {
          val iprot = request._1
          val seqid = request._2
          val args = StoreMetricEvent.Args.decode(iprot)
          iprot.readMessageEnd()
          val res = service(args)
          res.transform {
            case _root_.com.twitter.util.Return(value) =>
              val methodResult = StoreMetricEvent.Result(success = Some(value))
              Future.value(
                SuccessfulResponse(
                  args,
                  reply("storeMetricEvent", seqid, methodResult),
                  methodResult))
            case _root_.com.twitter.util.Throw(e: modeldb.InvalidExperimentRunException) => {
              Future.value(
                ThriftExceptionResponse(
                  args,
                  reply("storeMetricEvent", seqid, StoreMetricEvent.Result(ierEx = Some(e))),
                  e))
            }
            case _root_.com.twitter.util.Throw(e: modeldb.ServerLogicException) => {
              Future.value(
                ThriftExceptionResponse(
                  args,
                  reply("storeMetricEvent", seqid, StoreMetricEvent.Result(svEx = Some(e))),
                  e))
            }
            case t @ _root_.com.twitter.util.Throw(_) =>
              Future.const(t.cast[RichResponse[StoreMetricEvent.Args, StoreMetricEvent.Result]])
          }
        }
      }
    
      statsFilter.andThen(protocolExnFilter).andThen(serdeFilter)
    }
    val getFilePath: finagle$Filter[(TProtocol, Int), Array[Byte], GetFilePath.Args, GetFilePath.SuccessType] = {
      val statsFilter: finagle$Filter[(TProtocol, Int), Array[Byte], (TProtocol, Int), RichResponse[GetFilePath.Args, GetFilePath.Result]] = perMethodStatsFilter(GetFilePath)
    
      val protocolExnFilter = new SimpleFilter[(TProtocol, Int), RichResponse[GetFilePath.Args, GetFilePath.Result]] {
        def apply(
          request: (TProtocol, Int),
          service: finagle$Service[(TProtocol, Int), RichResponse[GetFilePath.Args, GetFilePath.Result]]
        ): Future[RichResponse[GetFilePath.Args, GetFilePath.Result]] = {
          val iprot = request._1
          val seqid = request._2
          val res = service(request)
          res.transform {
            case _root_.com.twitter.util.Throw(e: TProtocolException) =>
              iprot.readMessageEnd()
              Future.value(
                ProtocolExceptionResponse(
                  null,
                  exception("getFilePath", seqid, TApplicationException.PROTOCOL_ERROR, e.getMessage),
                  new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage)))
            case _ =>
              res
          }
        }
      }
    
      val serdeFilter = new finagle$Filter[(TProtocol, Int), RichResponse[GetFilePath.Args, GetFilePath.Result], GetFilePath.Args, GetFilePath.SuccessType] {
        def apply(
          request: (TProtocol, Int),
          service: finagle$Service[GetFilePath.Args, GetFilePath.SuccessType]
        ): Future[RichResponse[GetFilePath.Args, GetFilePath.Result]] = {
          val iprot = request._1
          val seqid = request._2
          val args = GetFilePath.Args.decode(iprot)
          iprot.readMessageEnd()
          val res = service(args)
          res.transform {
            case _root_.com.twitter.util.Return(value) =>
              val methodResult = GetFilePath.Result(success = Some(value))
              Future.value(
                SuccessfulResponse(
                  args,
                  reply("getFilePath", seqid, methodResult),
                  methodResult))
            case _root_.com.twitter.util.Throw(e: modeldb.ResourceNotFoundException) => {
              Future.value(
                ThriftExceptionResponse(
                  args,
                  reply("getFilePath", seqid, GetFilePath.Result(rnfEx = Some(e))),
                  e))
            }
            case _root_.com.twitter.util.Throw(e: modeldb.ServerLogicException) => {
              Future.value(
                ThriftExceptionResponse(
                  args,
                  reply("getFilePath", seqid, GetFilePath.Result(svEx = Some(e))),
                  e))
            }
            case t @ _root_.com.twitter.util.Throw(_) =>
              Future.const(t.cast[RichResponse[GetFilePath.Args, GetFilePath.Result]])
          }
        }
      }
    
      statsFilter.andThen(protocolExnFilter).andThen(serdeFilter)
    }
    val storeTransformEvent: finagle$Filter[(TProtocol, Int), Array[Byte], StoreTransformEvent.Args, StoreTransformEvent.SuccessType] = {
      val statsFilter: finagle$Filter[(TProtocol, Int), Array[Byte], (TProtocol, Int), RichResponse[StoreTransformEvent.Args, StoreTransformEvent.Result]] = perMethodStatsFilter(StoreTransformEvent)
    
      val protocolExnFilter = new SimpleFilter[(TProtocol, Int), RichResponse[StoreTransformEvent.Args, StoreTransformEvent.Result]] {
        def apply(
          request: (TProtocol, Int),
          service: finagle$Service[(TProtocol, Int), RichResponse[StoreTransformEvent.Args, StoreTransformEvent.Result]]
        ): Future[RichResponse[StoreTransformEvent.Args, StoreTransformEvent.Result]] = {
          val iprot = request._1
          val seqid = request._2
          val res = service(request)
          res.transform {
            case _root_.com.twitter.util.Throw(e: TProtocolException) =>
              iprot.readMessageEnd()
              Future.value(
                ProtocolExceptionResponse(
                  null,
                  exception("storeTransformEvent", seqid, TApplicationException.PROTOCOL_ERROR, e.getMessage),
                  new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage)))
            case _ =>
              res
          }
        }
      }
    
      val serdeFilter = new finagle$Filter[(TProtocol, Int), RichResponse[StoreTransformEvent.Args, StoreTransformEvent.Result], StoreTransformEvent.Args, StoreTransformEvent.SuccessType] {
        def apply(
          request: (TProtocol, Int),
          service: finagle$Service[StoreTransformEvent.Args, StoreTransformEvent.SuccessType]
        ): Future[RichResponse[StoreTransformEvent.Args, StoreTransformEvent.Result]] = {
          val iprot = request._1
          val seqid = request._2
          val args = StoreTransformEvent.Args.decode(iprot)
          iprot.readMessageEnd()
          val res = service(args)
          res.transform {
            case _root_.com.twitter.util.Return(value) =>
              val methodResult = StoreTransformEvent.Result(success = Some(value))
              Future.value(
                SuccessfulResponse(
                  args,
                  reply("storeTransformEvent", seqid, methodResult),
                  methodResult))
            case _root_.com.twitter.util.Throw(e: modeldb.InvalidExperimentRunException) => {
              Future.value(
                ThriftExceptionResponse(
                  args,
                  reply("storeTransformEvent", seqid, StoreTransformEvent.Result(ierEx = Some(e))),
                  e))
            }
            case _root_.com.twitter.util.Throw(e: modeldb.ServerLogicException) => {
              Future.value(
                ThriftExceptionResponse(
                  args,
                  reply("storeTransformEvent", seqid, StoreTransformEvent.Result(svEx = Some(e))),
                  e))
            }
            case t @ _root_.com.twitter.util.Throw(_) =>
              Future.const(t.cast[RichResponse[StoreTransformEvent.Args, StoreTransformEvent.Result]])
          }
        }
      }
    
      statsFilter.andThen(protocolExnFilter).andThen(serdeFilter)
    }
    val storeRandomSplitEvent: finagle$Filter[(TProtocol, Int), Array[Byte], StoreRandomSplitEvent.Args, StoreRandomSplitEvent.SuccessType] = {
      val statsFilter: finagle$Filter[(TProtocol, Int), Array[Byte], (TProtocol, Int), RichResponse[StoreRandomSplitEvent.Args, StoreRandomSplitEvent.Result]] = perMethodStatsFilter(StoreRandomSplitEvent)
    
      val protocolExnFilter = new SimpleFilter[(TProtocol, Int), RichResponse[StoreRandomSplitEvent.Args, StoreRandomSplitEvent.Result]] {
        def apply(
          request: (TProtocol, Int),
          service: finagle$Service[(TProtocol, Int), RichResponse[StoreRandomSplitEvent.Args, StoreRandomSplitEvent.Result]]
        ): Future[RichResponse[StoreRandomSplitEvent.Args, StoreRandomSplitEvent.Result]] = {
          val iprot = request._1
          val seqid = request._2
          val res = service(request)
          res.transform {
            case _root_.com.twitter.util.Throw(e: TProtocolException) =>
              iprot.readMessageEnd()
              Future.value(
                ProtocolExceptionResponse(
                  null,
                  exception("storeRandomSplitEvent", seqid, TApplicationException.PROTOCOL_ERROR, e.getMessage),
                  new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage)))
            case _ =>
              res
          }
        }
      }
    
      val serdeFilter = new finagle$Filter[(TProtocol, Int), RichResponse[StoreRandomSplitEvent.Args, StoreRandomSplitEvent.Result], StoreRandomSplitEvent.Args, StoreRandomSplitEvent.SuccessType] {
        def apply(
          request: (TProtocol, Int),
          service: finagle$Service[StoreRandomSplitEvent.Args, StoreRandomSplitEvent.SuccessType]
        ): Future[RichResponse[StoreRandomSplitEvent.Args, StoreRandomSplitEvent.Result]] = {
          val iprot = request._1
          val seqid = request._2
          val args = StoreRandomSplitEvent.Args.decode(iprot)
          iprot.readMessageEnd()
          val res = service(args)
          res.transform {
            case _root_.com.twitter.util.Return(value) =>
              val methodResult = StoreRandomSplitEvent.Result(success = Some(value))
              Future.value(
                SuccessfulResponse(
                  args,
                  reply("storeRandomSplitEvent", seqid, methodResult),
                  methodResult))
            case _root_.com.twitter.util.Throw(e: modeldb.ServerLogicException) => {
              Future.value(
                ThriftExceptionResponse(
                  args,
                  reply("storeRandomSplitEvent", seqid, StoreRandomSplitEvent.Result(svEx = Some(e))),
                  e))
            }
            case t @ _root_.com.twitter.util.Throw(_) =>
              Future.const(t.cast[RichResponse[StoreRandomSplitEvent.Args, StoreRandomSplitEvent.Result]])
          }
        }
      }
    
      statsFilter.andThen(protocolExnFilter).andThen(serdeFilter)
    }
    val storePipelineEvent: finagle$Filter[(TProtocol, Int), Array[Byte], StorePipelineEvent.Args, StorePipelineEvent.SuccessType] = {
      val statsFilter: finagle$Filter[(TProtocol, Int), Array[Byte], (TProtocol, Int), RichResponse[StorePipelineEvent.Args, StorePipelineEvent.Result]] = perMethodStatsFilter(StorePipelineEvent)
    
      val protocolExnFilter = new SimpleFilter[(TProtocol, Int), RichResponse[StorePipelineEvent.Args, StorePipelineEvent.Result]] {
        def apply(
          request: (TProtocol, Int),
          service: finagle$Service[(TProtocol, Int), RichResponse[StorePipelineEvent.Args, StorePipelineEvent.Result]]
        ): Future[RichResponse[StorePipelineEvent.Args, StorePipelineEvent.Result]] = {
          val iprot = request._1
          val seqid = request._2
          val res = service(request)
          res.transform {
            case _root_.com.twitter.util.Throw(e: TProtocolException) =>
              iprot.readMessageEnd()
              Future.value(
                ProtocolExceptionResponse(
                  null,
                  exception("storePipelineEvent", seqid, TApplicationException.PROTOCOL_ERROR, e.getMessage),
                  new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage)))
            case _ =>
              res
          }
        }
      }
    
      val serdeFilter = new finagle$Filter[(TProtocol, Int), RichResponse[StorePipelineEvent.Args, StorePipelineEvent.Result], StorePipelineEvent.Args, StorePipelineEvent.SuccessType] {
        def apply(
          request: (TProtocol, Int),
          service: finagle$Service[StorePipelineEvent.Args, StorePipelineEvent.SuccessType]
        ): Future[RichResponse[StorePipelineEvent.Args, StorePipelineEvent.Result]] = {
          val iprot = request._1
          val seqid = request._2
          val args = StorePipelineEvent.Args.decode(iprot)
          iprot.readMessageEnd()
          val res = service(args)
          res.transform {
            case _root_.com.twitter.util.Return(value) =>
              val methodResult = StorePipelineEvent.Result(success = Some(value))
              Future.value(
                SuccessfulResponse(
                  args,
                  reply("storePipelineEvent", seqid, methodResult),
                  methodResult))
            case _root_.com.twitter.util.Throw(e: modeldb.ServerLogicException) => {
              Future.value(
                ThriftExceptionResponse(
                  args,
                  reply("storePipelineEvent", seqid, StorePipelineEvent.Result(svEx = Some(e))),
                  e))
            }
            case t @ _root_.com.twitter.util.Throw(_) =>
              Future.const(t.cast[RichResponse[StorePipelineEvent.Args, StorePipelineEvent.Result]])
          }
        }
      }
    
      statsFilter.andThen(protocolExnFilter).andThen(serdeFilter)
    }
    val storeCrossValidationEvent: finagle$Filter[(TProtocol, Int), Array[Byte], StoreCrossValidationEvent.Args, StoreCrossValidationEvent.SuccessType] = {
      val statsFilter: finagle$Filter[(TProtocol, Int), Array[Byte], (TProtocol, Int), RichResponse[StoreCrossValidationEvent.Args, StoreCrossValidationEvent.Result]] = perMethodStatsFilter(StoreCrossValidationEvent)
    
      val protocolExnFilter = new SimpleFilter[(TProtocol, Int), RichResponse[StoreCrossValidationEvent.Args, StoreCrossValidationEvent.Result]] {
        def apply(
          request: (TProtocol, Int),
          service: finagle$Service[(TProtocol, Int), RichResponse[StoreCrossValidationEvent.Args, StoreCrossValidationEvent.Result]]
        ): Future[RichResponse[StoreCrossValidationEvent.Args, StoreCrossValidationEvent.Result]] = {
          val iprot = request._1
          val seqid = request._2
          val res = service(request)
          res.transform {
            case _root_.com.twitter.util.Throw(e: TProtocolException) =>
              iprot.readMessageEnd()
              Future.value(
                ProtocolExceptionResponse(
                  null,
                  exception("storeCrossValidationEvent", seqid, TApplicationException.PROTOCOL_ERROR, e.getMessage),
                  new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage)))
            case _ =>
              res
          }
        }
      }
    
      val serdeFilter = new finagle$Filter[(TProtocol, Int), RichResponse[StoreCrossValidationEvent.Args, StoreCrossValidationEvent.Result], StoreCrossValidationEvent.Args, StoreCrossValidationEvent.SuccessType] {
        def apply(
          request: (TProtocol, Int),
          service: finagle$Service[StoreCrossValidationEvent.Args, StoreCrossValidationEvent.SuccessType]
        ): Future[RichResponse[StoreCrossValidationEvent.Args, StoreCrossValidationEvent.Result]] = {
          val iprot = request._1
          val seqid = request._2
          val args = StoreCrossValidationEvent.Args.decode(iprot)
          iprot.readMessageEnd()
          val res = service(args)
          res.transform {
            case _root_.com.twitter.util.Return(value) =>
              val methodResult = StoreCrossValidationEvent.Result(success = Some(value))
              Future.value(
                SuccessfulResponse(
                  args,
                  reply("storeCrossValidationEvent", seqid, methodResult),
                  methodResult))
            case _root_.com.twitter.util.Throw(e: modeldb.ServerLogicException) => {
              Future.value(
                ThriftExceptionResponse(
                  args,
                  reply("storeCrossValidationEvent", seqid, StoreCrossValidationEvent.Result(svEx = Some(e))),
                  e))
            }
            case t @ _root_.com.twitter.util.Throw(_) =>
              Future.const(t.cast[RichResponse[StoreCrossValidationEvent.Args, StoreCrossValidationEvent.Result]])
          }
        }
      }
    
      statsFilter.andThen(protocolExnFilter).andThen(serdeFilter)
    }
    val storeGridSearchCrossValidationEvent: finagle$Filter[(TProtocol, Int), Array[Byte], StoreGridSearchCrossValidationEvent.Args, StoreGridSearchCrossValidationEvent.SuccessType] = {
      val statsFilter: finagle$Filter[(TProtocol, Int), Array[Byte], (TProtocol, Int), RichResponse[StoreGridSearchCrossValidationEvent.Args, StoreGridSearchCrossValidationEvent.Result]] = perMethodStatsFilter(StoreGridSearchCrossValidationEvent)
    
      val protocolExnFilter = new SimpleFilter[(TProtocol, Int), RichResponse[StoreGridSearchCrossValidationEvent.Args, StoreGridSearchCrossValidationEvent.Result]] {
        def apply(
          request: (TProtocol, Int),
          service: finagle$Service[(TProtocol, Int), RichResponse[StoreGridSearchCrossValidationEvent.Args, StoreGridSearchCrossValidationEvent.Result]]
        ): Future[RichResponse[StoreGridSearchCrossValidationEvent.Args, StoreGridSearchCrossValidationEvent.Result]] = {
          val iprot = request._1
          val seqid = request._2
          val res = service(request)
          res.transform {
            case _root_.com.twitter.util.Throw(e: TProtocolException) =>
              iprot.readMessageEnd()
              Future.value(
                ProtocolExceptionResponse(
                  null,
                  exception("storeGridSearchCrossValidationEvent", seqid, TApplicationException.PROTOCOL_ERROR, e.getMessage),
                  new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage)))
            case _ =>
              res
          }
        }
      }
    
      val serdeFilter = new finagle$Filter[(TProtocol, Int), RichResponse[StoreGridSearchCrossValidationEvent.Args, StoreGridSearchCrossValidationEvent.Result], StoreGridSearchCrossValidationEvent.Args, StoreGridSearchCrossValidationEvent.SuccessType] {
        def apply(
          request: (TProtocol, Int),
          service: finagle$Service[StoreGridSearchCrossValidationEvent.Args, StoreGridSearchCrossValidationEvent.SuccessType]
        ): Future[RichResponse[StoreGridSearchCrossValidationEvent.Args, StoreGridSearchCrossValidationEvent.Result]] = {
          val iprot = request._1
          val seqid = request._2
          val args = StoreGridSearchCrossValidationEvent.Args.decode(iprot)
          iprot.readMessageEnd()
          val res = service(args)
          res.transform {
            case _root_.com.twitter.util.Return(value) =>
              val methodResult = StoreGridSearchCrossValidationEvent.Result(success = Some(value))
              Future.value(
                SuccessfulResponse(
                  args,
                  reply("storeGridSearchCrossValidationEvent", seqid, methodResult),
                  methodResult))
            case _root_.com.twitter.util.Throw(e: modeldb.ServerLogicException) => {
              Future.value(
                ThriftExceptionResponse(
                  args,
                  reply("storeGridSearchCrossValidationEvent", seqid, StoreGridSearchCrossValidationEvent.Result(svEx = Some(e))),
                  e))
            }
            case t @ _root_.com.twitter.util.Throw(_) =>
              Future.const(t.cast[RichResponse[StoreGridSearchCrossValidationEvent.Args, StoreGridSearchCrossValidationEvent.Result]])
          }
        }
      }
    
      statsFilter.andThen(protocolExnFilter).andThen(serdeFilter)
    }
    val storeAnnotationEvent: finagle$Filter[(TProtocol, Int), Array[Byte], StoreAnnotationEvent.Args, StoreAnnotationEvent.SuccessType] = {
      val statsFilter: finagle$Filter[(TProtocol, Int), Array[Byte], (TProtocol, Int), RichResponse[StoreAnnotationEvent.Args, StoreAnnotationEvent.Result]] = perMethodStatsFilter(StoreAnnotationEvent)
    
      val protocolExnFilter = new SimpleFilter[(TProtocol, Int), RichResponse[StoreAnnotationEvent.Args, StoreAnnotationEvent.Result]] {
        def apply(
          request: (TProtocol, Int),
          service: finagle$Service[(TProtocol, Int), RichResponse[StoreAnnotationEvent.Args, StoreAnnotationEvent.Result]]
        ): Future[RichResponse[StoreAnnotationEvent.Args, StoreAnnotationEvent.Result]] = {
          val iprot = request._1
          val seqid = request._2
          val res = service(request)
          res.transform {
            case _root_.com.twitter.util.Throw(e: TProtocolException) =>
              iprot.readMessageEnd()
              Future.value(
                ProtocolExceptionResponse(
                  null,
                  exception("storeAnnotationEvent", seqid, TApplicationException.PROTOCOL_ERROR, e.getMessage),
                  new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage)))
            case _ =>
              res
          }
        }
      }
    
      val serdeFilter = new finagle$Filter[(TProtocol, Int), RichResponse[StoreAnnotationEvent.Args, StoreAnnotationEvent.Result], StoreAnnotationEvent.Args, StoreAnnotationEvent.SuccessType] {
        def apply(
          request: (TProtocol, Int),
          service: finagle$Service[StoreAnnotationEvent.Args, StoreAnnotationEvent.SuccessType]
        ): Future[RichResponse[StoreAnnotationEvent.Args, StoreAnnotationEvent.Result]] = {
          val iprot = request._1
          val seqid = request._2
          val args = StoreAnnotationEvent.Args.decode(iprot)
          iprot.readMessageEnd()
          val res = service(args)
          res.transform {
            case _root_.com.twitter.util.Return(value) =>
              val methodResult = StoreAnnotationEvent.Result(success = Some(value))
              Future.value(
                SuccessfulResponse(
                  args,
                  reply("storeAnnotationEvent", seqid, methodResult),
                  methodResult))
            case _root_.com.twitter.util.Throw(e: modeldb.ServerLogicException) => {
              Future.value(
                ThriftExceptionResponse(
                  args,
                  reply("storeAnnotationEvent", seqid, StoreAnnotationEvent.Result(svEx = Some(e))),
                  e))
            }
            case t @ _root_.com.twitter.util.Throw(_) =>
              Future.const(t.cast[RichResponse[StoreAnnotationEvent.Args, StoreAnnotationEvent.Result]])
          }
        }
      }
    
      statsFilter.andThen(protocolExnFilter).andThen(serdeFilter)
    }
    val storeProjectEvent: finagle$Filter[(TProtocol, Int), Array[Byte], StoreProjectEvent.Args, StoreProjectEvent.SuccessType] = {
      val statsFilter: finagle$Filter[(TProtocol, Int), Array[Byte], (TProtocol, Int), RichResponse[StoreProjectEvent.Args, StoreProjectEvent.Result]] = perMethodStatsFilter(StoreProjectEvent)
    
      val protocolExnFilter = new SimpleFilter[(TProtocol, Int), RichResponse[StoreProjectEvent.Args, StoreProjectEvent.Result]] {
        def apply(
          request: (TProtocol, Int),
          service: finagle$Service[(TProtocol, Int), RichResponse[StoreProjectEvent.Args, StoreProjectEvent.Result]]
        ): Future[RichResponse[StoreProjectEvent.Args, StoreProjectEvent.Result]] = {
          val iprot = request._1
          val seqid = request._2
          val res = service(request)
          res.transform {
            case _root_.com.twitter.util.Throw(e: TProtocolException) =>
              iprot.readMessageEnd()
              Future.value(
                ProtocolExceptionResponse(
                  null,
                  exception("storeProjectEvent", seqid, TApplicationException.PROTOCOL_ERROR, e.getMessage),
                  new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage)))
            case _ =>
              res
          }
        }
      }
    
      val serdeFilter = new finagle$Filter[(TProtocol, Int), RichResponse[StoreProjectEvent.Args, StoreProjectEvent.Result], StoreProjectEvent.Args, StoreProjectEvent.SuccessType] {
        def apply(
          request: (TProtocol, Int),
          service: finagle$Service[StoreProjectEvent.Args, StoreProjectEvent.SuccessType]
        ): Future[RichResponse[StoreProjectEvent.Args, StoreProjectEvent.Result]] = {
          val iprot = request._1
          val seqid = request._2
          val args = StoreProjectEvent.Args.decode(iprot)
          iprot.readMessageEnd()
          val res = service(args)
          res.transform {
            case _root_.com.twitter.util.Return(value) =>
              val methodResult = StoreProjectEvent.Result(success = Some(value))
              Future.value(
                SuccessfulResponse(
                  args,
                  reply("storeProjectEvent", seqid, methodResult),
                  methodResult))
            case _root_.com.twitter.util.Throw(e: modeldb.ServerLogicException) => {
              Future.value(
                ThriftExceptionResponse(
                  args,
                  reply("storeProjectEvent", seqid, StoreProjectEvent.Result(svEx = Some(e))),
                  e))
            }
            case t @ _root_.com.twitter.util.Throw(_) =>
              Future.const(t.cast[RichResponse[StoreProjectEvent.Args, StoreProjectEvent.Result]])
          }
        }
      }
    
      statsFilter.andThen(protocolExnFilter).andThen(serdeFilter)
    }
    val storeExperimentEvent: finagle$Filter[(TProtocol, Int), Array[Byte], StoreExperimentEvent.Args, StoreExperimentEvent.SuccessType] = {
      val statsFilter: finagle$Filter[(TProtocol, Int), Array[Byte], (TProtocol, Int), RichResponse[StoreExperimentEvent.Args, StoreExperimentEvent.Result]] = perMethodStatsFilter(StoreExperimentEvent)
    
      val protocolExnFilter = new SimpleFilter[(TProtocol, Int), RichResponse[StoreExperimentEvent.Args, StoreExperimentEvent.Result]] {
        def apply(
          request: (TProtocol, Int),
          service: finagle$Service[(TProtocol, Int), RichResponse[StoreExperimentEvent.Args, StoreExperimentEvent.Result]]
        ): Future[RichResponse[StoreExperimentEvent.Args, StoreExperimentEvent.Result]] = {
          val iprot = request._1
          val seqid = request._2
          val res = service(request)
          res.transform {
            case _root_.com.twitter.util.Throw(e: TProtocolException) =>
              iprot.readMessageEnd()
              Future.value(
                ProtocolExceptionResponse(
                  null,
                  exception("storeExperimentEvent", seqid, TApplicationException.PROTOCOL_ERROR, e.getMessage),
                  new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage)))
            case _ =>
              res
          }
        }
      }
    
      val serdeFilter = new finagle$Filter[(TProtocol, Int), RichResponse[StoreExperimentEvent.Args, StoreExperimentEvent.Result], StoreExperimentEvent.Args, StoreExperimentEvent.SuccessType] {
        def apply(
          request: (TProtocol, Int),
          service: finagle$Service[StoreExperimentEvent.Args, StoreExperimentEvent.SuccessType]
        ): Future[RichResponse[StoreExperimentEvent.Args, StoreExperimentEvent.Result]] = {
          val iprot = request._1
          val seqid = request._2
          val args = StoreExperimentEvent.Args.decode(iprot)
          iprot.readMessageEnd()
          val res = service(args)
          res.transform {
            case _root_.com.twitter.util.Return(value) =>
              val methodResult = StoreExperimentEvent.Result(success = Some(value))
              Future.value(
                SuccessfulResponse(
                  args,
                  reply("storeExperimentEvent", seqid, methodResult),
                  methodResult))
            case _root_.com.twitter.util.Throw(e: modeldb.ServerLogicException) => {
              Future.value(
                ThriftExceptionResponse(
                  args,
                  reply("storeExperimentEvent", seqid, StoreExperimentEvent.Result(svEx = Some(e))),
                  e))
            }
            case t @ _root_.com.twitter.util.Throw(_) =>
              Future.const(t.cast[RichResponse[StoreExperimentEvent.Args, StoreExperimentEvent.Result]])
          }
        }
      }
    
      statsFilter.andThen(protocolExnFilter).andThen(serdeFilter)
    }
    val storeExperimentRunEvent: finagle$Filter[(TProtocol, Int), Array[Byte], StoreExperimentRunEvent.Args, StoreExperimentRunEvent.SuccessType] = {
      val statsFilter: finagle$Filter[(TProtocol, Int), Array[Byte], (TProtocol, Int), RichResponse[StoreExperimentRunEvent.Args, StoreExperimentRunEvent.Result]] = perMethodStatsFilter(StoreExperimentRunEvent)
    
      val protocolExnFilter = new SimpleFilter[(TProtocol, Int), RichResponse[StoreExperimentRunEvent.Args, StoreExperimentRunEvent.Result]] {
        def apply(
          request: (TProtocol, Int),
          service: finagle$Service[(TProtocol, Int), RichResponse[StoreExperimentRunEvent.Args, StoreExperimentRunEvent.Result]]
        ): Future[RichResponse[StoreExperimentRunEvent.Args, StoreExperimentRunEvent.Result]] = {
          val iprot = request._1
          val seqid = request._2
          val res = service(request)
          res.transform {
            case _root_.com.twitter.util.Throw(e: TProtocolException) =>
              iprot.readMessageEnd()
              Future.value(
                ProtocolExceptionResponse(
                  null,
                  exception("storeExperimentRunEvent", seqid, TApplicationException.PROTOCOL_ERROR, e.getMessage),
                  new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage)))
            case _ =>
              res
          }
        }
      }
    
      val serdeFilter = new finagle$Filter[(TProtocol, Int), RichResponse[StoreExperimentRunEvent.Args, StoreExperimentRunEvent.Result], StoreExperimentRunEvent.Args, StoreExperimentRunEvent.SuccessType] {
        def apply(
          request: (TProtocol, Int),
          service: finagle$Service[StoreExperimentRunEvent.Args, StoreExperimentRunEvent.SuccessType]
        ): Future[RichResponse[StoreExperimentRunEvent.Args, StoreExperimentRunEvent.Result]] = {
          val iprot = request._1
          val seqid = request._2
          val args = StoreExperimentRunEvent.Args.decode(iprot)
          iprot.readMessageEnd()
          val res = service(args)
          res.transform {
            case _root_.com.twitter.util.Return(value) =>
              val methodResult = StoreExperimentRunEvent.Result(success = Some(value))
              Future.value(
                SuccessfulResponse(
                  args,
                  reply("storeExperimentRunEvent", seqid, methodResult),
                  methodResult))
            case _root_.com.twitter.util.Throw(e: modeldb.ServerLogicException) => {
              Future.value(
                ThriftExceptionResponse(
                  args,
                  reply("storeExperimentRunEvent", seqid, StoreExperimentRunEvent.Result(svEx = Some(e))),
                  e))
            }
            case t @ _root_.com.twitter.util.Throw(_) =>
              Future.const(t.cast[RichResponse[StoreExperimentRunEvent.Args, StoreExperimentRunEvent.Result]])
          }
        }
      }
    
      statsFilter.andThen(protocolExnFilter).andThen(serdeFilter)
    }
    val storeLinearModel: finagle$Filter[(TProtocol, Int), Array[Byte], StoreLinearModel.Args, StoreLinearModel.SuccessType] = {
      val statsFilter: finagle$Filter[(TProtocol, Int), Array[Byte], (TProtocol, Int), RichResponse[StoreLinearModel.Args, StoreLinearModel.Result]] = perMethodStatsFilter(StoreLinearModel)
    
      val protocolExnFilter = new SimpleFilter[(TProtocol, Int), RichResponse[StoreLinearModel.Args, StoreLinearModel.Result]] {
        def apply(
          request: (TProtocol, Int),
          service: finagle$Service[(TProtocol, Int), RichResponse[StoreLinearModel.Args, StoreLinearModel.Result]]
        ): Future[RichResponse[StoreLinearModel.Args, StoreLinearModel.Result]] = {
          val iprot = request._1
          val seqid = request._2
          val res = service(request)
          res.transform {
            case _root_.com.twitter.util.Throw(e: TProtocolException) =>
              iprot.readMessageEnd()
              Future.value(
                ProtocolExceptionResponse(
                  null,
                  exception("storeLinearModel", seqid, TApplicationException.PROTOCOL_ERROR, e.getMessage),
                  new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage)))
            case _ =>
              res
          }
        }
      }
    
      val serdeFilter = new finagle$Filter[(TProtocol, Int), RichResponse[StoreLinearModel.Args, StoreLinearModel.Result], StoreLinearModel.Args, StoreLinearModel.SuccessType] {
        def apply(
          request: (TProtocol, Int),
          service: finagle$Service[StoreLinearModel.Args, StoreLinearModel.SuccessType]
        ): Future[RichResponse[StoreLinearModel.Args, StoreLinearModel.Result]] = {
          val iprot = request._1
          val seqid = request._2
          val args = StoreLinearModel.Args.decode(iprot)
          iprot.readMessageEnd()
          val res = service(args)
          res.transform {
            case _root_.com.twitter.util.Return(value) =>
              val methodResult = StoreLinearModel.Result(success = Some(value))
              Future.value(
                SuccessfulResponse(
                  args,
                  reply("storeLinearModel", seqid, methodResult),
                  methodResult))
            case _root_.com.twitter.util.Throw(e: modeldb.ResourceNotFoundException) => {
              Future.value(
                ThriftExceptionResponse(
                  args,
                  reply("storeLinearModel", seqid, StoreLinearModel.Result(rnfEx = Some(e))),
                  e))
            }
            case _root_.com.twitter.util.Throw(e: modeldb.ServerLogicException) => {
              Future.value(
                ThriftExceptionResponse(
                  args,
                  reply("storeLinearModel", seqid, StoreLinearModel.Result(svEx = Some(e))),
                  e))
            }
            case t @ _root_.com.twitter.util.Throw(_) =>
              Future.const(t.cast[RichResponse[StoreLinearModel.Args, StoreLinearModel.Result]])
          }
        }
      }
    
      statsFilter.andThen(protocolExnFilter).andThen(serdeFilter)
    }
    val getDataFrameAncestry: finagle$Filter[(TProtocol, Int), Array[Byte], GetDataFrameAncestry.Args, GetDataFrameAncestry.SuccessType] = {
      val statsFilter: finagle$Filter[(TProtocol, Int), Array[Byte], (TProtocol, Int), RichResponse[GetDataFrameAncestry.Args, GetDataFrameAncestry.Result]] = perMethodStatsFilter(GetDataFrameAncestry)
    
      val protocolExnFilter = new SimpleFilter[(TProtocol, Int), RichResponse[GetDataFrameAncestry.Args, GetDataFrameAncestry.Result]] {
        def apply(
          request: (TProtocol, Int),
          service: finagle$Service[(TProtocol, Int), RichResponse[GetDataFrameAncestry.Args, GetDataFrameAncestry.Result]]
        ): Future[RichResponse[GetDataFrameAncestry.Args, GetDataFrameAncestry.Result]] = {
          val iprot = request._1
          val seqid = request._2
          val res = service(request)
          res.transform {
            case _root_.com.twitter.util.Throw(e: TProtocolException) =>
              iprot.readMessageEnd()
              Future.value(
                ProtocolExceptionResponse(
                  null,
                  exception("getDataFrameAncestry", seqid, TApplicationException.PROTOCOL_ERROR, e.getMessage),
                  new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage)))
            case _ =>
              res
          }
        }
      }
    
      val serdeFilter = new finagle$Filter[(TProtocol, Int), RichResponse[GetDataFrameAncestry.Args, GetDataFrameAncestry.Result], GetDataFrameAncestry.Args, GetDataFrameAncestry.SuccessType] {
        def apply(
          request: (TProtocol, Int),
          service: finagle$Service[GetDataFrameAncestry.Args, GetDataFrameAncestry.SuccessType]
        ): Future[RichResponse[GetDataFrameAncestry.Args, GetDataFrameAncestry.Result]] = {
          val iprot = request._1
          val seqid = request._2
          val args = GetDataFrameAncestry.Args.decode(iprot)
          iprot.readMessageEnd()
          val res = service(args)
          res.transform {
            case _root_.com.twitter.util.Return(value) =>
              val methodResult = GetDataFrameAncestry.Result(success = Some(value))
              Future.value(
                SuccessfulResponse(
                  args,
                  reply("getDataFrameAncestry", seqid, methodResult),
                  methodResult))
            case _root_.com.twitter.util.Throw(e: modeldb.ResourceNotFoundException) => {
              Future.value(
                ThriftExceptionResponse(
                  args,
                  reply("getDataFrameAncestry", seqid, GetDataFrameAncestry.Result(rnfEx = Some(e))),
                  e))
            }
            case _root_.com.twitter.util.Throw(e: modeldb.ServerLogicException) => {
              Future.value(
                ThriftExceptionResponse(
                  args,
                  reply("getDataFrameAncestry", seqid, GetDataFrameAncestry.Result(svEx = Some(e))),
                  e))
            }
            case t @ _root_.com.twitter.util.Throw(_) =>
              Future.const(t.cast[RichResponse[GetDataFrameAncestry.Args, GetDataFrameAncestry.Result]])
          }
        }
      }
    
      statsFilter.andThen(protocolExnFilter).andThen(serdeFilter)
    }
    val getCommonAncestor: finagle$Filter[(TProtocol, Int), Array[Byte], GetCommonAncestor.Args, GetCommonAncestor.SuccessType] = {
      val statsFilter: finagle$Filter[(TProtocol, Int), Array[Byte], (TProtocol, Int), RichResponse[GetCommonAncestor.Args, GetCommonAncestor.Result]] = perMethodStatsFilter(GetCommonAncestor)
    
      val protocolExnFilter = new SimpleFilter[(TProtocol, Int), RichResponse[GetCommonAncestor.Args, GetCommonAncestor.Result]] {
        def apply(
          request: (TProtocol, Int),
          service: finagle$Service[(TProtocol, Int), RichResponse[GetCommonAncestor.Args, GetCommonAncestor.Result]]
        ): Future[RichResponse[GetCommonAncestor.Args, GetCommonAncestor.Result]] = {
          val iprot = request._1
          val seqid = request._2
          val res = service(request)
          res.transform {
            case _root_.com.twitter.util.Throw(e: TProtocolException) =>
              iprot.readMessageEnd()
              Future.value(
                ProtocolExceptionResponse(
                  null,
                  exception("getCommonAncestor", seqid, TApplicationException.PROTOCOL_ERROR, e.getMessage),
                  new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage)))
            case _ =>
              res
          }
        }
      }
    
      val serdeFilter = new finagle$Filter[(TProtocol, Int), RichResponse[GetCommonAncestor.Args, GetCommonAncestor.Result], GetCommonAncestor.Args, GetCommonAncestor.SuccessType] {
        def apply(
          request: (TProtocol, Int),
          service: finagle$Service[GetCommonAncestor.Args, GetCommonAncestor.SuccessType]
        ): Future[RichResponse[GetCommonAncestor.Args, GetCommonAncestor.Result]] = {
          val iprot = request._1
          val seqid = request._2
          val args = GetCommonAncestor.Args.decode(iprot)
          iprot.readMessageEnd()
          val res = service(args)
          res.transform {
            case _root_.com.twitter.util.Return(value) =>
              val methodResult = GetCommonAncestor.Result(success = Some(value))
              Future.value(
                SuccessfulResponse(
                  args,
                  reply("getCommonAncestor", seqid, methodResult),
                  methodResult))
            case _root_.com.twitter.util.Throw(e: modeldb.ResourceNotFoundException) => {
              Future.value(
                ThriftExceptionResponse(
                  args,
                  reply("getCommonAncestor", seqid, GetCommonAncestor.Result(rnfEx = Some(e))),
                  e))
            }
            case _root_.com.twitter.util.Throw(e: modeldb.ServerLogicException) => {
              Future.value(
                ThriftExceptionResponse(
                  args,
                  reply("getCommonAncestor", seqid, GetCommonAncestor.Result(svEx = Some(e))),
                  e))
            }
            case t @ _root_.com.twitter.util.Throw(_) =>
              Future.const(t.cast[RichResponse[GetCommonAncestor.Args, GetCommonAncestor.Result]])
          }
        }
      }
    
      statsFilter.andThen(protocolExnFilter).andThen(serdeFilter)
    }
    val getCommonAncestorForModels: finagle$Filter[(TProtocol, Int), Array[Byte], GetCommonAncestorForModels.Args, GetCommonAncestorForModels.SuccessType] = {
      val statsFilter: finagle$Filter[(TProtocol, Int), Array[Byte], (TProtocol, Int), RichResponse[GetCommonAncestorForModels.Args, GetCommonAncestorForModels.Result]] = perMethodStatsFilter(GetCommonAncestorForModels)
    
      val protocolExnFilter = new SimpleFilter[(TProtocol, Int), RichResponse[GetCommonAncestorForModels.Args, GetCommonAncestorForModels.Result]] {
        def apply(
          request: (TProtocol, Int),
          service: finagle$Service[(TProtocol, Int), RichResponse[GetCommonAncestorForModels.Args, GetCommonAncestorForModels.Result]]
        ): Future[RichResponse[GetCommonAncestorForModels.Args, GetCommonAncestorForModels.Result]] = {
          val iprot = request._1
          val seqid = request._2
          val res = service(request)
          res.transform {
            case _root_.com.twitter.util.Throw(e: TProtocolException) =>
              iprot.readMessageEnd()
              Future.value(
                ProtocolExceptionResponse(
                  null,
                  exception("getCommonAncestorForModels", seqid, TApplicationException.PROTOCOL_ERROR, e.getMessage),
                  new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage)))
            case _ =>
              res
          }
        }
      }
    
      val serdeFilter = new finagle$Filter[(TProtocol, Int), RichResponse[GetCommonAncestorForModels.Args, GetCommonAncestorForModels.Result], GetCommonAncestorForModels.Args, GetCommonAncestorForModels.SuccessType] {
        def apply(
          request: (TProtocol, Int),
          service: finagle$Service[GetCommonAncestorForModels.Args, GetCommonAncestorForModels.SuccessType]
        ): Future[RichResponse[GetCommonAncestorForModels.Args, GetCommonAncestorForModels.Result]] = {
          val iprot = request._1
          val seqid = request._2
          val args = GetCommonAncestorForModels.Args.decode(iprot)
          iprot.readMessageEnd()
          val res = service(args)
          res.transform {
            case _root_.com.twitter.util.Return(value) =>
              val methodResult = GetCommonAncestorForModels.Result(success = Some(value))
              Future.value(
                SuccessfulResponse(
                  args,
                  reply("getCommonAncestorForModels", seqid, methodResult),
                  methodResult))
            case _root_.com.twitter.util.Throw(e: modeldb.ResourceNotFoundException) => {
              Future.value(
                ThriftExceptionResponse(
                  args,
                  reply("getCommonAncestorForModels", seqid, GetCommonAncestorForModels.Result(rnfEx = Some(e))),
                  e))
            }
            case _root_.com.twitter.util.Throw(e: modeldb.ServerLogicException) => {
              Future.value(
                ThriftExceptionResponse(
                  args,
                  reply("getCommonAncestorForModels", seqid, GetCommonAncestorForModels.Result(svEx = Some(e))),
                  e))
            }
            case t @ _root_.com.twitter.util.Throw(_) =>
              Future.const(t.cast[RichResponse[GetCommonAncestorForModels.Args, GetCommonAncestorForModels.Result]])
          }
        }
      }
    
      statsFilter.andThen(protocolExnFilter).andThen(serdeFilter)
    }
    val getTrainingRowsCount: finagle$Filter[(TProtocol, Int), Array[Byte], GetTrainingRowsCount.Args, GetTrainingRowsCount.SuccessType] = {
      val statsFilter: finagle$Filter[(TProtocol, Int), Array[Byte], (TProtocol, Int), RichResponse[GetTrainingRowsCount.Args, GetTrainingRowsCount.Result]] = perMethodStatsFilter(GetTrainingRowsCount)
    
      val protocolExnFilter = new SimpleFilter[(TProtocol, Int), RichResponse[GetTrainingRowsCount.Args, GetTrainingRowsCount.Result]] {
        def apply(
          request: (TProtocol, Int),
          service: finagle$Service[(TProtocol, Int), RichResponse[GetTrainingRowsCount.Args, GetTrainingRowsCount.Result]]
        ): Future[RichResponse[GetTrainingRowsCount.Args, GetTrainingRowsCount.Result]] = {
          val iprot = request._1
          val seqid = request._2
          val res = service(request)
          res.transform {
            case _root_.com.twitter.util.Throw(e: TProtocolException) =>
              iprot.readMessageEnd()
              Future.value(
                ProtocolExceptionResponse(
                  null,
                  exception("getTrainingRowsCount", seqid, TApplicationException.PROTOCOL_ERROR, e.getMessage),
                  new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage)))
            case _ =>
              res
          }
        }
      }
    
      val serdeFilter = new finagle$Filter[(TProtocol, Int), RichResponse[GetTrainingRowsCount.Args, GetTrainingRowsCount.Result], GetTrainingRowsCount.Args, GetTrainingRowsCount.SuccessType] {
        def apply(
          request: (TProtocol, Int),
          service: finagle$Service[GetTrainingRowsCount.Args, GetTrainingRowsCount.SuccessType]
        ): Future[RichResponse[GetTrainingRowsCount.Args, GetTrainingRowsCount.Result]] = {
          val iprot = request._1
          val seqid = request._2
          val args = GetTrainingRowsCount.Args.decode(iprot)
          iprot.readMessageEnd()
          val res = service(args)
          res.transform {
            case _root_.com.twitter.util.Return(value) =>
              val methodResult = GetTrainingRowsCount.Result(success = Some(value))
              Future.value(
                SuccessfulResponse(
                  args,
                  reply("getTrainingRowsCount", seqid, methodResult),
                  methodResult))
            case _root_.com.twitter.util.Throw(e: modeldb.ResourceNotFoundException) => {
              Future.value(
                ThriftExceptionResponse(
                  args,
                  reply("getTrainingRowsCount", seqid, GetTrainingRowsCount.Result(rnfEx = Some(e))),
                  e))
            }
            case _root_.com.twitter.util.Throw(e: modeldb.ServerLogicException) => {
              Future.value(
                ThriftExceptionResponse(
                  args,
                  reply("getTrainingRowsCount", seqid, GetTrainingRowsCount.Result(svEx = Some(e))),
                  e))
            }
            case t @ _root_.com.twitter.util.Throw(_) =>
              Future.const(t.cast[RichResponse[GetTrainingRowsCount.Args, GetTrainingRowsCount.Result]])
          }
        }
      }
    
      statsFilter.andThen(protocolExnFilter).andThen(serdeFilter)
    }
    val getTrainingRowsCounts: finagle$Filter[(TProtocol, Int), Array[Byte], GetTrainingRowsCounts.Args, GetTrainingRowsCounts.SuccessType] = {
      val statsFilter: finagle$Filter[(TProtocol, Int), Array[Byte], (TProtocol, Int), RichResponse[GetTrainingRowsCounts.Args, GetTrainingRowsCounts.Result]] = perMethodStatsFilter(GetTrainingRowsCounts)
    
      val protocolExnFilter = new SimpleFilter[(TProtocol, Int), RichResponse[GetTrainingRowsCounts.Args, GetTrainingRowsCounts.Result]] {
        def apply(
          request: (TProtocol, Int),
          service: finagle$Service[(TProtocol, Int), RichResponse[GetTrainingRowsCounts.Args, GetTrainingRowsCounts.Result]]
        ): Future[RichResponse[GetTrainingRowsCounts.Args, GetTrainingRowsCounts.Result]] = {
          val iprot = request._1
          val seqid = request._2
          val res = service(request)
          res.transform {
            case _root_.com.twitter.util.Throw(e: TProtocolException) =>
              iprot.readMessageEnd()
              Future.value(
                ProtocolExceptionResponse(
                  null,
                  exception("getTrainingRowsCounts", seqid, TApplicationException.PROTOCOL_ERROR, e.getMessage),
                  new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage)))
            case _ =>
              res
          }
        }
      }
    
      val serdeFilter = new finagle$Filter[(TProtocol, Int), RichResponse[GetTrainingRowsCounts.Args, GetTrainingRowsCounts.Result], GetTrainingRowsCounts.Args, GetTrainingRowsCounts.SuccessType] {
        def apply(
          request: (TProtocol, Int),
          service: finagle$Service[GetTrainingRowsCounts.Args, GetTrainingRowsCounts.SuccessType]
        ): Future[RichResponse[GetTrainingRowsCounts.Args, GetTrainingRowsCounts.Result]] = {
          val iprot = request._1
          val seqid = request._2
          val args = GetTrainingRowsCounts.Args.decode(iprot)
          iprot.readMessageEnd()
          val res = service(args)
          res.transform {
            case _root_.com.twitter.util.Return(value) =>
              val methodResult = GetTrainingRowsCounts.Result(success = Some(value))
              Future.value(
                SuccessfulResponse(
                  args,
                  reply("getTrainingRowsCounts", seqid, methodResult),
                  methodResult))
            case _root_.com.twitter.util.Throw(e: modeldb.ServerLogicException) => {
              Future.value(
                ThriftExceptionResponse(
                  args,
                  reply("getTrainingRowsCounts", seqid, GetTrainingRowsCounts.Result(svEx = Some(e))),
                  e))
            }
            case t @ _root_.com.twitter.util.Throw(_) =>
              Future.const(t.cast[RichResponse[GetTrainingRowsCounts.Args, GetTrainingRowsCounts.Result]])
          }
        }
      }
    
      statsFilter.andThen(protocolExnFilter).andThen(serdeFilter)
    }
    val compareHyperparameters: finagle$Filter[(TProtocol, Int), Array[Byte], CompareHyperparameters.Args, CompareHyperparameters.SuccessType] = {
      val statsFilter: finagle$Filter[(TProtocol, Int), Array[Byte], (TProtocol, Int), RichResponse[CompareHyperparameters.Args, CompareHyperparameters.Result]] = perMethodStatsFilter(CompareHyperparameters)
    
      val protocolExnFilter = new SimpleFilter[(TProtocol, Int), RichResponse[CompareHyperparameters.Args, CompareHyperparameters.Result]] {
        def apply(
          request: (TProtocol, Int),
          service: finagle$Service[(TProtocol, Int), RichResponse[CompareHyperparameters.Args, CompareHyperparameters.Result]]
        ): Future[RichResponse[CompareHyperparameters.Args, CompareHyperparameters.Result]] = {
          val iprot = request._1
          val seqid = request._2
          val res = service(request)
          res.transform {
            case _root_.com.twitter.util.Throw(e: TProtocolException) =>
              iprot.readMessageEnd()
              Future.value(
                ProtocolExceptionResponse(
                  null,
                  exception("compareHyperparameters", seqid, TApplicationException.PROTOCOL_ERROR, e.getMessage),
                  new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage)))
            case _ =>
              res
          }
        }
      }
    
      val serdeFilter = new finagle$Filter[(TProtocol, Int), RichResponse[CompareHyperparameters.Args, CompareHyperparameters.Result], CompareHyperparameters.Args, CompareHyperparameters.SuccessType] {
        def apply(
          request: (TProtocol, Int),
          service: finagle$Service[CompareHyperparameters.Args, CompareHyperparameters.SuccessType]
        ): Future[RichResponse[CompareHyperparameters.Args, CompareHyperparameters.Result]] = {
          val iprot = request._1
          val seqid = request._2
          val args = CompareHyperparameters.Args.decode(iprot)
          iprot.readMessageEnd()
          val res = service(args)
          res.transform {
            case _root_.com.twitter.util.Return(value) =>
              val methodResult = CompareHyperparameters.Result(success = Some(value))
              Future.value(
                SuccessfulResponse(
                  args,
                  reply("compareHyperparameters", seqid, methodResult),
                  methodResult))
            case _root_.com.twitter.util.Throw(e: modeldb.ResourceNotFoundException) => {
              Future.value(
                ThriftExceptionResponse(
                  args,
                  reply("compareHyperparameters", seqid, CompareHyperparameters.Result(rnfEx = Some(e))),
                  e))
            }
            case _root_.com.twitter.util.Throw(e: modeldb.ServerLogicException) => {
              Future.value(
                ThriftExceptionResponse(
                  args,
                  reply("compareHyperparameters", seqid, CompareHyperparameters.Result(svEx = Some(e))),
                  e))
            }
            case t @ _root_.com.twitter.util.Throw(_) =>
              Future.const(t.cast[RichResponse[CompareHyperparameters.Args, CompareHyperparameters.Result]])
          }
        }
      }
    
      statsFilter.andThen(protocolExnFilter).andThen(serdeFilter)
    }
    val compareFeatures: finagle$Filter[(TProtocol, Int), Array[Byte], CompareFeatures.Args, CompareFeatures.SuccessType] = {
      val statsFilter: finagle$Filter[(TProtocol, Int), Array[Byte], (TProtocol, Int), RichResponse[CompareFeatures.Args, CompareFeatures.Result]] = perMethodStatsFilter(CompareFeatures)
    
      val protocolExnFilter = new SimpleFilter[(TProtocol, Int), RichResponse[CompareFeatures.Args, CompareFeatures.Result]] {
        def apply(
          request: (TProtocol, Int),
          service: finagle$Service[(TProtocol, Int), RichResponse[CompareFeatures.Args, CompareFeatures.Result]]
        ): Future[RichResponse[CompareFeatures.Args, CompareFeatures.Result]] = {
          val iprot = request._1
          val seqid = request._2
          val res = service(request)
          res.transform {
            case _root_.com.twitter.util.Throw(e: TProtocolException) =>
              iprot.readMessageEnd()
              Future.value(
                ProtocolExceptionResponse(
                  null,
                  exception("compareFeatures", seqid, TApplicationException.PROTOCOL_ERROR, e.getMessage),
                  new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage)))
            case _ =>
              res
          }
        }
      }
    
      val serdeFilter = new finagle$Filter[(TProtocol, Int), RichResponse[CompareFeatures.Args, CompareFeatures.Result], CompareFeatures.Args, CompareFeatures.SuccessType] {
        def apply(
          request: (TProtocol, Int),
          service: finagle$Service[CompareFeatures.Args, CompareFeatures.SuccessType]
        ): Future[RichResponse[CompareFeatures.Args, CompareFeatures.Result]] = {
          val iprot = request._1
          val seqid = request._2
          val args = CompareFeatures.Args.decode(iprot)
          iprot.readMessageEnd()
          val res = service(args)
          res.transform {
            case _root_.com.twitter.util.Return(value) =>
              val methodResult = CompareFeatures.Result(success = Some(value))
              Future.value(
                SuccessfulResponse(
                  args,
                  reply("compareFeatures", seqid, methodResult),
                  methodResult))
            case _root_.com.twitter.util.Throw(e: modeldb.ResourceNotFoundException) => {
              Future.value(
                ThriftExceptionResponse(
                  args,
                  reply("compareFeatures", seqid, CompareFeatures.Result(rnfEx = Some(e))),
                  e))
            }
            case _root_.com.twitter.util.Throw(e: modeldb.ServerLogicException) => {
              Future.value(
                ThriftExceptionResponse(
                  args,
                  reply("compareFeatures", seqid, CompareFeatures.Result(svEx = Some(e))),
                  e))
            }
            case t @ _root_.com.twitter.util.Throw(_) =>
              Future.const(t.cast[RichResponse[CompareFeatures.Args, CompareFeatures.Result]])
          }
        }
      }
    
      statsFilter.andThen(protocolExnFilter).andThen(serdeFilter)
    }
    val groupByProblemType: finagle$Filter[(TProtocol, Int), Array[Byte], GroupByProblemType.Args, GroupByProblemType.SuccessType] = {
      val statsFilter: finagle$Filter[(TProtocol, Int), Array[Byte], (TProtocol, Int), RichResponse[GroupByProblemType.Args, GroupByProblemType.Result]] = perMethodStatsFilter(GroupByProblemType)
    
      val protocolExnFilter = new SimpleFilter[(TProtocol, Int), RichResponse[GroupByProblemType.Args, GroupByProblemType.Result]] {
        def apply(
          request: (TProtocol, Int),
          service: finagle$Service[(TProtocol, Int), RichResponse[GroupByProblemType.Args, GroupByProblemType.Result]]
        ): Future[RichResponse[GroupByProblemType.Args, GroupByProblemType.Result]] = {
          val iprot = request._1
          val seqid = request._2
          val res = service(request)
          res.transform {
            case _root_.com.twitter.util.Throw(e: TProtocolException) =>
              iprot.readMessageEnd()
              Future.value(
                ProtocolExceptionResponse(
                  null,
                  exception("groupByProblemType", seqid, TApplicationException.PROTOCOL_ERROR, e.getMessage),
                  new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage)))
            case _ =>
              res
          }
        }
      }
    
      val serdeFilter = new finagle$Filter[(TProtocol, Int), RichResponse[GroupByProblemType.Args, GroupByProblemType.Result], GroupByProblemType.Args, GroupByProblemType.SuccessType] {
        def apply(
          request: (TProtocol, Int),
          service: finagle$Service[GroupByProblemType.Args, GroupByProblemType.SuccessType]
        ): Future[RichResponse[GroupByProblemType.Args, GroupByProblemType.Result]] = {
          val iprot = request._1
          val seqid = request._2
          val args = GroupByProblemType.Args.decode(iprot)
          iprot.readMessageEnd()
          val res = service(args)
          res.transform {
            case _root_.com.twitter.util.Return(value) =>
              val methodResult = GroupByProblemType.Result(success = Some(value))
              Future.value(
                SuccessfulResponse(
                  args,
                  reply("groupByProblemType", seqid, methodResult),
                  methodResult))
            case _root_.com.twitter.util.Throw(e: modeldb.ServerLogicException) => {
              Future.value(
                ThriftExceptionResponse(
                  args,
                  reply("groupByProblemType", seqid, GroupByProblemType.Result(svEx = Some(e))),
                  e))
            }
            case t @ _root_.com.twitter.util.Throw(_) =>
              Future.const(t.cast[RichResponse[GroupByProblemType.Args, GroupByProblemType.Result]])
          }
        }
      }
    
      statsFilter.andThen(protocolExnFilter).andThen(serdeFilter)
    }
    val similarModels: finagle$Filter[(TProtocol, Int), Array[Byte], SimilarModels.Args, SimilarModels.SuccessType] = {
      val statsFilter: finagle$Filter[(TProtocol, Int), Array[Byte], (TProtocol, Int), RichResponse[SimilarModels.Args, SimilarModels.Result]] = perMethodStatsFilter(SimilarModels)
    
      val protocolExnFilter = new SimpleFilter[(TProtocol, Int), RichResponse[SimilarModels.Args, SimilarModels.Result]] {
        def apply(
          request: (TProtocol, Int),
          service: finagle$Service[(TProtocol, Int), RichResponse[SimilarModels.Args, SimilarModels.Result]]
        ): Future[RichResponse[SimilarModels.Args, SimilarModels.Result]] = {
          val iprot = request._1
          val seqid = request._2
          val res = service(request)
          res.transform {
            case _root_.com.twitter.util.Throw(e: TProtocolException) =>
              iprot.readMessageEnd()
              Future.value(
                ProtocolExceptionResponse(
                  null,
                  exception("similarModels", seqid, TApplicationException.PROTOCOL_ERROR, e.getMessage),
                  new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage)))
            case _ =>
              res
          }
        }
      }
    
      val serdeFilter = new finagle$Filter[(TProtocol, Int), RichResponse[SimilarModels.Args, SimilarModels.Result], SimilarModels.Args, SimilarModels.SuccessType] {
        def apply(
          request: (TProtocol, Int),
          service: finagle$Service[SimilarModels.Args, SimilarModels.SuccessType]
        ): Future[RichResponse[SimilarModels.Args, SimilarModels.Result]] = {
          val iprot = request._1
          val seqid = request._2
          val args = SimilarModels.Args.decode(iprot)
          iprot.readMessageEnd()
          val res = service(args)
          res.transform {
            case _root_.com.twitter.util.Return(value) =>
              val methodResult = SimilarModels.Result(success = Some(value))
              Future.value(
                SuccessfulResponse(
                  args,
                  reply("similarModels", seqid, methodResult),
                  methodResult))
            case _root_.com.twitter.util.Throw(e: modeldb.ResourceNotFoundException) => {
              Future.value(
                ThriftExceptionResponse(
                  args,
                  reply("similarModels", seqid, SimilarModels.Result(rnfEx = Some(e))),
                  e))
            }
            case _root_.com.twitter.util.Throw(e: modeldb.BadRequestException) => {
              Future.value(
                ThriftExceptionResponse(
                  args,
                  reply("similarModels", seqid, SimilarModels.Result(brEx = Some(e))),
                  e))
            }
            case _root_.com.twitter.util.Throw(e: modeldb.ServerLogicException) => {
              Future.value(
                ThriftExceptionResponse(
                  args,
                  reply("similarModels", seqid, SimilarModels.Result(svEx = Some(e))),
                  e))
            }
            case t @ _root_.com.twitter.util.Throw(_) =>
              Future.const(t.cast[RichResponse[SimilarModels.Args, SimilarModels.Result]])
          }
        }
      }
    
      statsFilter.andThen(protocolExnFilter).andThen(serdeFilter)
    }
    val linearModelFeatureImportances: finagle$Filter[(TProtocol, Int), Array[Byte], LinearModelFeatureImportances.Args, LinearModelFeatureImportances.SuccessType] = {
      val statsFilter: finagle$Filter[(TProtocol, Int), Array[Byte], (TProtocol, Int), RichResponse[LinearModelFeatureImportances.Args, LinearModelFeatureImportances.Result]] = perMethodStatsFilter(LinearModelFeatureImportances)
    
      val protocolExnFilter = new SimpleFilter[(TProtocol, Int), RichResponse[LinearModelFeatureImportances.Args, LinearModelFeatureImportances.Result]] {
        def apply(
          request: (TProtocol, Int),
          service: finagle$Service[(TProtocol, Int), RichResponse[LinearModelFeatureImportances.Args, LinearModelFeatureImportances.Result]]
        ): Future[RichResponse[LinearModelFeatureImportances.Args, LinearModelFeatureImportances.Result]] = {
          val iprot = request._1
          val seqid = request._2
          val res = service(request)
          res.transform {
            case _root_.com.twitter.util.Throw(e: TProtocolException) =>
              iprot.readMessageEnd()
              Future.value(
                ProtocolExceptionResponse(
                  null,
                  exception("linearModelFeatureImportances", seqid, TApplicationException.PROTOCOL_ERROR, e.getMessage),
                  new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage)))
            case _ =>
              res
          }
        }
      }
    
      val serdeFilter = new finagle$Filter[(TProtocol, Int), RichResponse[LinearModelFeatureImportances.Args, LinearModelFeatureImportances.Result], LinearModelFeatureImportances.Args, LinearModelFeatureImportances.SuccessType] {
        def apply(
          request: (TProtocol, Int),
          service: finagle$Service[LinearModelFeatureImportances.Args, LinearModelFeatureImportances.SuccessType]
        ): Future[RichResponse[LinearModelFeatureImportances.Args, LinearModelFeatureImportances.Result]] = {
          val iprot = request._1
          val seqid = request._2
          val args = LinearModelFeatureImportances.Args.decode(iprot)
          iprot.readMessageEnd()
          val res = service(args)
          res.transform {
            case _root_.com.twitter.util.Return(value) =>
              val methodResult = LinearModelFeatureImportances.Result(success = Some(value))
              Future.value(
                SuccessfulResponse(
                  args,
                  reply("linearModelFeatureImportances", seqid, methodResult),
                  methodResult))
            case _root_.com.twitter.util.Throw(e: modeldb.ResourceNotFoundException) => {
              Future.value(
                ThriftExceptionResponse(
                  args,
                  reply("linearModelFeatureImportances", seqid, LinearModelFeatureImportances.Result(rnfEx = Some(e))),
                  e))
            }
            case _root_.com.twitter.util.Throw(e: modeldb.IllegalOperationException) => {
              Future.value(
                ThriftExceptionResponse(
                  args,
                  reply("linearModelFeatureImportances", seqid, LinearModelFeatureImportances.Result(ioEx = Some(e))),
                  e))
            }
            case _root_.com.twitter.util.Throw(e: modeldb.ServerLogicException) => {
              Future.value(
                ThriftExceptionResponse(
                  args,
                  reply("linearModelFeatureImportances", seqid, LinearModelFeatureImportances.Result(svEx = Some(e))),
                  e))
            }
            case t @ _root_.com.twitter.util.Throw(_) =>
              Future.const(t.cast[RichResponse[LinearModelFeatureImportances.Args, LinearModelFeatureImportances.Result]])
          }
        }
      }
    
      statsFilter.andThen(protocolExnFilter).andThen(serdeFilter)
    }
    val compareLinearModelFeatureImportances: finagle$Filter[(TProtocol, Int), Array[Byte], CompareLinearModelFeatureImportances.Args, CompareLinearModelFeatureImportances.SuccessType] = {
      val statsFilter: finagle$Filter[(TProtocol, Int), Array[Byte], (TProtocol, Int), RichResponse[CompareLinearModelFeatureImportances.Args, CompareLinearModelFeatureImportances.Result]] = perMethodStatsFilter(CompareLinearModelFeatureImportances)
    
      val protocolExnFilter = new SimpleFilter[(TProtocol, Int), RichResponse[CompareLinearModelFeatureImportances.Args, CompareLinearModelFeatureImportances.Result]] {
        def apply(
          request: (TProtocol, Int),
          service: finagle$Service[(TProtocol, Int), RichResponse[CompareLinearModelFeatureImportances.Args, CompareLinearModelFeatureImportances.Result]]
        ): Future[RichResponse[CompareLinearModelFeatureImportances.Args, CompareLinearModelFeatureImportances.Result]] = {
          val iprot = request._1
          val seqid = request._2
          val res = service(request)
          res.transform {
            case _root_.com.twitter.util.Throw(e: TProtocolException) =>
              iprot.readMessageEnd()
              Future.value(
                ProtocolExceptionResponse(
                  null,
                  exception("compareLinearModelFeatureImportances", seqid, TApplicationException.PROTOCOL_ERROR, e.getMessage),
                  new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage)))
            case _ =>
              res
          }
        }
      }
    
      val serdeFilter = new finagle$Filter[(TProtocol, Int), RichResponse[CompareLinearModelFeatureImportances.Args, CompareLinearModelFeatureImportances.Result], CompareLinearModelFeatureImportances.Args, CompareLinearModelFeatureImportances.SuccessType] {
        def apply(
          request: (TProtocol, Int),
          service: finagle$Service[CompareLinearModelFeatureImportances.Args, CompareLinearModelFeatureImportances.SuccessType]
        ): Future[RichResponse[CompareLinearModelFeatureImportances.Args, CompareLinearModelFeatureImportances.Result]] = {
          val iprot = request._1
          val seqid = request._2
          val args = CompareLinearModelFeatureImportances.Args.decode(iprot)
          iprot.readMessageEnd()
          val res = service(args)
          res.transform {
            case _root_.com.twitter.util.Return(value) =>
              val methodResult = CompareLinearModelFeatureImportances.Result(success = Some(value))
              Future.value(
                SuccessfulResponse(
                  args,
                  reply("compareLinearModelFeatureImportances", seqid, methodResult),
                  methodResult))
            case _root_.com.twitter.util.Throw(e: modeldb.ResourceNotFoundException) => {
              Future.value(
                ThriftExceptionResponse(
                  args,
                  reply("compareLinearModelFeatureImportances", seqid, CompareLinearModelFeatureImportances.Result(rnfEx = Some(e))),
                  e))
            }
            case _root_.com.twitter.util.Throw(e: modeldb.IllegalOperationException) => {
              Future.value(
                ThriftExceptionResponse(
                  args,
                  reply("compareLinearModelFeatureImportances", seqid, CompareLinearModelFeatureImportances.Result(ioEx = Some(e))),
                  e))
            }
            case _root_.com.twitter.util.Throw(e: modeldb.ServerLogicException) => {
              Future.value(
                ThriftExceptionResponse(
                  args,
                  reply("compareLinearModelFeatureImportances", seqid, CompareLinearModelFeatureImportances.Result(svEx = Some(e))),
                  e))
            }
            case t @ _root_.com.twitter.util.Throw(_) =>
              Future.const(t.cast[RichResponse[CompareLinearModelFeatureImportances.Args, CompareLinearModelFeatureImportances.Result]])
          }
        }
      }
    
      statsFilter.andThen(protocolExnFilter).andThen(serdeFilter)
    }
    val iterationsUntilConvergence: finagle$Filter[(TProtocol, Int), Array[Byte], IterationsUntilConvergence.Args, IterationsUntilConvergence.SuccessType] = {
      val statsFilter: finagle$Filter[(TProtocol, Int), Array[Byte], (TProtocol, Int), RichResponse[IterationsUntilConvergence.Args, IterationsUntilConvergence.Result]] = perMethodStatsFilter(IterationsUntilConvergence)
    
      val protocolExnFilter = new SimpleFilter[(TProtocol, Int), RichResponse[IterationsUntilConvergence.Args, IterationsUntilConvergence.Result]] {
        def apply(
          request: (TProtocol, Int),
          service: finagle$Service[(TProtocol, Int), RichResponse[IterationsUntilConvergence.Args, IterationsUntilConvergence.Result]]
        ): Future[RichResponse[IterationsUntilConvergence.Args, IterationsUntilConvergence.Result]] = {
          val iprot = request._1
          val seqid = request._2
          val res = service(request)
          res.transform {
            case _root_.com.twitter.util.Throw(e: TProtocolException) =>
              iprot.readMessageEnd()
              Future.value(
                ProtocolExceptionResponse(
                  null,
                  exception("iterationsUntilConvergence", seqid, TApplicationException.PROTOCOL_ERROR, e.getMessage),
                  new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage)))
            case _ =>
              res
          }
        }
      }
    
      val serdeFilter = new finagle$Filter[(TProtocol, Int), RichResponse[IterationsUntilConvergence.Args, IterationsUntilConvergence.Result], IterationsUntilConvergence.Args, IterationsUntilConvergence.SuccessType] {
        def apply(
          request: (TProtocol, Int),
          service: finagle$Service[IterationsUntilConvergence.Args, IterationsUntilConvergence.SuccessType]
        ): Future[RichResponse[IterationsUntilConvergence.Args, IterationsUntilConvergence.Result]] = {
          val iprot = request._1
          val seqid = request._2
          val args = IterationsUntilConvergence.Args.decode(iprot)
          iprot.readMessageEnd()
          val res = service(args)
          res.transform {
            case _root_.com.twitter.util.Return(value) =>
              val methodResult = IterationsUntilConvergence.Result(success = Some(value))
              Future.value(
                SuccessfulResponse(
                  args,
                  reply("iterationsUntilConvergence", seqid, methodResult),
                  methodResult))
            case _root_.com.twitter.util.Throw(e: modeldb.ServerLogicException) => {
              Future.value(
                ThriftExceptionResponse(
                  args,
                  reply("iterationsUntilConvergence", seqid, IterationsUntilConvergence.Result(svEx = Some(e))),
                  e))
            }
            case t @ _root_.com.twitter.util.Throw(_) =>
              Future.const(t.cast[RichResponse[IterationsUntilConvergence.Args, IterationsUntilConvergence.Result]])
          }
        }
      }
    
      statsFilter.andThen(protocolExnFilter).andThen(serdeFilter)
    }
    val rankModels: finagle$Filter[(TProtocol, Int), Array[Byte], RankModels.Args, RankModels.SuccessType] = {
      val statsFilter: finagle$Filter[(TProtocol, Int), Array[Byte], (TProtocol, Int), RichResponse[RankModels.Args, RankModels.Result]] = perMethodStatsFilter(RankModels)
    
      val protocolExnFilter = new SimpleFilter[(TProtocol, Int), RichResponse[RankModels.Args, RankModels.Result]] {
        def apply(
          request: (TProtocol, Int),
          service: finagle$Service[(TProtocol, Int), RichResponse[RankModels.Args, RankModels.Result]]
        ): Future[RichResponse[RankModels.Args, RankModels.Result]] = {
          val iprot = request._1
          val seqid = request._2
          val res = service(request)
          res.transform {
            case _root_.com.twitter.util.Throw(e: TProtocolException) =>
              iprot.readMessageEnd()
              Future.value(
                ProtocolExceptionResponse(
                  null,
                  exception("rankModels", seqid, TApplicationException.PROTOCOL_ERROR, e.getMessage),
                  new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage)))
            case _ =>
              res
          }
        }
      }
    
      val serdeFilter = new finagle$Filter[(TProtocol, Int), RichResponse[RankModels.Args, RankModels.Result], RankModels.Args, RankModels.SuccessType] {
        def apply(
          request: (TProtocol, Int),
          service: finagle$Service[RankModels.Args, RankModels.SuccessType]
        ): Future[RichResponse[RankModels.Args, RankModels.Result]] = {
          val iprot = request._1
          val seqid = request._2
          val args = RankModels.Args.decode(iprot)
          iprot.readMessageEnd()
          val res = service(args)
          res.transform {
            case _root_.com.twitter.util.Return(value) =>
              val methodResult = RankModels.Result(success = Some(value))
              Future.value(
                SuccessfulResponse(
                  args,
                  reply("rankModels", seqid, methodResult),
                  methodResult))
            case _root_.com.twitter.util.Throw(e: modeldb.ServerLogicException) => {
              Future.value(
                ThriftExceptionResponse(
                  args,
                  reply("rankModels", seqid, RankModels.Result(svEx = Some(e))),
                  e))
            }
            case t @ _root_.com.twitter.util.Throw(_) =>
              Future.const(t.cast[RichResponse[RankModels.Args, RankModels.Result]])
          }
        }
      }
    
      statsFilter.andThen(protocolExnFilter).andThen(serdeFilter)
    }
    val confidenceIntervals: finagle$Filter[(TProtocol, Int), Array[Byte], ConfidenceIntervals.Args, ConfidenceIntervals.SuccessType] = {
      val statsFilter: finagle$Filter[(TProtocol, Int), Array[Byte], (TProtocol, Int), RichResponse[ConfidenceIntervals.Args, ConfidenceIntervals.Result]] = perMethodStatsFilter(ConfidenceIntervals)
    
      val protocolExnFilter = new SimpleFilter[(TProtocol, Int), RichResponse[ConfidenceIntervals.Args, ConfidenceIntervals.Result]] {
        def apply(
          request: (TProtocol, Int),
          service: finagle$Service[(TProtocol, Int), RichResponse[ConfidenceIntervals.Args, ConfidenceIntervals.Result]]
        ): Future[RichResponse[ConfidenceIntervals.Args, ConfidenceIntervals.Result]] = {
          val iprot = request._1
          val seqid = request._2
          val res = service(request)
          res.transform {
            case _root_.com.twitter.util.Throw(e: TProtocolException) =>
              iprot.readMessageEnd()
              Future.value(
                ProtocolExceptionResponse(
                  null,
                  exception("confidenceIntervals", seqid, TApplicationException.PROTOCOL_ERROR, e.getMessage),
                  new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage)))
            case _ =>
              res
          }
        }
      }
    
      val serdeFilter = new finagle$Filter[(TProtocol, Int), RichResponse[ConfidenceIntervals.Args, ConfidenceIntervals.Result], ConfidenceIntervals.Args, ConfidenceIntervals.SuccessType] {
        def apply(
          request: (TProtocol, Int),
          service: finagle$Service[ConfidenceIntervals.Args, ConfidenceIntervals.SuccessType]
        ): Future[RichResponse[ConfidenceIntervals.Args, ConfidenceIntervals.Result]] = {
          val iprot = request._1
          val seqid = request._2
          val args = ConfidenceIntervals.Args.decode(iprot)
          iprot.readMessageEnd()
          val res = service(args)
          res.transform {
            case _root_.com.twitter.util.Return(value) =>
              val methodResult = ConfidenceIntervals.Result(success = Some(value))
              Future.value(
                SuccessfulResponse(
                  args,
                  reply("confidenceIntervals", seqid, methodResult),
                  methodResult))
            case _root_.com.twitter.util.Throw(e: modeldb.ResourceNotFoundException) => {
              Future.value(
                ThriftExceptionResponse(
                  args,
                  reply("confidenceIntervals", seqid, ConfidenceIntervals.Result(rnfEx = Some(e))),
                  e))
            }
            case _root_.com.twitter.util.Throw(e: modeldb.IllegalOperationException) => {
              Future.value(
                ThriftExceptionResponse(
                  args,
                  reply("confidenceIntervals", seqid, ConfidenceIntervals.Result(ioEx = Some(e))),
                  e))
            }
            case _root_.com.twitter.util.Throw(e: modeldb.BadRequestException) => {
              Future.value(
                ThriftExceptionResponse(
                  args,
                  reply("confidenceIntervals", seqid, ConfidenceIntervals.Result(brEx = Some(e))),
                  e))
            }
            case _root_.com.twitter.util.Throw(e: modeldb.ServerLogicException) => {
              Future.value(
                ThriftExceptionResponse(
                  args,
                  reply("confidenceIntervals", seqid, ConfidenceIntervals.Result(svEx = Some(e))),
                  e))
            }
            case t @ _root_.com.twitter.util.Throw(_) =>
              Future.const(t.cast[RichResponse[ConfidenceIntervals.Args, ConfidenceIntervals.Result]])
          }
        }
      }
    
      statsFilter.andThen(protocolExnFilter).andThen(serdeFilter)
    }
    val modelsWithFeatures: finagle$Filter[(TProtocol, Int), Array[Byte], ModelsWithFeatures.Args, ModelsWithFeatures.SuccessType] = {
      val statsFilter: finagle$Filter[(TProtocol, Int), Array[Byte], (TProtocol, Int), RichResponse[ModelsWithFeatures.Args, ModelsWithFeatures.Result]] = perMethodStatsFilter(ModelsWithFeatures)
    
      val protocolExnFilter = new SimpleFilter[(TProtocol, Int), RichResponse[ModelsWithFeatures.Args, ModelsWithFeatures.Result]] {
        def apply(
          request: (TProtocol, Int),
          service: finagle$Service[(TProtocol, Int), RichResponse[ModelsWithFeatures.Args, ModelsWithFeatures.Result]]
        ): Future[RichResponse[ModelsWithFeatures.Args, ModelsWithFeatures.Result]] = {
          val iprot = request._1
          val seqid = request._2
          val res = service(request)
          res.transform {
            case _root_.com.twitter.util.Throw(e: TProtocolException) =>
              iprot.readMessageEnd()
              Future.value(
                ProtocolExceptionResponse(
                  null,
                  exception("modelsWithFeatures", seqid, TApplicationException.PROTOCOL_ERROR, e.getMessage),
                  new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage)))
            case _ =>
              res
          }
        }
      }
    
      val serdeFilter = new finagle$Filter[(TProtocol, Int), RichResponse[ModelsWithFeatures.Args, ModelsWithFeatures.Result], ModelsWithFeatures.Args, ModelsWithFeatures.SuccessType] {
        def apply(
          request: (TProtocol, Int),
          service: finagle$Service[ModelsWithFeatures.Args, ModelsWithFeatures.SuccessType]
        ): Future[RichResponse[ModelsWithFeatures.Args, ModelsWithFeatures.Result]] = {
          val iprot = request._1
          val seqid = request._2
          val args = ModelsWithFeatures.Args.decode(iprot)
          iprot.readMessageEnd()
          val res = service(args)
          res.transform {
            case _root_.com.twitter.util.Return(value) =>
              val methodResult = ModelsWithFeatures.Result(success = Some(value))
              Future.value(
                SuccessfulResponse(
                  args,
                  reply("modelsWithFeatures", seqid, methodResult),
                  methodResult))
            case _root_.com.twitter.util.Throw(e: modeldb.ServerLogicException) => {
              Future.value(
                ThriftExceptionResponse(
                  args,
                  reply("modelsWithFeatures", seqid, ModelsWithFeatures.Result(svEx = Some(e))),
                  e))
            }
            case t @ _root_.com.twitter.util.Throw(_) =>
              Future.const(t.cast[RichResponse[ModelsWithFeatures.Args, ModelsWithFeatures.Result]])
          }
        }
      }
    
      statsFilter.andThen(protocolExnFilter).andThen(serdeFilter)
    }
    val modelsDerivedFromDataFrame: finagle$Filter[(TProtocol, Int), Array[Byte], ModelsDerivedFromDataFrame.Args, ModelsDerivedFromDataFrame.SuccessType] = {
      val statsFilter: finagle$Filter[(TProtocol, Int), Array[Byte], (TProtocol, Int), RichResponse[ModelsDerivedFromDataFrame.Args, ModelsDerivedFromDataFrame.Result]] = perMethodStatsFilter(ModelsDerivedFromDataFrame)
    
      val protocolExnFilter = new SimpleFilter[(TProtocol, Int), RichResponse[ModelsDerivedFromDataFrame.Args, ModelsDerivedFromDataFrame.Result]] {
        def apply(
          request: (TProtocol, Int),
          service: finagle$Service[(TProtocol, Int), RichResponse[ModelsDerivedFromDataFrame.Args, ModelsDerivedFromDataFrame.Result]]
        ): Future[RichResponse[ModelsDerivedFromDataFrame.Args, ModelsDerivedFromDataFrame.Result]] = {
          val iprot = request._1
          val seqid = request._2
          val res = service(request)
          res.transform {
            case _root_.com.twitter.util.Throw(e: TProtocolException) =>
              iprot.readMessageEnd()
              Future.value(
                ProtocolExceptionResponse(
                  null,
                  exception("modelsDerivedFromDataFrame", seqid, TApplicationException.PROTOCOL_ERROR, e.getMessage),
                  new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage)))
            case _ =>
              res
          }
        }
      }
    
      val serdeFilter = new finagle$Filter[(TProtocol, Int), RichResponse[ModelsDerivedFromDataFrame.Args, ModelsDerivedFromDataFrame.Result], ModelsDerivedFromDataFrame.Args, ModelsDerivedFromDataFrame.SuccessType] {
        def apply(
          request: (TProtocol, Int),
          service: finagle$Service[ModelsDerivedFromDataFrame.Args, ModelsDerivedFromDataFrame.SuccessType]
        ): Future[RichResponse[ModelsDerivedFromDataFrame.Args, ModelsDerivedFromDataFrame.Result]] = {
          val iprot = request._1
          val seqid = request._2
          val args = ModelsDerivedFromDataFrame.Args.decode(iprot)
          iprot.readMessageEnd()
          val res = service(args)
          res.transform {
            case _root_.com.twitter.util.Return(value) =>
              val methodResult = ModelsDerivedFromDataFrame.Result(success = Some(value))
              Future.value(
                SuccessfulResponse(
                  args,
                  reply("modelsDerivedFromDataFrame", seqid, methodResult),
                  methodResult))
            case _root_.com.twitter.util.Throw(e: modeldb.ResourceNotFoundException) => {
              Future.value(
                ThriftExceptionResponse(
                  args,
                  reply("modelsDerivedFromDataFrame", seqid, ModelsDerivedFromDataFrame.Result(rnfEx = Some(e))),
                  e))
            }
            case _root_.com.twitter.util.Throw(e: modeldb.ServerLogicException) => {
              Future.value(
                ThriftExceptionResponse(
                  args,
                  reply("modelsDerivedFromDataFrame", seqid, ModelsDerivedFromDataFrame.Result(svEx = Some(e))),
                  e))
            }
            case t @ _root_.com.twitter.util.Throw(_) =>
              Future.const(t.cast[RichResponse[ModelsDerivedFromDataFrame.Args, ModelsDerivedFromDataFrame.Result]])
          }
        }
      }
    
      statsFilter.andThen(protocolExnFilter).andThen(serdeFilter)
    }
    val getProjectIds: finagle$Filter[(TProtocol, Int), Array[Byte], GetProjectIds.Args, GetProjectIds.SuccessType] = {
      val statsFilter: finagle$Filter[(TProtocol, Int), Array[Byte], (TProtocol, Int), RichResponse[GetProjectIds.Args, GetProjectIds.Result]] = perMethodStatsFilter(GetProjectIds)
    
      val protocolExnFilter = new SimpleFilter[(TProtocol, Int), RichResponse[GetProjectIds.Args, GetProjectIds.Result]] {
        def apply(
          request: (TProtocol, Int),
          service: finagle$Service[(TProtocol, Int), RichResponse[GetProjectIds.Args, GetProjectIds.Result]]
        ): Future[RichResponse[GetProjectIds.Args, GetProjectIds.Result]] = {
          val iprot = request._1
          val seqid = request._2
          val res = service(request)
          res.transform {
            case _root_.com.twitter.util.Throw(e: TProtocolException) =>
              iprot.readMessageEnd()
              Future.value(
                ProtocolExceptionResponse(
                  null,
                  exception("getProjectIds", seqid, TApplicationException.PROTOCOL_ERROR, e.getMessage),
                  new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage)))
            case _ =>
              res
          }
        }
      }
    
      val serdeFilter = new finagle$Filter[(TProtocol, Int), RichResponse[GetProjectIds.Args, GetProjectIds.Result], GetProjectIds.Args, GetProjectIds.SuccessType] {
        def apply(
          request: (TProtocol, Int),
          service: finagle$Service[GetProjectIds.Args, GetProjectIds.SuccessType]
        ): Future[RichResponse[GetProjectIds.Args, GetProjectIds.Result]] = {
          val iprot = request._1
          val seqid = request._2
          val args = GetProjectIds.Args.decode(iprot)
          iprot.readMessageEnd()
          val res = service(args)
          res.transform {
            case _root_.com.twitter.util.Return(value) =>
              val methodResult = GetProjectIds.Result(success = Some(value))
              Future.value(
                SuccessfulResponse(
                  args,
                  reply("getProjectIds", seqid, methodResult),
                  methodResult))
            case _root_.com.twitter.util.Throw(e: modeldb.ServerLogicException) => {
              Future.value(
                ThriftExceptionResponse(
                  args,
                  reply("getProjectIds", seqid, GetProjectIds.Result(svEx = Some(e))),
                  e))
            }
            case t @ _root_.com.twitter.util.Throw(_) =>
              Future.const(t.cast[RichResponse[GetProjectIds.Args, GetProjectIds.Result]])
          }
        }
      }
    
      statsFilter.andThen(protocolExnFilter).andThen(serdeFilter)
    }
    val getModelIds: finagle$Filter[(TProtocol, Int), Array[Byte], GetModelIds.Args, GetModelIds.SuccessType] = {
      val statsFilter: finagle$Filter[(TProtocol, Int), Array[Byte], (TProtocol, Int), RichResponse[GetModelIds.Args, GetModelIds.Result]] = perMethodStatsFilter(GetModelIds)
    
      val protocolExnFilter = new SimpleFilter[(TProtocol, Int), RichResponse[GetModelIds.Args, GetModelIds.Result]] {
        def apply(
          request: (TProtocol, Int),
          service: finagle$Service[(TProtocol, Int), RichResponse[GetModelIds.Args, GetModelIds.Result]]
        ): Future[RichResponse[GetModelIds.Args, GetModelIds.Result]] = {
          val iprot = request._1
          val seqid = request._2
          val res = service(request)
          res.transform {
            case _root_.com.twitter.util.Throw(e: TProtocolException) =>
              iprot.readMessageEnd()
              Future.value(
                ProtocolExceptionResponse(
                  null,
                  exception("getModelIds", seqid, TApplicationException.PROTOCOL_ERROR, e.getMessage),
                  new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage)))
            case _ =>
              res
          }
        }
      }
    
      val serdeFilter = new finagle$Filter[(TProtocol, Int), RichResponse[GetModelIds.Args, GetModelIds.Result], GetModelIds.Args, GetModelIds.SuccessType] {
        def apply(
          request: (TProtocol, Int),
          service: finagle$Service[GetModelIds.Args, GetModelIds.SuccessType]
        ): Future[RichResponse[GetModelIds.Args, GetModelIds.Result]] = {
          val iprot = request._1
          val seqid = request._2
          val args = GetModelIds.Args.decode(iprot)
          iprot.readMessageEnd()
          val res = service(args)
          res.transform {
            case _root_.com.twitter.util.Return(value) =>
              val methodResult = GetModelIds.Result(success = Some(value))
              Future.value(
                SuccessfulResponse(
                  args,
                  reply("getModelIds", seqid, methodResult),
                  methodResult))
            case _root_.com.twitter.util.Throw(e: modeldb.ServerLogicException) => {
              Future.value(
                ThriftExceptionResponse(
                  args,
                  reply("getModelIds", seqid, GetModelIds.Result(svEx = Some(e))),
                  e))
            }
            case t @ _root_.com.twitter.util.Throw(_) =>
              Future.const(t.cast[RichResponse[GetModelIds.Args, GetModelIds.Result]])
          }
        }
      }
    
      statsFilter.andThen(protocolExnFilter).andThen(serdeFilter)
    }
    val updateProject: finagle$Filter[(TProtocol, Int), Array[Byte], UpdateProject.Args, UpdateProject.SuccessType] = {
      val statsFilter: finagle$Filter[(TProtocol, Int), Array[Byte], (TProtocol, Int), RichResponse[UpdateProject.Args, UpdateProject.Result]] = perMethodStatsFilter(UpdateProject)
    
      val protocolExnFilter = new SimpleFilter[(TProtocol, Int), RichResponse[UpdateProject.Args, UpdateProject.Result]] {
        def apply(
          request: (TProtocol, Int),
          service: finagle$Service[(TProtocol, Int), RichResponse[UpdateProject.Args, UpdateProject.Result]]
        ): Future[RichResponse[UpdateProject.Args, UpdateProject.Result]] = {
          val iprot = request._1
          val seqid = request._2
          val res = service(request)
          res.transform {
            case _root_.com.twitter.util.Throw(e: TProtocolException) =>
              iprot.readMessageEnd()
              Future.value(
                ProtocolExceptionResponse(
                  null,
                  exception("updateProject", seqid, TApplicationException.PROTOCOL_ERROR, e.getMessage),
                  new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage)))
            case _ =>
              res
          }
        }
      }
    
      val serdeFilter = new finagle$Filter[(TProtocol, Int), RichResponse[UpdateProject.Args, UpdateProject.Result], UpdateProject.Args, UpdateProject.SuccessType] {
        def apply(
          request: (TProtocol, Int),
          service: finagle$Service[UpdateProject.Args, UpdateProject.SuccessType]
        ): Future[RichResponse[UpdateProject.Args, UpdateProject.Result]] = {
          val iprot = request._1
          val seqid = request._2
          val args = UpdateProject.Args.decode(iprot)
          iprot.readMessageEnd()
          val res = service(args)
          res.transform {
            case _root_.com.twitter.util.Return(value) =>
              val methodResult = UpdateProject.Result(success = Some(value))
              Future.value(
                SuccessfulResponse(
                  args,
                  reply("updateProject", seqid, methodResult),
                  methodResult))
            case _root_.com.twitter.util.Throw(e: modeldb.ServerLogicException) => {
              Future.value(
                ThriftExceptionResponse(
                  args,
                  reply("updateProject", seqid, UpdateProject.Result(svEx = Some(e))),
                  e))
            }
            case t @ _root_.com.twitter.util.Throw(_) =>
              Future.const(t.cast[RichResponse[UpdateProject.Args, UpdateProject.Result]])
          }
        }
      }
    
      statsFilter.andThen(protocolExnFilter).andThen(serdeFilter)
    }
    val createOrUpdateScalarField: finagle$Filter[(TProtocol, Int), Array[Byte], CreateOrUpdateScalarField.Args, CreateOrUpdateScalarField.SuccessType] = {
      val statsFilter: finagle$Filter[(TProtocol, Int), Array[Byte], (TProtocol, Int), RichResponse[CreateOrUpdateScalarField.Args, CreateOrUpdateScalarField.Result]] = perMethodStatsFilter(CreateOrUpdateScalarField)
    
      val protocolExnFilter = new SimpleFilter[(TProtocol, Int), RichResponse[CreateOrUpdateScalarField.Args, CreateOrUpdateScalarField.Result]] {
        def apply(
          request: (TProtocol, Int),
          service: finagle$Service[(TProtocol, Int), RichResponse[CreateOrUpdateScalarField.Args, CreateOrUpdateScalarField.Result]]
        ): Future[RichResponse[CreateOrUpdateScalarField.Args, CreateOrUpdateScalarField.Result]] = {
          val iprot = request._1
          val seqid = request._2
          val res = service(request)
          res.transform {
            case _root_.com.twitter.util.Throw(e: TProtocolException) =>
              iprot.readMessageEnd()
              Future.value(
                ProtocolExceptionResponse(
                  null,
                  exception("createOrUpdateScalarField", seqid, TApplicationException.PROTOCOL_ERROR, e.getMessage),
                  new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage)))
            case _ =>
              res
          }
        }
      }
    
      val serdeFilter = new finagle$Filter[(TProtocol, Int), RichResponse[CreateOrUpdateScalarField.Args, CreateOrUpdateScalarField.Result], CreateOrUpdateScalarField.Args, CreateOrUpdateScalarField.SuccessType] {
        def apply(
          request: (TProtocol, Int),
          service: finagle$Service[CreateOrUpdateScalarField.Args, CreateOrUpdateScalarField.SuccessType]
        ): Future[RichResponse[CreateOrUpdateScalarField.Args, CreateOrUpdateScalarField.Result]] = {
          val iprot = request._1
          val seqid = request._2
          val args = CreateOrUpdateScalarField.Args.decode(iprot)
          iprot.readMessageEnd()
          val res = service(args)
          res.transform {
            case _root_.com.twitter.util.Return(value) =>
              val methodResult = CreateOrUpdateScalarField.Result(success = Some(value))
              Future.value(
                SuccessfulResponse(
                  args,
                  reply("createOrUpdateScalarField", seqid, methodResult),
                  methodResult))
            case _root_.com.twitter.util.Throw(e: modeldb.ServerLogicException) => {
              Future.value(
                ThriftExceptionResponse(
                  args,
                  reply("createOrUpdateScalarField", seqid, CreateOrUpdateScalarField.Result(svEx = Some(e))),
                  e))
            }
            case t @ _root_.com.twitter.util.Throw(_) =>
              Future.const(t.cast[RichResponse[CreateOrUpdateScalarField.Args, CreateOrUpdateScalarField.Result]])
          }
        }
      }
    
      statsFilter.andThen(protocolExnFilter).andThen(serdeFilter)
    }
    val createVectorField: finagle$Filter[(TProtocol, Int), Array[Byte], CreateVectorField.Args, CreateVectorField.SuccessType] = {
      val statsFilter: finagle$Filter[(TProtocol, Int), Array[Byte], (TProtocol, Int), RichResponse[CreateVectorField.Args, CreateVectorField.Result]] = perMethodStatsFilter(CreateVectorField)
    
      val protocolExnFilter = new SimpleFilter[(TProtocol, Int), RichResponse[CreateVectorField.Args, CreateVectorField.Result]] {
        def apply(
          request: (TProtocol, Int),
          service: finagle$Service[(TProtocol, Int), RichResponse[CreateVectorField.Args, CreateVectorField.Result]]
        ): Future[RichResponse[CreateVectorField.Args, CreateVectorField.Result]] = {
          val iprot = request._1
          val seqid = request._2
          val res = service(request)
          res.transform {
            case _root_.com.twitter.util.Throw(e: TProtocolException) =>
              iprot.readMessageEnd()
              Future.value(
                ProtocolExceptionResponse(
                  null,
                  exception("createVectorField", seqid, TApplicationException.PROTOCOL_ERROR, e.getMessage),
                  new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage)))
            case _ =>
              res
          }
        }
      }
    
      val serdeFilter = new finagle$Filter[(TProtocol, Int), RichResponse[CreateVectorField.Args, CreateVectorField.Result], CreateVectorField.Args, CreateVectorField.SuccessType] {
        def apply(
          request: (TProtocol, Int),
          service: finagle$Service[CreateVectorField.Args, CreateVectorField.SuccessType]
        ): Future[RichResponse[CreateVectorField.Args, CreateVectorField.Result]] = {
          val iprot = request._1
          val seqid = request._2
          val args = CreateVectorField.Args.decode(iprot)
          iprot.readMessageEnd()
          val res = service(args)
          res.transform {
            case _root_.com.twitter.util.Return(value) =>
              val methodResult = CreateVectorField.Result(success = Some(value))
              Future.value(
                SuccessfulResponse(
                  args,
                  reply("createVectorField", seqid, methodResult),
                  methodResult))
            case _root_.com.twitter.util.Throw(e: modeldb.ServerLogicException) => {
              Future.value(
                ThriftExceptionResponse(
                  args,
                  reply("createVectorField", seqid, CreateVectorField.Result(svEx = Some(e))),
                  e))
            }
            case t @ _root_.com.twitter.util.Throw(_) =>
              Future.const(t.cast[RichResponse[CreateVectorField.Args, CreateVectorField.Result]])
          }
        }
      }
    
      statsFilter.andThen(protocolExnFilter).andThen(serdeFilter)
    }
    val updateVectorField: finagle$Filter[(TProtocol, Int), Array[Byte], UpdateVectorField.Args, UpdateVectorField.SuccessType] = {
      val statsFilter: finagle$Filter[(TProtocol, Int), Array[Byte], (TProtocol, Int), RichResponse[UpdateVectorField.Args, UpdateVectorField.Result]] = perMethodStatsFilter(UpdateVectorField)
    
      val protocolExnFilter = new SimpleFilter[(TProtocol, Int), RichResponse[UpdateVectorField.Args, UpdateVectorField.Result]] {
        def apply(
          request: (TProtocol, Int),
          service: finagle$Service[(TProtocol, Int), RichResponse[UpdateVectorField.Args, UpdateVectorField.Result]]
        ): Future[RichResponse[UpdateVectorField.Args, UpdateVectorField.Result]] = {
          val iprot = request._1
          val seqid = request._2
          val res = service(request)
          res.transform {
            case _root_.com.twitter.util.Throw(e: TProtocolException) =>
              iprot.readMessageEnd()
              Future.value(
                ProtocolExceptionResponse(
                  null,
                  exception("updateVectorField", seqid, TApplicationException.PROTOCOL_ERROR, e.getMessage),
                  new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage)))
            case _ =>
              res
          }
        }
      }
    
      val serdeFilter = new finagle$Filter[(TProtocol, Int), RichResponse[UpdateVectorField.Args, UpdateVectorField.Result], UpdateVectorField.Args, UpdateVectorField.SuccessType] {
        def apply(
          request: (TProtocol, Int),
          service: finagle$Service[UpdateVectorField.Args, UpdateVectorField.SuccessType]
        ): Future[RichResponse[UpdateVectorField.Args, UpdateVectorField.Result]] = {
          val iprot = request._1
          val seqid = request._2
          val args = UpdateVectorField.Args.decode(iprot)
          iprot.readMessageEnd()
          val res = service(args)
          res.transform {
            case _root_.com.twitter.util.Return(value) =>
              val methodResult = UpdateVectorField.Result(success = Some(value))
              Future.value(
                SuccessfulResponse(
                  args,
                  reply("updateVectorField", seqid, methodResult),
                  methodResult))
            case _root_.com.twitter.util.Throw(e: modeldb.ServerLogicException) => {
              Future.value(
                ThriftExceptionResponse(
                  args,
                  reply("updateVectorField", seqid, UpdateVectorField.Result(svEx = Some(e))),
                  e))
            }
            case t @ _root_.com.twitter.util.Throw(_) =>
              Future.const(t.cast[RichResponse[UpdateVectorField.Args, UpdateVectorField.Result]])
          }
        }
      }
    
      statsFilter.andThen(protocolExnFilter).andThen(serdeFilter)
    }
    val appendToVectorField: finagle$Filter[(TProtocol, Int), Array[Byte], AppendToVectorField.Args, AppendToVectorField.SuccessType] = {
      val statsFilter: finagle$Filter[(TProtocol, Int), Array[Byte], (TProtocol, Int), RichResponse[AppendToVectorField.Args, AppendToVectorField.Result]] = perMethodStatsFilter(AppendToVectorField)
    
      val protocolExnFilter = new SimpleFilter[(TProtocol, Int), RichResponse[AppendToVectorField.Args, AppendToVectorField.Result]] {
        def apply(
          request: (TProtocol, Int),
          service: finagle$Service[(TProtocol, Int), RichResponse[AppendToVectorField.Args, AppendToVectorField.Result]]
        ): Future[RichResponse[AppendToVectorField.Args, AppendToVectorField.Result]] = {
          val iprot = request._1
          val seqid = request._2
          val res = service(request)
          res.transform {
            case _root_.com.twitter.util.Throw(e: TProtocolException) =>
              iprot.readMessageEnd()
              Future.value(
                ProtocolExceptionResponse(
                  null,
                  exception("appendToVectorField", seqid, TApplicationException.PROTOCOL_ERROR, e.getMessage),
                  new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage)))
            case _ =>
              res
          }
        }
      }
    
      val serdeFilter = new finagle$Filter[(TProtocol, Int), RichResponse[AppendToVectorField.Args, AppendToVectorField.Result], AppendToVectorField.Args, AppendToVectorField.SuccessType] {
        def apply(
          request: (TProtocol, Int),
          service: finagle$Service[AppendToVectorField.Args, AppendToVectorField.SuccessType]
        ): Future[RichResponse[AppendToVectorField.Args, AppendToVectorField.Result]] = {
          val iprot = request._1
          val seqid = request._2
          val args = AppendToVectorField.Args.decode(iprot)
          iprot.readMessageEnd()
          val res = service(args)
          res.transform {
            case _root_.com.twitter.util.Return(value) =>
              val methodResult = AppendToVectorField.Result(success = Some(value))
              Future.value(
                SuccessfulResponse(
                  args,
                  reply("appendToVectorField", seqid, methodResult),
                  methodResult))
            case _root_.com.twitter.util.Throw(e: modeldb.ServerLogicException) => {
              Future.value(
                ThriftExceptionResponse(
                  args,
                  reply("appendToVectorField", seqid, AppendToVectorField.Result(svEx = Some(e))),
                  e))
            }
            case t @ _root_.com.twitter.util.Throw(_) =>
              Future.const(t.cast[RichResponse[AppendToVectorField.Args, AppendToVectorField.Result]])
          }
        }
      }
    
      statsFilter.andThen(protocolExnFilter).andThen(serdeFilter)
    }
    val getModel: finagle$Filter[(TProtocol, Int), Array[Byte], GetModel.Args, GetModel.SuccessType] = {
      val statsFilter: finagle$Filter[(TProtocol, Int), Array[Byte], (TProtocol, Int), RichResponse[GetModel.Args, GetModel.Result]] = perMethodStatsFilter(GetModel)
    
      val protocolExnFilter = new SimpleFilter[(TProtocol, Int), RichResponse[GetModel.Args, GetModel.Result]] {
        def apply(
          request: (TProtocol, Int),
          service: finagle$Service[(TProtocol, Int), RichResponse[GetModel.Args, GetModel.Result]]
        ): Future[RichResponse[GetModel.Args, GetModel.Result]] = {
          val iprot = request._1
          val seqid = request._2
          val res = service(request)
          res.transform {
            case _root_.com.twitter.util.Throw(e: TProtocolException) =>
              iprot.readMessageEnd()
              Future.value(
                ProtocolExceptionResponse(
                  null,
                  exception("getModel", seqid, TApplicationException.PROTOCOL_ERROR, e.getMessage),
                  new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage)))
            case _ =>
              res
          }
        }
      }
    
      val serdeFilter = new finagle$Filter[(TProtocol, Int), RichResponse[GetModel.Args, GetModel.Result], GetModel.Args, GetModel.SuccessType] {
        def apply(
          request: (TProtocol, Int),
          service: finagle$Service[GetModel.Args, GetModel.SuccessType]
        ): Future[RichResponse[GetModel.Args, GetModel.Result]] = {
          val iprot = request._1
          val seqid = request._2
          val args = GetModel.Args.decode(iprot)
          iprot.readMessageEnd()
          val res = service(args)
          res.transform {
            case _root_.com.twitter.util.Return(value) =>
              val methodResult = GetModel.Result(success = Some(value))
              Future.value(
                SuccessfulResponse(
                  args,
                  reply("getModel", seqid, methodResult),
                  methodResult))
            case _root_.com.twitter.util.Throw(e: modeldb.ResourceNotFoundException) => {
              Future.value(
                ThriftExceptionResponse(
                  args,
                  reply("getModel", seqid, GetModel.Result(rnfEx = Some(e))),
                  e))
            }
            case _root_.com.twitter.util.Throw(e: modeldb.ServerLogicException) => {
              Future.value(
                ThriftExceptionResponse(
                  args,
                  reply("getModel", seqid, GetModel.Result(svEx = Some(e))),
                  e))
            }
            case t @ _root_.com.twitter.util.Throw(_) =>
              Future.const(t.cast[RichResponse[GetModel.Args, GetModel.Result]])
          }
        }
      }
    
      statsFilter.andThen(protocolExnFilter).andThen(serdeFilter)
    }
    val getRunsInExperiment: finagle$Filter[(TProtocol, Int), Array[Byte], GetRunsInExperiment.Args, GetRunsInExperiment.SuccessType] = {
      val statsFilter: finagle$Filter[(TProtocol, Int), Array[Byte], (TProtocol, Int), RichResponse[GetRunsInExperiment.Args, GetRunsInExperiment.Result]] = perMethodStatsFilter(GetRunsInExperiment)
    
      val protocolExnFilter = new SimpleFilter[(TProtocol, Int), RichResponse[GetRunsInExperiment.Args, GetRunsInExperiment.Result]] {
        def apply(
          request: (TProtocol, Int),
          service: finagle$Service[(TProtocol, Int), RichResponse[GetRunsInExperiment.Args, GetRunsInExperiment.Result]]
        ): Future[RichResponse[GetRunsInExperiment.Args, GetRunsInExperiment.Result]] = {
          val iprot = request._1
          val seqid = request._2
          val res = service(request)
          res.transform {
            case _root_.com.twitter.util.Throw(e: TProtocolException) =>
              iprot.readMessageEnd()
              Future.value(
                ProtocolExceptionResponse(
                  null,
                  exception("getRunsInExperiment", seqid, TApplicationException.PROTOCOL_ERROR, e.getMessage),
                  new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage)))
            case _ =>
              res
          }
        }
      }
    
      val serdeFilter = new finagle$Filter[(TProtocol, Int), RichResponse[GetRunsInExperiment.Args, GetRunsInExperiment.Result], GetRunsInExperiment.Args, GetRunsInExperiment.SuccessType] {
        def apply(
          request: (TProtocol, Int),
          service: finagle$Service[GetRunsInExperiment.Args, GetRunsInExperiment.SuccessType]
        ): Future[RichResponse[GetRunsInExperiment.Args, GetRunsInExperiment.Result]] = {
          val iprot = request._1
          val seqid = request._2
          val args = GetRunsInExperiment.Args.decode(iprot)
          iprot.readMessageEnd()
          val res = service(args)
          res.transform {
            case _root_.com.twitter.util.Return(value) =>
              val methodResult = GetRunsInExperiment.Result(success = Some(value))
              Future.value(
                SuccessfulResponse(
                  args,
                  reply("getRunsInExperiment", seqid, methodResult),
                  methodResult))
            case _root_.com.twitter.util.Throw(e: modeldb.ServerLogicException) => {
              Future.value(
                ThriftExceptionResponse(
                  args,
                  reply("getRunsInExperiment", seqid, GetRunsInExperiment.Result(svEx = Some(e))),
                  e))
            }
            case t @ _root_.com.twitter.util.Throw(_) =>
              Future.const(t.cast[RichResponse[GetRunsInExperiment.Args, GetRunsInExperiment.Result]])
          }
        }
      }
    
      statsFilter.andThen(protocolExnFilter).andThen(serdeFilter)
    }
    val getRunsAndExperimentsInProject: finagle$Filter[(TProtocol, Int), Array[Byte], GetRunsAndExperimentsInProject.Args, GetRunsAndExperimentsInProject.SuccessType] = {
      val statsFilter: finagle$Filter[(TProtocol, Int), Array[Byte], (TProtocol, Int), RichResponse[GetRunsAndExperimentsInProject.Args, GetRunsAndExperimentsInProject.Result]] = perMethodStatsFilter(GetRunsAndExperimentsInProject)
    
      val protocolExnFilter = new SimpleFilter[(TProtocol, Int), RichResponse[GetRunsAndExperimentsInProject.Args, GetRunsAndExperimentsInProject.Result]] {
        def apply(
          request: (TProtocol, Int),
          service: finagle$Service[(TProtocol, Int), RichResponse[GetRunsAndExperimentsInProject.Args, GetRunsAndExperimentsInProject.Result]]
        ): Future[RichResponse[GetRunsAndExperimentsInProject.Args, GetRunsAndExperimentsInProject.Result]] = {
          val iprot = request._1
          val seqid = request._2
          val res = service(request)
          res.transform {
            case _root_.com.twitter.util.Throw(e: TProtocolException) =>
              iprot.readMessageEnd()
              Future.value(
                ProtocolExceptionResponse(
                  null,
                  exception("getRunsAndExperimentsInProject", seqid, TApplicationException.PROTOCOL_ERROR, e.getMessage),
                  new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage)))
            case _ =>
              res
          }
        }
      }
    
      val serdeFilter = new finagle$Filter[(TProtocol, Int), RichResponse[GetRunsAndExperimentsInProject.Args, GetRunsAndExperimentsInProject.Result], GetRunsAndExperimentsInProject.Args, GetRunsAndExperimentsInProject.SuccessType] {
        def apply(
          request: (TProtocol, Int),
          service: finagle$Service[GetRunsAndExperimentsInProject.Args, GetRunsAndExperimentsInProject.SuccessType]
        ): Future[RichResponse[GetRunsAndExperimentsInProject.Args, GetRunsAndExperimentsInProject.Result]] = {
          val iprot = request._1
          val seqid = request._2
          val args = GetRunsAndExperimentsInProject.Args.decode(iprot)
          iprot.readMessageEnd()
          val res = service(args)
          res.transform {
            case _root_.com.twitter.util.Return(value) =>
              val methodResult = GetRunsAndExperimentsInProject.Result(success = Some(value))
              Future.value(
                SuccessfulResponse(
                  args,
                  reply("getRunsAndExperimentsInProject", seqid, methodResult),
                  methodResult))
            case _root_.com.twitter.util.Throw(e: modeldb.ServerLogicException) => {
              Future.value(
                ThriftExceptionResponse(
                  args,
                  reply("getRunsAndExperimentsInProject", seqid, GetRunsAndExperimentsInProject.Result(svEx = Some(e))),
                  e))
            }
            case t @ _root_.com.twitter.util.Throw(_) =>
              Future.const(t.cast[RichResponse[GetRunsAndExperimentsInProject.Args, GetRunsAndExperimentsInProject.Result]])
          }
        }
      }
    
      statsFilter.andThen(protocolExnFilter).andThen(serdeFilter)
    }
    val getProjectOverviews: finagle$Filter[(TProtocol, Int), Array[Byte], GetProjectOverviews.Args, GetProjectOverviews.SuccessType] = {
      val statsFilter: finagle$Filter[(TProtocol, Int), Array[Byte], (TProtocol, Int), RichResponse[GetProjectOverviews.Args, GetProjectOverviews.Result]] = perMethodStatsFilter(GetProjectOverviews)
    
      val protocolExnFilter = new SimpleFilter[(TProtocol, Int), RichResponse[GetProjectOverviews.Args, GetProjectOverviews.Result]] {
        def apply(
          request: (TProtocol, Int),
          service: finagle$Service[(TProtocol, Int), RichResponse[GetProjectOverviews.Args, GetProjectOverviews.Result]]
        ): Future[RichResponse[GetProjectOverviews.Args, GetProjectOverviews.Result]] = {
          val iprot = request._1
          val seqid = request._2
          val res = service(request)
          res.transform {
            case _root_.com.twitter.util.Throw(e: TProtocolException) =>
              iprot.readMessageEnd()
              Future.value(
                ProtocolExceptionResponse(
                  null,
                  exception("getProjectOverviews", seqid, TApplicationException.PROTOCOL_ERROR, e.getMessage),
                  new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage)))
            case _ =>
              res
          }
        }
      }
    
      val serdeFilter = new finagle$Filter[(TProtocol, Int), RichResponse[GetProjectOverviews.Args, GetProjectOverviews.Result], GetProjectOverviews.Args, GetProjectOverviews.SuccessType] {
        def apply(
          request: (TProtocol, Int),
          service: finagle$Service[GetProjectOverviews.Args, GetProjectOverviews.SuccessType]
        ): Future[RichResponse[GetProjectOverviews.Args, GetProjectOverviews.Result]] = {
          val iprot = request._1
          val seqid = request._2
          val args = GetProjectOverviews.Args.decode(iprot)
          iprot.readMessageEnd()
          val res = service(args)
          res.transform {
            case _root_.com.twitter.util.Return(value) =>
              val methodResult = GetProjectOverviews.Result(success = Some(value))
              Future.value(
                SuccessfulResponse(
                  args,
                  reply("getProjectOverviews", seqid, methodResult),
                  methodResult))
            case _root_.com.twitter.util.Throw(e: modeldb.ServerLogicException) => {
              Future.value(
                ThriftExceptionResponse(
                  args,
                  reply("getProjectOverviews", seqid, GetProjectOverviews.Result(svEx = Some(e))),
                  e))
            }
            case t @ _root_.com.twitter.util.Throw(_) =>
              Future.const(t.cast[RichResponse[GetProjectOverviews.Args, GetProjectOverviews.Result]])
          }
        }
      }
    
      statsFilter.andThen(protocolExnFilter).andThen(serdeFilter)
    }
    val getExperimentRunDetails: finagle$Filter[(TProtocol, Int), Array[Byte], GetExperimentRunDetails.Args, GetExperimentRunDetails.SuccessType] = {
      val statsFilter: finagle$Filter[(TProtocol, Int), Array[Byte], (TProtocol, Int), RichResponse[GetExperimentRunDetails.Args, GetExperimentRunDetails.Result]] = perMethodStatsFilter(GetExperimentRunDetails)
    
      val protocolExnFilter = new SimpleFilter[(TProtocol, Int), RichResponse[GetExperimentRunDetails.Args, GetExperimentRunDetails.Result]] {
        def apply(
          request: (TProtocol, Int),
          service: finagle$Service[(TProtocol, Int), RichResponse[GetExperimentRunDetails.Args, GetExperimentRunDetails.Result]]
        ): Future[RichResponse[GetExperimentRunDetails.Args, GetExperimentRunDetails.Result]] = {
          val iprot = request._1
          val seqid = request._2
          val res = service(request)
          res.transform {
            case _root_.com.twitter.util.Throw(e: TProtocolException) =>
              iprot.readMessageEnd()
              Future.value(
                ProtocolExceptionResponse(
                  null,
                  exception("getExperimentRunDetails", seqid, TApplicationException.PROTOCOL_ERROR, e.getMessage),
                  new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage)))
            case _ =>
              res
          }
        }
      }
    
      val serdeFilter = new finagle$Filter[(TProtocol, Int), RichResponse[GetExperimentRunDetails.Args, GetExperimentRunDetails.Result], GetExperimentRunDetails.Args, GetExperimentRunDetails.SuccessType] {
        def apply(
          request: (TProtocol, Int),
          service: finagle$Service[GetExperimentRunDetails.Args, GetExperimentRunDetails.SuccessType]
        ): Future[RichResponse[GetExperimentRunDetails.Args, GetExperimentRunDetails.Result]] = {
          val iprot = request._1
          val seqid = request._2
          val args = GetExperimentRunDetails.Args.decode(iprot)
          iprot.readMessageEnd()
          val res = service(args)
          res.transform {
            case _root_.com.twitter.util.Return(value) =>
              val methodResult = GetExperimentRunDetails.Result(success = Some(value))
              Future.value(
                SuccessfulResponse(
                  args,
                  reply("getExperimentRunDetails", seqid, methodResult),
                  methodResult))
            case _root_.com.twitter.util.Throw(e: modeldb.ServerLogicException) => {
              Future.value(
                ThriftExceptionResponse(
                  args,
                  reply("getExperimentRunDetails", seqid, GetExperimentRunDetails.Result(svEx = Some(e))),
                  e))
            }
            case _root_.com.twitter.util.Throw(e: modeldb.ResourceNotFoundException) => {
              Future.value(
                ThriftExceptionResponse(
                  args,
                  reply("getExperimentRunDetails", seqid, GetExperimentRunDetails.Result(rnfEx = Some(e))),
                  e))
            }
            case t @ _root_.com.twitter.util.Throw(_) =>
              Future.const(t.cast[RichResponse[GetExperimentRunDetails.Args, GetExperimentRunDetails.Result]])
          }
        }
      }
    
      statsFilter.andThen(protocolExnFilter).andThen(serdeFilter)
    }
    val originalFeatures: finagle$Filter[(TProtocol, Int), Array[Byte], OriginalFeatures.Args, OriginalFeatures.SuccessType] = {
      val statsFilter: finagle$Filter[(TProtocol, Int), Array[Byte], (TProtocol, Int), RichResponse[OriginalFeatures.Args, OriginalFeatures.Result]] = perMethodStatsFilter(OriginalFeatures)
    
      val protocolExnFilter = new SimpleFilter[(TProtocol, Int), RichResponse[OriginalFeatures.Args, OriginalFeatures.Result]] {
        def apply(
          request: (TProtocol, Int),
          service: finagle$Service[(TProtocol, Int), RichResponse[OriginalFeatures.Args, OriginalFeatures.Result]]
        ): Future[RichResponse[OriginalFeatures.Args, OriginalFeatures.Result]] = {
          val iprot = request._1
          val seqid = request._2
          val res = service(request)
          res.transform {
            case _root_.com.twitter.util.Throw(e: TProtocolException) =>
              iprot.readMessageEnd()
              Future.value(
                ProtocolExceptionResponse(
                  null,
                  exception("originalFeatures", seqid, TApplicationException.PROTOCOL_ERROR, e.getMessage),
                  new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage)))
            case _ =>
              res
          }
        }
      }
    
      val serdeFilter = new finagle$Filter[(TProtocol, Int), RichResponse[OriginalFeatures.Args, OriginalFeatures.Result], OriginalFeatures.Args, OriginalFeatures.SuccessType] {
        def apply(
          request: (TProtocol, Int),
          service: finagle$Service[OriginalFeatures.Args, OriginalFeatures.SuccessType]
        ): Future[RichResponse[OriginalFeatures.Args, OriginalFeatures.Result]] = {
          val iprot = request._1
          val seqid = request._2
          val args = OriginalFeatures.Args.decode(iprot)
          iprot.readMessageEnd()
          val res = service(args)
          res.transform {
            case _root_.com.twitter.util.Return(value) =>
              val methodResult = OriginalFeatures.Result(success = Some(value))
              Future.value(
                SuccessfulResponse(
                  args,
                  reply("originalFeatures", seqid, methodResult),
                  methodResult))
            case _root_.com.twitter.util.Throw(e: modeldb.ResourceNotFoundException) => {
              Future.value(
                ThriftExceptionResponse(
                  args,
                  reply("originalFeatures", seqid, OriginalFeatures.Result(rnfEx = Some(e))),
                  e))
            }
            case _root_.com.twitter.util.Throw(e: modeldb.ServerLogicException) => {
              Future.value(
                ThriftExceptionResponse(
                  args,
                  reply("originalFeatures", seqid, OriginalFeatures.Result(svEx = Some(e))),
                  e))
            }
            case t @ _root_.com.twitter.util.Throw(_) =>
              Future.const(t.cast[RichResponse[OriginalFeatures.Args, OriginalFeatures.Result]])
          }
        }
      }
    
      statsFilter.andThen(protocolExnFilter).andThen(serdeFilter)
    }
    val storeTreeModel: finagle$Filter[(TProtocol, Int), Array[Byte], StoreTreeModel.Args, StoreTreeModel.SuccessType] = {
      val statsFilter: finagle$Filter[(TProtocol, Int), Array[Byte], (TProtocol, Int), RichResponse[StoreTreeModel.Args, StoreTreeModel.Result]] = perMethodStatsFilter(StoreTreeModel)
    
      val protocolExnFilter = new SimpleFilter[(TProtocol, Int), RichResponse[StoreTreeModel.Args, StoreTreeModel.Result]] {
        def apply(
          request: (TProtocol, Int),
          service: finagle$Service[(TProtocol, Int), RichResponse[StoreTreeModel.Args, StoreTreeModel.Result]]
        ): Future[RichResponse[StoreTreeModel.Args, StoreTreeModel.Result]] = {
          val iprot = request._1
          val seqid = request._2
          val res = service(request)
          res.transform {
            case _root_.com.twitter.util.Throw(e: TProtocolException) =>
              iprot.readMessageEnd()
              Future.value(
                ProtocolExceptionResponse(
                  null,
                  exception("storeTreeModel", seqid, TApplicationException.PROTOCOL_ERROR, e.getMessage),
                  new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage)))
            case _ =>
              res
          }
        }
      }
    
      val serdeFilter = new finagle$Filter[(TProtocol, Int), RichResponse[StoreTreeModel.Args, StoreTreeModel.Result], StoreTreeModel.Args, StoreTreeModel.SuccessType] {
        def apply(
          request: (TProtocol, Int),
          service: finagle$Service[StoreTreeModel.Args, StoreTreeModel.SuccessType]
        ): Future[RichResponse[StoreTreeModel.Args, StoreTreeModel.Result]] = {
          val iprot = request._1
          val seqid = request._2
          val args = StoreTreeModel.Args.decode(iprot)
          iprot.readMessageEnd()
          val res = service(args)
          res.transform {
            case _root_.com.twitter.util.Return(value) =>
              val methodResult = StoreTreeModel.Result(success = Some(value))
              Future.value(
                SuccessfulResponse(
                  args,
                  reply("storeTreeModel", seqid, methodResult),
                  methodResult))
            case _root_.com.twitter.util.Throw(e: modeldb.ResourceNotFoundException) => {
              Future.value(
                ThriftExceptionResponse(
                  args,
                  reply("storeTreeModel", seqid, StoreTreeModel.Result(rnfEx = Some(e))),
                  e))
            }
            case _root_.com.twitter.util.Throw(e: modeldb.ServerLogicException) => {
              Future.value(
                ThriftExceptionResponse(
                  args,
                  reply("storeTreeModel", seqid, StoreTreeModel.Result(svEx = Some(e))),
                  e))
            }
            case t @ _root_.com.twitter.util.Throw(_) =>
              Future.const(t.cast[RichResponse[StoreTreeModel.Args, StoreTreeModel.Result]])
          }
        }
      }
    
      statsFilter.andThen(protocolExnFilter).andThen(serdeFilter)
    }
    val storePipelineTransformEvent: finagle$Filter[(TProtocol, Int), Array[Byte], StorePipelineTransformEvent.Args, StorePipelineTransformEvent.SuccessType] = {
      val statsFilter: finagle$Filter[(TProtocol, Int), Array[Byte], (TProtocol, Int), RichResponse[StorePipelineTransformEvent.Args, StorePipelineTransformEvent.Result]] = perMethodStatsFilter(StorePipelineTransformEvent)
    
      val protocolExnFilter = new SimpleFilter[(TProtocol, Int), RichResponse[StorePipelineTransformEvent.Args, StorePipelineTransformEvent.Result]] {
        def apply(
          request: (TProtocol, Int),
          service: finagle$Service[(TProtocol, Int), RichResponse[StorePipelineTransformEvent.Args, StorePipelineTransformEvent.Result]]
        ): Future[RichResponse[StorePipelineTransformEvent.Args, StorePipelineTransformEvent.Result]] = {
          val iprot = request._1
          val seqid = request._2
          val res = service(request)
          res.transform {
            case _root_.com.twitter.util.Throw(e: TProtocolException) =>
              iprot.readMessageEnd()
              Future.value(
                ProtocolExceptionResponse(
                  null,
                  exception("storePipelineTransformEvent", seqid, TApplicationException.PROTOCOL_ERROR, e.getMessage),
                  new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage)))
            case _ =>
              res
          }
        }
      }
    
      val serdeFilter = new finagle$Filter[(TProtocol, Int), RichResponse[StorePipelineTransformEvent.Args, StorePipelineTransformEvent.Result], StorePipelineTransformEvent.Args, StorePipelineTransformEvent.SuccessType] {
        def apply(
          request: (TProtocol, Int),
          service: finagle$Service[StorePipelineTransformEvent.Args, StorePipelineTransformEvent.SuccessType]
        ): Future[RichResponse[StorePipelineTransformEvent.Args, StorePipelineTransformEvent.Result]] = {
          val iprot = request._1
          val seqid = request._2
          val args = StorePipelineTransformEvent.Args.decode(iprot)
          iprot.readMessageEnd()
          val res = service(args)
          res.transform {
            case _root_.com.twitter.util.Return(value) =>
              val methodResult = StorePipelineTransformEvent.Result(success = Some(value))
              Future.value(
                SuccessfulResponse(
                  args,
                  reply("storePipelineTransformEvent", seqid, methodResult),
                  methodResult))
            case _root_.com.twitter.util.Throw(e: modeldb.InvalidExperimentRunException) => {
              Future.value(
                ThriftExceptionResponse(
                  args,
                  reply("storePipelineTransformEvent", seqid, StorePipelineTransformEvent.Result(ierEx = Some(e))),
                  e))
            }
            case _root_.com.twitter.util.Throw(e: modeldb.ServerLogicException) => {
              Future.value(
                ThriftExceptionResponse(
                  args,
                  reply("storePipelineTransformEvent", seqid, StorePipelineTransformEvent.Result(svEx = Some(e))),
                  e))
            }
            case t @ _root_.com.twitter.util.Throw(_) =>
              Future.const(t.cast[RichResponse[StorePipelineTransformEvent.Args, StorePipelineTransformEvent.Result]])
          }
        }
      }
    
      statsFilter.andThen(protocolExnFilter).andThen(serdeFilter)
    }
    val computeModelAncestry: finagle$Filter[(TProtocol, Int), Array[Byte], ComputeModelAncestry.Args, ComputeModelAncestry.SuccessType] = {
      val statsFilter: finagle$Filter[(TProtocol, Int), Array[Byte], (TProtocol, Int), RichResponse[ComputeModelAncestry.Args, ComputeModelAncestry.Result]] = perMethodStatsFilter(ComputeModelAncestry)
    
      val protocolExnFilter = new SimpleFilter[(TProtocol, Int), RichResponse[ComputeModelAncestry.Args, ComputeModelAncestry.Result]] {
        def apply(
          request: (TProtocol, Int),
          service: finagle$Service[(TProtocol, Int), RichResponse[ComputeModelAncestry.Args, ComputeModelAncestry.Result]]
        ): Future[RichResponse[ComputeModelAncestry.Args, ComputeModelAncestry.Result]] = {
          val iprot = request._1
          val seqid = request._2
          val res = service(request)
          res.transform {
            case _root_.com.twitter.util.Throw(e: TProtocolException) =>
              iprot.readMessageEnd()
              Future.value(
                ProtocolExceptionResponse(
                  null,
                  exception("computeModelAncestry", seqid, TApplicationException.PROTOCOL_ERROR, e.getMessage),
                  new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage)))
            case _ =>
              res
          }
        }
      }
    
      val serdeFilter = new finagle$Filter[(TProtocol, Int), RichResponse[ComputeModelAncestry.Args, ComputeModelAncestry.Result], ComputeModelAncestry.Args, ComputeModelAncestry.SuccessType] {
        def apply(
          request: (TProtocol, Int),
          service: finagle$Service[ComputeModelAncestry.Args, ComputeModelAncestry.SuccessType]
        ): Future[RichResponse[ComputeModelAncestry.Args, ComputeModelAncestry.Result]] = {
          val iprot = request._1
          val seqid = request._2
          val args = ComputeModelAncestry.Args.decode(iprot)
          iprot.readMessageEnd()
          val res = service(args)
          res.transform {
            case _root_.com.twitter.util.Return(value) =>
              val methodResult = ComputeModelAncestry.Result(success = Some(value))
              Future.value(
                SuccessfulResponse(
                  args,
                  reply("computeModelAncestry", seqid, methodResult),
                  methodResult))
            case _root_.com.twitter.util.Throw(e: modeldb.ResourceNotFoundException) => {
              Future.value(
                ThriftExceptionResponse(
                  args,
                  reply("computeModelAncestry", seqid, ComputeModelAncestry.Result(rnfEx = Some(e))),
                  e))
            }
            case _root_.com.twitter.util.Throw(e: modeldb.ServerLogicException) => {
              Future.value(
                ThriftExceptionResponse(
                  args,
                  reply("computeModelAncestry", seqid, ComputeModelAncestry.Result(svEx = Some(e))),
                  e))
            }
            case t @ _root_.com.twitter.util.Throw(_) =>
              Future.const(t.cast[RichResponse[ComputeModelAncestry.Args, ComputeModelAncestry.Result]])
          }
        }
      }
    
      statsFilter.andThen(protocolExnFilter).andThen(serdeFilter)
    }
    val extractPipeline: finagle$Filter[(TProtocol, Int), Array[Byte], ExtractPipeline.Args, ExtractPipeline.SuccessType] = {
      val statsFilter: finagle$Filter[(TProtocol, Int), Array[Byte], (TProtocol, Int), RichResponse[ExtractPipeline.Args, ExtractPipeline.Result]] = perMethodStatsFilter(ExtractPipeline)
    
      val protocolExnFilter = new SimpleFilter[(TProtocol, Int), RichResponse[ExtractPipeline.Args, ExtractPipeline.Result]] {
        def apply(
          request: (TProtocol, Int),
          service: finagle$Service[(TProtocol, Int), RichResponse[ExtractPipeline.Args, ExtractPipeline.Result]]
        ): Future[RichResponse[ExtractPipeline.Args, ExtractPipeline.Result]] = {
          val iprot = request._1
          val seqid = request._2
          val res = service(request)
          res.transform {
            case _root_.com.twitter.util.Throw(e: TProtocolException) =>
              iprot.readMessageEnd()
              Future.value(
                ProtocolExceptionResponse(
                  null,
                  exception("extractPipeline", seqid, TApplicationException.PROTOCOL_ERROR, e.getMessage),
                  new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage)))
            case _ =>
              res
          }
        }
      }
    
      val serdeFilter = new finagle$Filter[(TProtocol, Int), RichResponse[ExtractPipeline.Args, ExtractPipeline.Result], ExtractPipeline.Args, ExtractPipeline.SuccessType] {
        def apply(
          request: (TProtocol, Int),
          service: finagle$Service[ExtractPipeline.Args, ExtractPipeline.SuccessType]
        ): Future[RichResponse[ExtractPipeline.Args, ExtractPipeline.Result]] = {
          val iprot = request._1
          val seqid = request._2
          val args = ExtractPipeline.Args.decode(iprot)
          iprot.readMessageEnd()
          val res = service(args)
          res.transform {
            case _root_.com.twitter.util.Return(value) =>
              val methodResult = ExtractPipeline.Result(success = Some(value))
              Future.value(
                SuccessfulResponse(
                  args,
                  reply("extractPipeline", seqid, methodResult),
                  methodResult))
            case _root_.com.twitter.util.Throw(e: modeldb.ResourceNotFoundException) => {
              Future.value(
                ThriftExceptionResponse(
                  args,
                  reply("extractPipeline", seqid, ExtractPipeline.Result(rnfEx = Some(e))),
                  e))
            }
            case _root_.com.twitter.util.Throw(e: modeldb.ServerLogicException) => {
              Future.value(
                ThriftExceptionResponse(
                  args,
                  reply("extractPipeline", seqid, ExtractPipeline.Result(svEx = Some(e))),
                  e))
            }
            case t @ _root_.com.twitter.util.Throw(_) =>
              Future.const(t.cast[RichResponse[ExtractPipeline.Args, ExtractPipeline.Result]])
          }
        }
      }
    
      statsFilter.andThen(protocolExnFilter).andThen(serdeFilter)
    }
  }

}
