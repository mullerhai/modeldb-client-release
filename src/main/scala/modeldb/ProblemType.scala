/**
 * Generated by Scrooge
 *   version: 18.10.0
 *   rev: dda071e1412b53f4bfdebc19e474f584e475d475
 *   built at: 20181018-174244
 */
package modeldb

import com.twitter.scrooge.ThriftEnum
import scala.collection.immutable.{Map => immutable$Map}


@javax.annotation.Generated(value = Array("com.twitter.scrooge.Compiler"))
case object ProblemType extends _root_.com.twitter.scrooge.ThriftEnumObject[ProblemType] {

  val annotations: immutable$Map[String, String] = immutable$Map.empty

  
  case object Undefined extends modeldb.ProblemType {
    val value: Int = 0
    val name: String = "Undefined"
    val originalName: String = "UNDEFINED"
    val annotations: immutable$Map[String, String] = immutable$Map.empty
  }

  private[this] val _SomeUndefined = _root_.scala.Some(modeldb.ProblemType.Undefined)
  
  case object BinaryClassification extends modeldb.ProblemType {
    val value: Int = 1
    val name: String = "BinaryClassification"
    val originalName: String = "BINARY_CLASSIFICATION"
    val annotations: immutable$Map[String, String] = immutable$Map.empty
  }

  private[this] val _SomeBinaryClassification = _root_.scala.Some(modeldb.ProblemType.BinaryClassification)
  
  case object MulticlassClassification extends modeldb.ProblemType {
    val value: Int = 2
    val name: String = "MulticlassClassification"
    val originalName: String = "MULTICLASS_CLASSIFICATION"
    val annotations: immutable$Map[String, String] = immutable$Map.empty
  }

  private[this] val _SomeMulticlassClassification = _root_.scala.Some(modeldb.ProblemType.MulticlassClassification)
  
  case object Regression extends modeldb.ProblemType {
    val value: Int = 3
    val name: String = "Regression"
    val originalName: String = "REGRESSION"
    val annotations: immutable$Map[String, String] = immutable$Map.empty
  }

  private[this] val _SomeRegression = _root_.scala.Some(modeldb.ProblemType.Regression)
  
  case object Clustering extends modeldb.ProblemType {
    val value: Int = 4
    val name: String = "Clustering"
    val originalName: String = "CLUSTERING"
    val annotations: immutable$Map[String, String] = immutable$Map.empty
  }

  private[this] val _SomeClustering = _root_.scala.Some(modeldb.ProblemType.Clustering)
  
  case object Recommendation extends modeldb.ProblemType {
    val value: Int = 5
    val name: String = "Recommendation"
    val originalName: String = "RECOMMENDATION"
    val annotations: immutable$Map[String, String] = immutable$Map.empty
  }

  private[this] val _SomeRecommendation = _root_.scala.Some(modeldb.ProblemType.Recommendation)

  case class EnumUnknownProblemType(value: Int)
    extends modeldb.ProblemType with _root_.com.twitter.scrooge.EnumItemUnknown
  {
    val name: String = "EnumUnknownProblemType" + value
    def originalName: String = name
  }

  /**
   * Find the enum by its integer value, as defined in the Thrift IDL.
   */
  def apply(value: Int): modeldb.ProblemType =
    value match {
      case 0 => modeldb.ProblemType.Undefined
      case 1 => modeldb.ProblemType.BinaryClassification
      case 2 => modeldb.ProblemType.MulticlassClassification
      case 3 => modeldb.ProblemType.Regression
      case 4 => modeldb.ProblemType.Clustering
      case 5 => modeldb.ProblemType.Recommendation
      case _ => throw new NoSuchElementException(value.toString)
    }

  /**
   * Find the enum by its integer value, as defined in the Thrift IDL.
   * returns an EnumUnknownProblemType(value) if the value is not found.
   * In particular this allows ignoring new values added to an enum
   * in the IDL on the producer side when the consumer was not updated.
   */
  def getOrUnknown(value: Int): modeldb.ProblemType =
    get(value) match {
      case _root_.scala.Some(e) => e
      case _root_.scala.None => EnumUnknownProblemType(value)
    }

  /**
   * Find the enum by its integer value, as defined in the Thrift IDL.
   * Returns None if the value is not found
   */
  def get(value: Int): _root_.scala.Option[modeldb.ProblemType] =
    value match {
      case 0 => _SomeUndefined
      case 1 => _SomeBinaryClassification
      case 2 => _SomeMulticlassClassification
      case 3 => _SomeRegression
      case 4 => _SomeClustering
      case 5 => _SomeRecommendation
      case _ => _root_.scala.None
    }

  def valueOf(name: String): _root_.scala.Option[modeldb.ProblemType] =
    name.toLowerCase match {
      case "undefined" => _SomeUndefined
      case "binaryclassification" => _SomeBinaryClassification
      case "multiclassclassification" => _SomeMulticlassClassification
      case "regression" => _SomeRegression
      case "clustering" => _SomeClustering
      case "recommendation" => _SomeRecommendation
      case _ => _root_.scala.None
    }

  lazy val list: List[modeldb.ProblemType] = scala.List[modeldb.ProblemType](
    modeldb.ProblemType.Undefined,
    modeldb.ProblemType.BinaryClassification,
    modeldb.ProblemType.MulticlassClassification,
    modeldb.ProblemType.Regression,
    modeldb.ProblemType.Clustering,
    modeldb.ProblemType.Recommendation
  )
}



@javax.annotation.Generated(value = Array("com.twitter.scrooge.Compiler"))
sealed trait ProblemType extends ThriftEnum with Serializable